<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Perspective Explorer - Learn Spatial Reasoning</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background-color: #f0f8ff;
            overflow: hidden;
            color: #333;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #header {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: #4b0082;
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        #title {
            font-size: 24px;
            font-weight: bold;
        }

        #game-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #left-panel {
            width: 300px;
            background-color: #e6e6fa;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        #right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #quiz-container {
            height: 300px;
            background-color: #fff;
            padding: 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .parameter-group {
            margin-bottom: 20px;
            background-color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .parameter-group h3 {
            margin-top: 0;
            color: #4b0082;
        }

        .parameter {
            margin: 10px 0;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="range"], select {
            width: 100%;
        }

        input[type="number"] {
            width: 60px;
        }

        .character {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 150px;
            z-index: 100;
        }

        .speech-bubble {
            position: absolute;
            bottom: 160px;
            right: 20px;
            background-color: white;
            border-radius: 20px;
            padding: 15px;
            width: 250px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
            transition: opacity 0.5s;
        }

        .speech-bubble:after {
            content: "";
            position: absolute;
            bottom: -15px;
            right: 30px;
            border-width: 15px 15px 0;
            border-style: solid;
            border-color: white transparent;
        }

        #quiz-question {
            font-size: 18px;
            margin-bottom: 15px;
        }

        #options-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .option {
            width: 120px;
            height: 120px;
            border: 3px solid #ccc;
            border-radius: 10px;
            margin: 10px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .option:hover {
            transform: scale(1.05);
        }

        .selected {
            border-color: #4b0082;
            box-shadow: 0 0 15px rgba(75, 0, 130, 0.5);
        }

        .correct {
            border-color: #00aa00;
            box-shadow: 0 0 15px rgba(0, 170, 0, 0.5);
        }

        .incorrect {
            border-color: #aa0000;
            box-shadow: 0 0 15px rgba(170, 0, 0, 0.5);
        }

        #progress-bar-container {
            height: 20px;
            width: 100%;
            background-color: #eee;
            border-radius: 10px;
            margin-top: auto;
            margin-bottom: 10px;
        }

        #progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4b0082;
            border-radius: 10px;
            transition: width 0.5s;
        }

        #score-container {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-weight: bold;
        }

        button {
            background-color: #4b0082;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
            margin-top: 10px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #6a0dad;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .view-button {
            margin: 5px;
            background-color: #6a0dad;
            font-size: 14px;
        }

        #view-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        #modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
        }

        #close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
            color: #333;
        }

        #help-button {
            background-color: #ffa500;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            z-index: 100;
        }

        #celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            opacity: 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="title">3D Perspective Explorer</div>
            <div id="level-display">Level: <span id="current-level">1</span></div>
        </div>
        <div id="game-container">
            <div id="left-panel">
                <div class="parameter-group">
                    <h3>Character</h3>
                    <div class="parameter">
                        <label for="character-select">Choose Your Guide:</label>
                        <select id="character-select">
                            <option value="professor">Professor Cube</option>
                            <option value="robot">Robo Vision</option>
                            <option value="wizard">Wizard Perspective</option>
                        </select>
                    </div>
                </div>

                <div class="parameter-group">
                    <h3>Game Settings</h3>
                    <div class="parameter">
                        <label for="difficulty">Difficulty:</label>
                        <select id="difficulty">
                            <option value="easy">Easy (2x2x2)</option>
                            <option value="medium" selected>Medium (3x3x3)</option>
                            <option value="hard">Hard (4x4x4)</option>
                            <option value="expert">Expert (5x5x5)</option>
                        </select>
                    </div>
                    <div class="parameter">
                        <label for="grid-visible">Show Grid:</label>
                        <input type="checkbox" id="grid-visible" checked>
                    </div>
                    <div class="parameter">
                        <label for="colors">Cube Colors:</label>
                        <select id="colors">
                            <option value="rainbow">Rainbow</option>
                            <option value="simple" selected>Simple</option>
                            <option value="grayscale">Grayscale</option>
                        </select>
                    </div>
                    <div class="parameter">
                        <label for="rotation-speed">Rotation Speed:</label>
                        <input type="range" id="rotation-speed" min="0" max="5" step="0.1" value="1">
                    </div>
                </div>

                <div class="parameter-group">
                    <h3>Advanced Settings</h3>
                    <div class="parameter">
                        <label for="viewpoint-hints">Show Viewpoint Hints:</label>
                        <input type="checkbox" id="viewpoint-hints" checked>
                    </div>
                    <div class="parameter">
                        <label for="camera-transition">Smooth Camera Transitions:</label>
                        <input type="checkbox" id="camera-transition" checked>
                    </div>
                    <div class="parameter">
                        <label for="shape-complexity">Shape Complexity:</label>
                        <input type="range" id="shape-complexity" min="1" max="5" step="1" value="2">
                    </div>
                </div>

                <button id="learn-more-btn">Learn About 3D Projection</button>
                <button id="reset-game-btn">Reset Game</button>
            </div>
            <div id="right-panel">
                <div id="canvas-container">
                    <div id="help-button">?</div>
                    <div id="view-buttons">
                        <button class="view-button" data-view="free">Free View</button>
                        <button class="view-button" data-view="top">Top View</button>
                        <button class="view-button" data-view="front">Front View</button>
                        <button class="view-button" data-view="right">Right View</button>
                    </div>
                </div>
                <div id="quiz-container">
                    <div id="quiz-question">Which of these is the correct view of the 3D model from the top?</div>
                    <div id="options-container">
                        <!-- Options will be generated here -->
                    </div>
                    <div id="progress-bar-container">
                        <div id="progress-bar"></div>
                    </div>
                    <div id="score-container">
                        <div id="score">Score: 0</div>
                        <button id="next-question-btn" disabled>Next Question</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="speech-bubble" id="speech-bubble" style="opacity: 0;">
        Hello! I'm Professor Cube. Let me guide you through the fascinating world of 3D shapes and perspectives!
    </div>

    <div id="modal">
        <div id="modal-content">
            <span id="close-modal">&times;</span>
            <h2>Understanding 3D Perspectives</h2>
            <div id="modal-body">
                <!-- Content will be inserted here -->
            </div>
        </div>
    </div>

    <div id="celebration"></div>

    <script>
        // Main game variables
        let scene, camera, renderer, controls;
        let mainObject, grid;
        let currentQuestion = 0;
        let score = 0;
        let totalQuestions = 10;
        let selectedOption = null;
        let currentLevel = 1;
        let questions = [];
        let currentCharacter = "professor";
        let rotationSpeed = 1;
        let viewTransitioning = false;
        
        // Initialize speech bubbles for different characters
        const characterDialogues = {
            professor: [
                "Welcome to 3D Perspective Explorer! I'm Professor Cube, and I'll help you master spatial reasoning.",
                "Look at the 3D shape and try to figure out how it would look from different angles.",
                "In IQ tests, you'll often need to visualize how 3D objects look from different viewpoints.",
                "Great job! You're getting better at visualizing 3D shapes in your mind.",
                "Try changing the view buttons to see the shape from different angles!",
                "The more you practice, the better your spatial reasoning will become.",
                "Did you know? Spatial reasoning is used by engineers, architects, and scientists every day!"
            ],
            robot: [
                "GREETINGS HUMAN! I AM ROBO VISION! MY SENSORS ARE CALIBRATED TO HELP YOU LEARN 3D PERSPECTIVES.",
                "PROCESSING... SHAPE ANALYSIS COMPLETE. CAN YOUR HUMAN BRAIN VISUALIZE THE CORRECT PERSPECTIVE?",
                "MY ALGORITHMS SUGGEST ANALYZING THE CUBE ARRANGEMENT SYSTEMATICALLY.",
                "EXCELLENT PERFORMANCE! YOUR SPATIAL REASONING CIRCUITS ARE FUNCTIONING AT 78% EFFICIENCY!",
                "TRY ACTIVATING THE DIFFERENT VIEW MODES TO ENHANCE YOUR UNDERSTANDING.",
                "SPATIAL REASONING CAPABILITY INCREASE DETECTED. CONTINUE TRAINING SEQUENCE!"
            ],
            wizard: [
                "Ah, a new apprentice! I am Wizard Perspective, master of spatial magic!",
                "To see through illusions, you must learn to view objects from all angles. This is true magic!",
                "Focus your mind's eye on the shape. Can you see how it transforms when viewed from different sides?",
                "Marvelous! Your inner eye grows stronger with each challenge.",
                "My magical view buttons will reveal the secrets of different perspectives!",
                "The greatest wizards can visualize complex objects in their mind. Practice, and you shall join their ranks!"
            ]
        };

        // DOM Elements
        const speechBubble = document.getElementById('speech-bubble');
        const characterSelect = document.getElementById('character-select');
        const difficultySelect = document.getElementById('difficulty');
        const gridVisibleCheckbox = document.getElementById('grid-visible');
        const colorsSelect = document.getElementById('colors');
        const rotationSpeedSlider = document.getElementById('rotation-speed');
        const viewpointHintsCheckbox = document.getElementById('viewpoint-hints');
        const cameraTransitionCheckbox = document.getElementById('camera-transition');
        const shapeComplexitySlider = document.getElementById('shape-complexity');
        const learnMoreBtn = document.getElementById('learn-more-btn');
        const resetGameBtn = document.getElementById('reset-game-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const quizQuestion = document.getElementById('quiz-question');
        const optionsContainer = document.getElementById('options-container');
        const progressBar = document.getElementById('progress-bar');
        const scoreElement = document.getElementById('score');
        const currentLevelElement = document.getElementById('current-level');
        const helpButton = document.getElementById('help-button');
        const modal = document.getElementById('modal');
        const closeModal = document.getElementById('close-modal');
        const modalBody = document.getElementById('modal-body');
        const viewButtons = document.querySelectorAll('.view-button');
        const celebrationContainer = document.getElementById('celebration');

        // Initialize the game
        init();
        animate();

        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f8ff);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Create grid helper
            grid = new THREE.GridHelper(10, 10, 0x000000, 0x888888);
            scene.add(grid);

            // Add axes helper for orientation
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Add OrbitControls for camera manipulation
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Generate initial game level
            generateLevel();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Setup event listeners
            setupEventListeners();

            // Show initial character dialogue
            updateCharacterDialogue();

            // Start with help modal
            showHelp();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Rotate main object if not in transition
            if (mainObject && !viewTransitioning) {
                mainObject.rotation.y += 0.005 * rotationSpeed;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Setup all event listeners
        function setupEventListeners() {
            // Character selection
            characterSelect.addEventListener('change', function() {
                currentCharacter = this.value;
                updateCharacterDialogue();
            });

            // Difficulty change
            difficultySelect.addEventListener('change', function() {
                resetGame();
            });

            // Grid visibility
            gridVisibleCheckbox.addEventListener('change', function() {
                grid.visible = this.checked;
            });

            // Color scheme
            colorsSelect.addEventListener('change', function() {
                updateColors();
            });

            // Rotation speed
            rotationSpeedSlider.addEventListener('input', function() {
                rotationSpeed = parseFloat(this.value);
            });

            // Shape complexity
            shapeComplexitySlider.addEventListener('change', function() {
                resetGame();
            });

            // Learn more button
            learnMoreBtn.addEventListener('click', function() {
                showLearnMoreModal();
            });

            // Reset game button
            resetGameBtn.addEventListener('click', function() {
                resetGame();
            });

            // Next question button
            nextQuestionBtn.addEventListener('click', function() {
                nextQuestion();
            });

            // Help button
            helpButton.addEventListener('click', function() {
                showHelp();
            });

            // Close modal
            closeModal.addEventListener('click', function() {
                hideModal();
            });

            // View buttons
            viewButtons.forEach(button => {
                button.addEventListener('click', function() {
                    changeView(this.getAttribute('data-view'));
                });
            });
        }

        // Generate a new game level
        function generateLevel() {
            // Clear previous shape if exists
            if (mainObject) {
                scene.remove(mainObject);
            }

            // Create a new group for the main object
            mainObject = new THREE.Group();
            scene.add(mainObject);

            // Determine grid size based on difficulty
            let gridSize;
            switch (difficultySelect.value) {
                case 'easy': gridSize = 2; break;
                case 'medium': gridSize = 3; break;
                case 'hard': gridSize = 4; break;
                case 'expert': gridSize = 5; break;
                default: gridSize = 3;
            }

            // Determine complexity (how many cubes to create)
            const complexity = parseInt(shapeComplexitySlider.value);
            const maxCubes = Math.floor(gridSize * gridSize * gridSize * (complexity / 5));
            
            // Create cubes in a structured pattern based on complexity
            const cubes = [];
            
            // Always ensure a base platform of cubes
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    const cubeGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                    const material = createCubeMaterial();
                    
                    const cube = new THREE.Mesh(cubeGeometry, material);
                    cube.position.set(x - (gridSize-1)/2, 0, z - (gridSize-1)/2);
                    mainObject.add(cube);
                    cubes.push(cube);
                }
            }
            
            // Add additional cubes based on complexity
            const remainingCubes = maxCubes - gridSize * gridSize;
            if (remainingCubes > 0) {
                for (let i = 0; i < remainingCubes; i++) {
                    // Create vertical stacks in a structured way rather than random
                    const baseIndex = Math.floor(Math.random() * (gridSize * gridSize));
                    const baseX = cubes[baseIndex].position.x;
                    const baseZ = cubes[baseIndex].position.z;
                    const height = Math.floor(Math.random() * (gridSize - 1)) + 1;
                    
                    const cubeGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                    const material = createCubeMaterial();
                    
                    const cube = new THREE.Mesh(cubeGeometry, material);
                    cube.position.set(baseX, height, baseZ);
                    mainObject.add(cube);
                }
            }

            // Center the object
            mainObject.position.set(0, 0, 0);

            // Generate questions based on this model
            generateQuestions();

            // Update the displayed level
            currentLevelElement.textContent = currentLevel;

            // Reset the camera to default position
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        // Create cube material based on color settings
        function createCubeMaterial() {
            const colorScheme = colorsSelect.value;
            
            if (colorScheme === 'rainbow') {
                const colors = [0xff0000, 0xff9900, 0xffff00, 0x00ff00, 0x0099ff, 0x6633ff];
                const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
                
                return new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
            } else if (colorScheme === 'simple') {
                return new THREE.MeshLambertMaterial({ 
                    color: 0x3366ff,
                    transparent: true,
                    opacity: 0.9
                });
            } else {
                // Grayscale
                const shade = Math.floor(Math.random() * 150) + 100;
                const color = new THREE.Color(`rgb(${shade}, ${shade}, ${shade})`);
                
                return new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
            }
        }

        // Update colors of existing cubes
        function updateColors() {
            if (mainObject) {
                mainObject.traverse(function(child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = createCubeMaterial();
                    }
                });
            }
        }

        // Generate quiz questions
        function generateQuestions() {
            questions = [];
            
            // Create views from different angles
            const viewTypes = ['top', 'front', 'right'];
            
            for (let i = 0; i < totalQuestions; i++) {
                // Choose a random view type for each question
                const viewType = viewTypes[Math.floor(Math.random() * viewTypes.length)];
                
                // Generate a correct option
                const correctOption = renderViewToCanvas(viewType);
                
                // Generate 3 incorrect options (variations of the shape)
                const incorrectOptions = [];
                for (let j = 0; j < 3; j++) {
                    incorrectOptions.push(generateIncorrectOption(viewType));
                }
                
                // Create the question object
                const question = {
                    type: viewType,
                    correct: correctOption,
                    options: shuffleArray([correctOption, ...incorrectOptions]),
                    correctIndex: 0 // Will be updated after shuffling
                };
                
                // Find the index of the correct option after shuffling
                question.correctIndex = question.options.indexOf(correctOption);
                
                questions.push(question);
            }
            
            // Set up the first question
            setUpQuestion(currentQuestion);
        }

        // Render a specific view of the 3D model to a canvas
        function renderViewToCanvas(viewType) {
            // Create a temporary scene with the same model
            const tempScene = new THREE.Scene();
            tempScene.background = new THREE.Color(0xffffff);
            
            // Clone the main object for the temporary scene
            const tempObject = mainObject.clone();
            tempScene.add(tempObject);
            
            // Create an orthographic camera for the view
            const width = 4;
            const height = 4;
            const orthoCam = new THREE.OrthographicCamera(
                width / -2, width / 2,
                height / 2, height / -2,
                0.1, 100
            );
            
            // Set camera position based on view type
            switch (viewType) {
                case 'top':
                    orthoCam.position.set(0, 10, 0);
                    orthoCam.lookAt(0, 0, 0);
                    break;
                case 'front':
                    orthoCam.position.set(0, 0, 10);
                    orthoCam.lookAt(0, 0, 0);
                    break;
                case 'right':
                    orthoCam.position.set(10, 0, 0);
                    orthoCam.lookAt(0, 0, 0);
                    break;
            }
            
            // Create a temporary renderer
            const tempRenderer = new THREE.WebGLRenderer({ antialias: true });
            tempRenderer.setSize(120, 120);
            
            // Render the view
            tempRenderer.render(tempScene, orthoCam);
            
            // Return the canvas element
            return tempRenderer.domElement.toDataURL();
        }

        // Generate an incorrect option for the quiz
        function generateIncorrectOption(viewType) {
            // Create a temporary scene with a modified version of the model
            const tempScene = new THREE.Scene();
            tempScene.background = new THREE.Color(0xffffff);
            
            // Clone the main object for the temporary scene
            const tempObject = mainObject.clone();
            
            // Modify the object (add/remove/move some cubes)
            tempObject.traverse(function(child) {
                if (child instanceof THREE.Mesh && Math.random() > 0.7) {
                    // Randomly modify some cubes
                    const modification = Math.floor(Math.random() * 3);
                    
                    if (modification === 0 && child.parent) {
                        // Remove this cube
                        child.visible = false;
                    } else if (modification === 1) {
                        // Move this cube
                        child.position.x += (Math.random() - 0.5) * 2;
                        child.position.y += (Math.random() - 0.5) * 2;
                        child.position.z += (Math.random() - 0.5) * 2;
                    } else {
                        // Change size
                        child.scale.set(
                            0.7 + Math.random() * 0.6,
                            0.7 + Math.random() * 0.6,
                            0.7 + Math.random() * 0.6
                        );
                    }
                }
            });
            
            tempScene.add(tempObject);
            
            // Create an orthographic camera for the view
            const width = 4;
            const height = 4;
            const orthoCam = new THREE.OrthographicCamera(
                width / -2, width / 2,
                height / 2, height / -2,
                0.1, 100
            );
            
            // Set camera position based on view type
            switch (viewType) {
                case 'top':
                    orthoCam.position.set(0, 10, 0);
                    orthoCam.lookAt(0, 0, 0);
                    break;
                case 'front':
                    orthoCam.position.set(0, 0, 10);
                    orthoCam.lookAt(0, 0, 0);
                    break;
                case 'right':
                    orthoCam.position.set(10, 0, 0);
                    orthoCam.lookAt(0, 0, 0);
                    break;
            }
            
            // Create a temporary renderer
            const tempRenderer = new THREE.WebGLRenderer({ antialias: true });
            tempRenderer.setSize(120, 120);
            
            // Render the view
            tempRenderer.render(tempScene, orthoCam);
            
            // Return the canvas element
            return tempRenderer.domElement.toDataURL();
        }

        // Set up a question in the UI
        function setUpQuestion(index) {
            if (index >= questions.length) {
                // All questions have been answered
                completeLevel();
                return;
            }
            
            const question = questions[index];
            
            // Set question text
            let questionText = "";
            switch (question.type) {
                case 'top':
                    questionText = "Which image shows the correct view of the 3D model from the TOP?";
                    break;
                case 'front':
                    questionText = "Which image shows the correct view of the 3D model from the FRONT?";
                    break;
                case 'right':
                    questionText = "Which image shows the correct view of the 3D model from the RIGHT side?";
                    break;
            }
            quizQuestion.textContent = questionText;
            
            // Clear any previous options
            optionsContainer.innerHTML = '';
            
            // Add new options
            question.options.forEach((option, i) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.setAttribute('data-index', i);
                
                // Create an image from the data URL
                const img = document.createElement('img');
                img.src = option;
                img.alt = `Option ${i+1}`;
                img.width = 120;
                img.height = 120;
                
                optionEl.appendChild(img);
                optionsContainer.appendChild(optionEl);
                
                // Add click event
                optionEl.addEventListener('click', function() {
                    selectOption(i);
                });
            });
            
            // Reset selection
            selectedOption = null;
            nextQuestionBtn.disabled = true;
            
            // Update progress bar
            updateProgressBar();
            
            // If viewpoint hints are enabled, show the current view
            if (viewpointHintsCheckbox.checked) {
                changeView(question.type);
            } else {
                changeView('free');
            }
            
            // Update character dialogue
            updateCharacterDialogue();
        }

        // Select an option in the quiz
        function selectOption(index) {
            // If already submitted, don't allow changing
            if (selectedOption !== null) return;
            
            selectedOption = index;
            
            // Get the current question
            const question = questions[currentQuestion];
            
            // Mark selected option
            const options = document.querySelectorAll('.option');
            options.forEach(option => option.classList.remove('selected', 'correct', 'incorrect'));
            
            const selectedElement = document.querySelector(`.option[data-index="${index}"]`);
            selectedElement.classList.add('selected');
            
            // Check if correct
            const isCorrect = (index === question.correctIndex);
            
            if (isCorrect) {
                selectedElement.classList.add('correct');
                score++;
                scoreElement.textContent = `Score: ${score}`;
                
                // Show celebration animation
                showCelebration();
            } else {
                selectedElement.classList.add('incorrect');
                
                // Highlight the correct option
                const correctElement = document.querySelector(`.option[data-index="${question.correctIndex}"]`);
                correctElement.classList.add('correct');
            }
            
            // Enable next button
            nextQuestionBtn.disabled = false;
        }

        // Go to the next question
        function nextQuestion() {
            currentQuestion++;
            setUpQuestion(currentQuestion);
        }

        // Complete the current level
        function completeLevel() {
            // Calculate score percentage
            const scorePercentage = (score / totalQuestions) * 100;
            
            let message;
            let passed = false;
            
            if (scorePercentage >= 70) {
                passed = true;
                message = `<h2>Great job!</h2>
                <p>You completed Level ${currentLevel} with a score of ${score}/${totalQuestions} (${scorePercentage}%).</p>
                <p>You've shown excellent spatial reasoning skills! Ready for the next level?</p>`;
            } else {
                message = `<h2>Good effort!</h2>
                <p>You completed Level ${currentLevel} with a score of ${score}/${totalQuestions} (${scorePercentage}%).</p>
                <p>Let's try this level again to improve your spatial reasoning skills.</p>`;
            }
            
            modalBody.innerHTML = message;
            modal.classList.add('active');
            
            // Create button to proceed
            const proceedBtn = document.createElement('button');
            proceedBtn.textContent = passed ? "Next Level" : "Try Again";
            proceedBtn.addEventListener('click', function() {
                if (passed) {
                    // Advance to next level
                    currentLevel++;
                    currentLevelElement.textContent = currentLevel;
                    
                    // Increase difficulty if needed
                    if (currentLevel % 3 === 0) {
                        increaseComplexity();
                    }
                }
                
                // Reset and start new level
                resetGameState();
                hideModal();
            });
            
            modalBody.appendChild(proceedBtn);
        }

        // Increase game complexity
        function increaseComplexity() {
            // Get current difficulty index
            const difficulties = ["easy", "medium", "hard", "expert"];
            const currentDifficultyIndex = difficulties.indexOf(difficultySelect.value);
            
            // Increase difficulty if not already at maximum
            if (currentDifficultyIndex < difficulties.length - 1) {
                difficultySelect.value = difficulties[currentDifficultyIndex + 1];
            }
            
            // Increase shape complexity if not already at maximum
            const currentComplexity = parseInt(shapeComplexitySlider.value);
            if (currentComplexity < 5) {
                shapeComplexitySlider.value = currentComplexity + 1;
            }
        }

        // Reset the game state (keeping the current level)
        function resetGameState() {
            currentQuestion = 0;
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            questions = [];
            selectedOption = null;
            
            // Generate new level
            generateLevel();
        }

        // Reset the entire game (back to level 1)
        function resetGame() {
            currentLevel = 1;
            currentLevelElement.textContent = currentLevel;
            resetGameState();
        }

        // Update the progress bar
        function updateProgressBar() {
            const progressPercentage = (currentQuestion / totalQuestions) * 100;
            progressBar.style.width = `${progressPercentage}%`;
        }

        // Update character dialogue
        function updateCharacterDialogue() {
            const dialogues = characterDialogues[currentCharacter];
            const randomIndex = Math.floor(Math.random() * dialogues.length);
            
            // Hide the speech bubble first
            speechBubble.style.opacity = 0;
            
            // After a short delay, update text and show again
            setTimeout(() => {
                speechBubble.textContent = dialogues[randomIndex];
                speechBubble.style.opacity = 1;
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    speechBubble.style.opacity = 0;
                }, 5000);
            }, 500);
        }

        // Change camera view
        function changeView(viewType) {
            if (viewTransitioning) return;
            
            viewTransitioning = true;
            
            // Highlight the active view button
            viewButtons.forEach(button => {
                button.style.backgroundColor = button.getAttribute('data-view') === viewType ? '#4b0082' : '#6a0dad';
            });
            
            // Create target position and lookAt
            let targetPosition, targetLookAt;
            
            switch (viewType) {
                case 'top':
                    targetPosition = new THREE.Vector3(0, 8, 0);
                    targetLookAt = new THREE.Vector3(0, 0, 0);
                    break;
                case 'front':
                    targetPosition = new THREE.Vector3(0, 0, 8);
                    targetLookAt = new THREE.Vector3(0, 0, 0);
                    break;
                case 'right':
                    targetPosition = new THREE.Vector3(8, 0, 0);
                    targetLookAt = new THREE.Vector3(0, 0, 0);
                    break;
                case 'free':
                default:
                    targetPosition = new THREE.Vector3(5, 5, 5);
                    targetLookAt = new THREE.Vector3(0, 0, 0);
                    break;
            }
            
            // Determine if we should animate the transition
            if (cameraTransitionCheckbox.checked) {
                // Animate camera movement
                const startPosition = camera.position.clone();
                const startLookAt = controls.target.clone();
                
                // Animation duration in milliseconds
                const duration = 1000;
                const startTime = Date.now();
                
                function animateCamera() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease function (ease-in-out cubic)
                    const eased = progress < 0.5 ? 4 * progress * progress * progress :
                        1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // Update camera position
                    camera.position.lerpVectors(startPosition, targetPosition, eased);
                    
                    // Update controls target (lookAt)
                    controls.target.lerpVectors(startLookAt, targetLookAt, eased);
                    controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    } else {
                        viewTransitioning = false;
                    }
                }
                
                animateCamera();
            } else {
                // Instant camera movement
                camera.position.copy(targetPosition);
                controls.target.copy(targetLookAt);
                controls.update();
                viewTransitioning = false;
            }
        }

        // Show the help modal
        function showHelp() {
            modalBody.innerHTML = `
                <h2>Welcome to 3D Perspective Explorer!</h2>
                <p>This game helps you improve your spatial reasoning skills by understanding how 3D shapes look from different angles.</p>
                
                <h3>How to Play:</h3>
                <ol>
                    <li>Look at the 3D model in the main view.</li>
                    <li>Use the view buttons to see the model from different angles (top, front, right).</li>
                    <li>Answer the questions by selecting the correct 2D projection from the options.</li>
                    <li>Complete levels to increase the challenge!</li>
                </ol>
                
                <h3>Tips:</h3>
                <ul>
                    <li>Try to mentally visualize how the shape looks from different angles before looking at the options.</li>
                    <li>Notice how cubes align and stack together.</li>
                    <li>Remember that hidden cubes won't appear in the 2D projection.</li>
                    <li>Use the grid to help orient yourself.</li>
                </ul>
                
                <h3>Controls:</h3>
                <ul>
                    <li>Click and drag to rotate the 3D view (in free view mode).</li>
                    <li>Scroll to zoom in/out.</li>
                    <li>Use the settings panel to customize your experience.</li>
                </ul>
                
                <p>Get ready to train your brain and become a 3D visualization expert!</p>
            `;
            
            modal.classList.add('active');
        }

        // Show learn more modal with advanced concepts
        function showLearnMoreModal() {
            modalBody.innerHTML = `
                <h2>The Science of 3D Projection</h2>
                
                <p>When we look at a 3D object from different angles, our brain processes 2D images to understand the 3D structure. This skill is called <strong>spatial reasoning</strong>.</p>
                
                <h3>Basic Concepts:</h3>
                
                <h4>Orthographic Projection</h4>
                <p>In this game, we use <strong>orthographic projection</strong>, which means we look at objects perpendicularly from each side, ignoring perspective distortion. This creates "flattened" views where parallel lines remain parallel.</p>
                
                <h4>Standard Views</h4>
                <p>Engineers and architects use three standard views:</p>
                <ul>
                    <li><strong>Top View (Plan)</strong>: Looking down from above</li>
                    <li><strong>Front View (Elevation)</strong>: Looking at the front</li>
                    <li><strong>Side View (Right Elevation)</strong>: Looking from the right side</li>
                </ul>
                
                <h3>Advanced Concepts:</h3>
                
                <h4>Mental Rotation</h4>
                <p>Your brain performs <strong>mental rotation</strong> to visualize objects from different angles. This involves activating your visual-spatial processing centers in the parietal lobe of your brain.</p>
                
                <h4>Occlusion</h4>
                <p><strong>Occlusion</strong> refers to when one part of an object blocks another from view. Understanding which parts will be visible from each angle is a key skill.</p>
                
                <h4>Spatial Coordinates</h4>
                <p>3D space is defined using X, Y, and Z coordinates:</p>
                <ul>
                    <li>X-axis: Left to right (red line)</li>
                    <li>Y-axis: Up and down (green line)</li>
                    <li>Z-axis: Front to back (blue line)</li>
                </ul>
                
                <h3>Real-World Applications:</h3>
                
                <p>The spatial reasoning skills you're developing are used in:</p>
                <ul>
                    <li>Engineering and architecture</li>
                    <li>Medical imaging interpretation</li>
                    <li>Computer graphics and game design</li>
                    <li>Navigation and map reading</li>
                    <li>Robotics and computer vision</li>
                    <li>Mathematics (especially geometry and topology)</li>
                </ul>
                
                <p>Keep practicing, and you'll improve your ability to visualize complex 3D structures in your mind!</p>
            `;
            
            modal.classList.add('active');
        }

        // Hide the modal
        function hideModal() {
            modal.classList.remove('active');
        }

        // Show celebration animation
        function showCelebration() {
            celebrationContainer.style.display = 'block';
            
            // Create confetti particles
            for (let i = 0; i < 50; i++) {
                createConfetti();
            }
            
            // Hide celebration after animation completes
            setTimeout(() => {
                celebrationContainer.style.display = 'none';
                celebrationContainer.innerHTML = '';
            }, 3000);
        }

        // Create a single confetti particle
        function createConfetti() {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            
            // Random color
            const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Random position
            const posX = Math.random() * window.innerWidth;
            const posY = -20;
            confetti.style.left = posX + 'px';
            confetti.style.top = posY + 'px';
            
            // Random size
            const size = Math.random() * 10 + 5;
            confetti.style.width = size + 'px';
            confetti.style.height = size + 'px';
            
            // Random rotation
            confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
            
            celebrationContainer.appendChild(confetti);
            
            // Animate falling
            const duration = Math.random() * 1000 + 2000;
            const endPosX = posX + (Math.random() - 0.5) * 300;
            const endPosY = window.innerHeight + 20;
            
            // Start animation
            confetti.style.transition = `top ${duration}ms linear, left ${duration}ms ease-in-out, transform ${duration}ms linear, opacity 0.5s`;
            
            // Set initial opacity
            confetti.style.opacity = '1';
            
            // Trigger animation
            setTimeout(() => {
                confetti.style.top = endPosY + 'px';
                confetti.style.left = endPosX + 'px';
                confetti.style.transform = `rotate(${Math.random() * 360 + 360}deg)`;
                
                // Fade out at the end
                setTimeout(() => {
                    confetti.style.opacity = '0';
                }, duration - 500);
                
                // Remove after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, duration);
            }, 10);
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }
    </script>
</body>
</html>