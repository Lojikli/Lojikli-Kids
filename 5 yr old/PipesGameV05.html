<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Water Pipe Flow Game</title>
  <style>
    body {
      text-align: center;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .game-container {
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
      margin-top: 20px;
    }

    h1 {
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      font-size: 2.5em;
      margin-bottom: 20px;
    }

    canvas {
      border: 3px solid #000;
      border-radius: 10px;
      background: #eee;
      cursor: pointer;
      transition: transform 0.2s;
    }

    canvas:hover {
      transform: scale(1.01);
    }

    /* Celebration overlay */
    .celebration-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }

    /* Victory message */
    .victory-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: rgba(255, 255, 255, 0.95);
      padding: 20px 40px;
      border-radius: 15px;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.3);
      z-index: 1001;
      display: none;
      animation: popIn 0.5s ease-out forwards;
    }

    .victory-message h2 {
      color: #2c3e50;
      font-size: 2em;
      margin: 0 0 10px 0;
    }

    .victory-message p {
      color: #7f8c8d;
      font-size: 1.2em;
      margin: 0;
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); }
      80% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* Confetti styles */
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #f00;
      opacity: 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
    <div class="game-container">
        <h1>Water Pipe Flow Game</h1>
        <canvas id="gameCanvas" width="480" height="480"></canvas>
      </div>
      <div class="celebration-overlay" id="celebrationOverlay"></div>
      <div class="victory-message" id="victoryMessage">
        <h2>ðŸŽ‰ Congratulations! ðŸŽ‰</h2>
        <p>You've successfully connected all the pipes!</p>
      </div>

  <script>
    // ----- Basic Settings -----
    const rows = 6, cols = 6;
    const cellSize = 80;
    const pipeThickness = 20;
    let gameWon = false;
    
    // ----- Direction Helpers -----
    const directions = {
      'N': { dr: -1, dc: 0 },
      'E': { dr: 0, dc: 1 },
      'S': { dr: 1, dc: 0 },
      'W': { dr: 0, dc: -1 }
    };

    function opposite(dir) {
      return { 'N': 'S', 'E': 'W', 'S': 'N', 'W': 'E' }[dir];
    }

// ----- Sound Setup -----
const sounds = {
  rotate: new Howl({
    src: ['https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js'],
    volume: 0.5
  })
};



    // ----- Board Setup -----
    let board = [];
    for (let r = 0; r < rows; r++) {
      board[r] = [];
      for (let c = 0; c < cols; c++) {
        board[r][c] = null;
      }
    }

    // Generate a random monotonic path from (0,0) to (rows-1,cols-1)
    function generateMonotonicPath(rows, cols) {
      let moves = [];
      for (let i = 0; i < rows - 1; i++) moves.push('S');
      for (let j = 0; j < cols - 1; j++) moves.push('E');
      
      // Shuffle moves for randomization
      for (let i = moves.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [moves[i], moves[j]] = [moves[j], moves[i]];
      }
      
      let path = [{ r: 0, c: 0 }];
      let current = { r: 0, c: 0 };
      moves.forEach(move => {
        if (move === 'S') current = { r: current.r + 1, c: current.c };
        else if (move === 'E') current = { r: current.r, c: current.c + 1 };
        path.push({ ...current });
      });
      return path;
    }

    const solutionPath = generateMonotonicPath(rows, cols);

    // Calculate correct rotations for pieces
    function getCorrectRotation(incoming, outgoing, type) {
      if (type === 'straight') {
        if ((incoming === 'W' && outgoing === 'E') || (incoming === 'E' && outgoing === 'W'))
          return 0;
        if ((incoming === 'N' && outgoing === 'S') || (incoming === 'S' && outgoing === 'N'))
          return 90;
      } else if (type === 'curve') {
        const options = {
          0: ['N', 'E'],
          90: ['E', 'S'],
          180: ['S', 'W'],
          270: ['W', 'N']
        };
        for (let rot in options) {
          const con = options[rot];
          if ((con[0] === incoming && con[1] === outgoing) ||
              (con[0] === outgoing && con[1] === incoming))
            return parseInt(rot);
        }
      }
      return 0;
    }

    // Create solution map
    let solutionMap = {};
    for (let i = 0; i < solutionPath.length; i++) {
      const cell = solutionPath[i];
      let incoming, outgoing;
      
      if (i === 0) {
        incoming = 'W';
        const next = solutionPath[i + 1];
        outgoing = (next.r === cell.r) ? 'E' : 'S';
      } else if (i === solutionPath.length - 1) {
        const prev = solutionPath[i - 1];
        if (prev.r === cell.r) incoming = (cell.c > prev.c) ? 'W' : 'E';
        else if (prev.c === cell.c) incoming = (cell.r > prev.r) ? 'N' : 'S';
        outgoing = 'E';
      } else {
        const prev = solutionPath[i - 1];
        const next = solutionPath[i + 1];
        if (prev.r === cell.r) incoming = (cell.c > prev.c) ? 'W' : 'E';
        else if (prev.c === cell.c) incoming = (cell.r > prev.r) ? 'N' : 'S';
        if (next.r === cell.r) outgoing = (next.c > cell.c) ? 'E' : 'W';
        else if (next.c === cell.c) outgoing = (next.r > cell.r) ? 'S' : 'N';
      }
      
      const pieceType = (incoming === opposite(outgoing)) ? 'straight' : 'curve';
      const correctRotation = getCorrectRotation(incoming, outgoing, pieceType);
      solutionMap[`${cell.r},${cell.c}`] = { type: pieceType, correctRotation: correctRotation };
    }

    // Fill the board with solution pieces and random pieces
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (solutionMap.hasOwnProperty(`${r},${c}`)) {
          const sol = solutionMap[`${r},${c}`];
          const randomOffset = 90 * Math.floor(Math.random() * 4);
          const currentRotation = (sol.correctRotation + randomOffset) % 360;
          board[r][c] = { 
            type: sol.type, 
            rotation: currentRotation, 
            solution: sol.correctRotation 
          };
        } else {
          const type = (Math.random() < 0.5) ? 'straight' : 'curve';
          let rotation;
          if (type === 'straight') {
            rotation = (Math.random() < 0.5) ? 0 : 90;
          } else {
            const options = [0, 90, 180, 270];
            rotation = options[Math.floor(Math.random() * options.length)];
          }
          board[r][c] = { 
            type: type, 
            rotation: rotation, 
            solution: null 
          };
        }
      }
    }

// ----- Canvas Setup -----
const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ----- Pipe Drawing Functions -----
    function drawPipe(ctx, x, y, piece, cellSize) {
      ctx.save();
      ctx.translate(x, y);
      ctx.translate(cellSize/2, cellSize/2);
      ctx.rotate(piece.rotation * Math.PI / 180);
      ctx.translate(-cellSize/2, -cellSize/2);
      
      if (piece.type === 'straight') {
        // Draw pipe shadow
        ctx.beginPath();
        ctx.moveTo(0, cellSize/2);
        ctx.lineTo(cellSize, cellSize/2);
        ctx.lineWidth = pipeThickness + 4;
        ctx.strokeStyle = "#333";
        ctx.lineCap = "round";
        ctx.stroke();
        
        // Draw main pipe with gradient
        ctx.beginPath();
        ctx.moveTo(0, cellSize/2);
        ctx.lineTo(cellSize, cellSize/2);
        let grad = ctx.createLinearGradient(0, cellSize/2, cellSize, cellSize/2);
        grad.addColorStop(0, "#aaa");
        grad.addColorStop(0.5, "#ddd");
        grad.addColorStop(1, "#aaa");
        ctx.lineWidth = pipeThickness;
        ctx.strokeStyle = grad;
        ctx.stroke();
      } else if (piece.type === 'curve') {
        // Draw curve shadow
        ctx.beginPath();
        ctx.arc(cellSize, 0, cellSize/2, Math.PI/2, Math.PI, false);
        ctx.lineWidth = pipeThickness + 4;
        ctx.strokeStyle = "#333";
        ctx.lineCap = "round";
        ctx.stroke();
        
        // Draw main curve with gradient
        ctx.beginPath();
        ctx.arc(cellSize, 0, cellSize/2, Math.PI/2, Math.PI, false);
        let grad = ctx.createRadialGradient(
          cellSize, 0, cellSize/4,
          cellSize, 0, cellSize/2
        );
        grad.addColorStop(0, "#ddd");
        grad.addColorStop(1, "#aaa");
        ctx.lineWidth = pipeThickness;
        ctx.strokeStyle = grad;
        ctx.stroke();
      }
      ctx.restore();
    }

    // Draw the full board
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background with subtle pattern
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x = c * cellSize;
          const y = r * cellSize;
          
          // Draw cell background
          ctx.fillStyle = "#fff";
          ctx.fillRect(x, y, cellSize, cellSize);
          
          // Draw subtle grid
          ctx.strokeStyle = "#ddd";
          ctx.strokeRect(x, y, cellSize, cellSize);
          
          // Draw pipe
          drawPipe(ctx, x, y, board[r][c], cellSize);
        }
      }
      
      // Draw source and destination indicators
      drawEndpoints();
    }

    function drawEndpoints() {
      // Source (left side)
      ctx.fillStyle = "#4CAF50";
      ctx.beginPath();
      ctx.arc(0, cellSize/2, 12, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "#45a049";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Destination (right side)
      ctx.fillStyle = "#f44336";
      ctx.beginPath();
      ctx.arc(canvas.width, cellSize * (rows - 1) + cellSize/2, 12, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "#e53935";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // ----- Animation Utilities -----
    function rotatePoint(pt, angle, center) {
      const rad = angle * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      const dx = pt.x - center.x;
      const dy = pt.y - center.y;
      return {
        x: center.x + dx * cos - dy * sin,
        y: center.y + dx * sin + dy * cos
      };
    }

    function rotateDirection(dir, angle) {
      const order = ['N', 'E', 'S', 'W'];
      const idx = order.indexOf(dir);
      const times = (angle / 90) % 4;
      const newIdx = (idx + times + order.length) % order.length;
      return order[newIdx];
    }

    // Get pipe endpoints for water animation
    function getPipeEndpoints(piece, cellSize) {
      let endpoints = {};
      const center = { x: cellSize/2, y: cellSize/2 };
      
      if (piece.type === 'straight') {
        const base = {
          'W': { x: 0, y: cellSize/2 },
          'E': { x: cellSize, y: cellSize/2 }
        };
        for (let d in base) {
          const pt = base[d];
          const rotatedPt = rotatePoint(pt, piece.rotation, center);
          const newDir = rotateDirection(d, piece.rotation);
          endpoints[newDir] = rotatedPt;
        }
      } else if (piece.type === 'curve') {
        const base = {
          'N': { x: cellSize/2, y: 0 },
          'E': { x: cellSize, y: cellSize/2 }
        };
        for (let d in base) {
          const pt = base[d];
          const rotatedPt = rotatePoint(pt, piece.rotation, center);
          const newDir = rotateDirection(d, piece.rotation);
          endpoints[newDir] = rotatedPt;
        }
      }
      return endpoints;
    }
    // ----- Water Flow Check Functions -----
    function getConnections(piece, cellSize) {
      const endpoints = getPipeEndpoints(piece, cellSize);
      let connections = [];
      for (let dir in endpoints) {
        connections.push(dir);
      }
      return connections;
    }

    function areConnected(piece1, dir1, piece2, dir2) {
      const connections1 = getConnections(piece1, cellSize);
      const connections2 = getConnections(piece2, cellSize);
      return connections1.includes(dir1) && connections2.includes(opposite(dir1));
    }

    function checkWaterFlow() {
      const waterPath = findWaterPath();
      return waterPath !== null;
    }

    function findWaterPath() {
      let visited = new Set();
      let path = [];
      
      function dfs(r, c, fromDir) {
        if (r < 0 || r >= rows || c < 0 || c >= cols) {
          // Check if we've reached the destination
          return c === cols && r === rows - 1;
        }
        
        const key = `${r},${c}`;
        if (visited.has(key)) return false;
        visited.add(key);
        path.push({r, c});
        
        const piece = board[r][c];
        const connections = getConnections(piece, cellSize);
        
        // Try each possible direction
        for (let dir of connections) {
          if (fromDir && !areConnected(piece, opposite(fromDir), piece, dir)) continue;
          
          const next = directions[dir];
          if (dfs(r + next.dr, c + next.dc, dir)) {
            return true;
          }
        }
        
        path.pop();
        return false;
      }
      
      // Start from the entry point
      const startFound = dfs(0, 0, null);
      return startFound ? path : null;
    }

    function animateWaterPath(path) {
      const victoryMessage = document.getElementById('victoryMessage');
      const celebrationOverlay = document.getElementById('celebrationOverlay');
      
      // Show victory message
      victoryMessage.style.display = 'block';
      celebrationOverlay.style.display = 'block';
      
      // Create confetti
      for (let i = 0; i < 100; i++) {
        createConfetti();
      }
    }

    function createConfetti() {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * window.innerWidth + 'px';
      confetti.style.top = -10 + 'px';
      confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
      confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
      
      document.getElementById('celebrationOverlay').appendChild(confetti);
      
      // Animate confetti
      const animation = confetti.animate([
        { transform: `translate(0, 0) rotate(0)`, opacity: 1 },
        { transform: `translate(${Math.random() * 100 - 50}px, ${window.innerHeight}px) rotate(${Math.random() * 720}deg)`, opacity: 0 }
      ], {
        duration: 1500 + Math.random() * 1500,
        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
      });
      
      animation.onfinish = () => confetti.remove();
    }



// ----- Event Handling -----
    canvas.addEventListener('click', function(evt) {
      if (gameWon) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const col = Math.floor(x / cellSize);
      const row = Math.floor(y / cellSize);
      
      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        // Add rotation animation
        const piece = board[row][col];
        const originalRotation = piece.rotation;
        const targetRotation = (originalRotation + 90) % 360;
        const startTime = performance.now();
        const duration = 300; // milliseconds
        
        function animateRotation(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Easing function for smooth rotation
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          
          piece.rotation = originalRotation + (90 * easeProgress);
          drawBoard();
          
          if (progress < 1) {
            requestAnimationFrame(animateRotation);
          } else {
            piece.rotation = targetRotation; // Ensure final position is exact
            drawBoard();
            
            // Play rotation sound
            sounds.rotate.play();
            
            // Check if puzzle is solved
            if (checkWaterFlow()) {
              gameWon = true;
              const path = findWaterPath();
              if (path) {
                animateWaterPath(path);
              }
            }
          }
        }
        
        requestAnimationFrame(animateRotation);
      }
    });

    // Add hover effect
    canvas.addEventListener('mousemove', function(evt) {
      if (gameWon) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const col = Math.floor(x / cellSize);
      const row = Math.floor(y / cellSize);
      
      // Add subtle highlight effect
      drawBoard();
      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
      }
    });

    // ----- Initialization -----
    drawBoard();



  </script>
</body>
</html>