<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Like Terms Explorer: Algebraic Grouping Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #ff9a76;
            --tertiary-color: #6ecb63;
            --quaternary-color: #ffec5f;
            --background-color: #f5f5f5;
            --text-color: #333;
            --card-color: #ffffff;
            --success-color: #66bb6a;
            --error-color: #ef5350;
            --hint-color: #7986cb;
            --level1-color: #c8e6c9;
            --level2-color: #a5d6a7;
            --level3-color: #81c784;
            --level4-color: #66bb6a;
            --level5-color: #4caf50;
            --level6-color: #43a047;
            --level7-color: #388e3c;
            --level8-color: #2e7d32;
            --highlight-blue: #2196f3;
            --highlight-orange: #ff9800;
            --highlight-purple: #9c27b0;
            --highlight-pink: #e91e63;
            --highlight-teal: #009688;
            --highlight-red: #f44336;
            --highlight-green: #4caf50;
            --highlight-yellow: #ffeb3b;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            overflow-x: hidden;
            min-height: 100vh;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary-color);
            font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .levels-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--card-color);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .level-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
        }

        .level-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .level-btn:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .level-btn.selected {
            outline: 3px solid var(--quaternary-color);
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .level-btn:nth-child(1) { background-color: var(--level1-color); color: var(--text-color); }
        .level-btn:nth-child(2) { background-color: var(--level2-color); color: var(--text-color); }
        .level-btn:nth-child(3) { background-color: var(--level3-color); color: var(--text-color); }
        .level-btn:nth-child(4) { background-color: var(--level4-color); }
        .level-btn:nth-child(5) { background-color: var(--level5-color); }
        .level-btn:nth-child(6) { background-color: var(--level6-color); }
        .level-btn:nth-child(7) { background-color: var(--level7-color); }
        .level-btn:nth-child(8) { background-color: var(--level8-color); }

        .character-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .character {
            width: 150px;
            height: 150px;
            position: relative;
            margin: 0 10px;
        }

        .character-speech {
            position: absolute;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 10px 15px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 250px;
            border: 2px solid var(--primary-color);
            box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .character-speech:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent transparent;
        }

        .visualization-container {
            width: 100%;
            height: 300px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: var(--card-color);
        }

        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-bottom: 20px;
            background-color: var(--card-color);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            flex: 1;
            min-width: 250px;
            margin: 10px;
        }

        .control-title {
            font-size: 18px;
            color: var(--primary-color);
            margin-bottom: 10px;
            font-weight: bold;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: block;
            margin-bottom: 5px;
        }

        .slider {
            width: 100%;
            height: 25px;
            background: #d3d3d3;
            outline: none;
            border-radius: 15px;
        }

        .quiz-container {
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .quiz-header {
            font-size: 24px;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
        }

        .level-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: var(--quaternary-color);
            border-radius: 10px;
            font-weight: bold;
        }

        .problem-container {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            position: relative;
        }

        .term {
            display: inline-block;
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .term:hover {
            transform: translateY(-3px);
        }

        .term.highlighted {
            color: white;
            font-weight: bold;
        }

        .term.blue-square {
            background-color: var(--highlight-blue);
            color: white;
        }

        .term.orange-cloud {
            background-color: var(--highlight-orange);
            color: white;
        }

        .term.purple-circle {
            background-color: var(--highlight-purple);
            color: white;
        }

        .term.pink-star {
            background-color: var(--highlight-pink);
            color: white;
        }

        .term.teal-diamond {
            background-color: var(--highlight-teal);
            color: white;
        }

        .term.red-triangle {
            background-color: var(--highlight-red);
            color: white;
        }

        .term.green-pentagon {
            background-color: var(--highlight-green);
            color: white;
        }

        .term.yellow-hexagon {
            background-color: var(--highlight-yellow);
            color: black;
        }

        .highlight-tools-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .highlight-tool {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .highlight-tool.active {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            border: 3px solid white;
        }

        .highlight-tool-icon {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .highlight-tool:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .blue-square-tool {
            background-color: var(--highlight-blue);
        }

        .orange-cloud-tool {
            background-color: var(--highlight-orange);
        }

        .purple-circle-tool {
            background-color: var(--highlight-purple);
        }

        .pink-star-tool {
            background-color: var(--highlight-pink);
        }

        .teal-diamond-tool {
            background-color: var(--highlight-teal);
        }

        .red-triangle-tool {
            background-color: var(--highlight-red);
        }

        .green-pentagon-tool {
            background-color: var(--highlight-green);
        }

        .yellow-hexagon-tool {
            background-color: var(--highlight-yellow);
        }

        .clear-highlights-btn {
            background-color: #757575;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.2s;
        }

        .clear-highlights-btn:hover {
            background-color: #616161;
        }

        .answer-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .answer-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .answer-input {
            width: 300px;
            height: 40px;
            font-size: 18px;
            text-align: center;
            padding: 5px 10px;
            border: 2px solid var(--primary-color);
            border-radius: 10px;
        }

        .variable-selector {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .variable-btn {
            background-color: var(--quaternary-color);
            border: none;
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .variable-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .variable-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .operation-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s, box-shadow 0.1s;
            margin: 0 5px;
        }

        .operation-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .action-btns {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .check-btn {
            background-color: var(--success-color);
            color: white;
        }

        .hint-btn {
            background-color: var(--hint-color);
            color: white;
        }

        .new-problem-btn {
            background-color: var(--primary-color);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .result-message {
            text-align: center;
            margin: 20px 0;
            font-size: 20px;
            padding: 10px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .hint-panel {
            background-color: var(--hint-color);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

        .hint-title {
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .progress-container {
            margin-top: 20px;
            background-color: var(--card-color);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .progress-title {
            font-size: 18px;
            color: var(--primary-color);
            margin-bottom: 10px;
            text-align: center;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .progress-stat {
            flex: 1;
            min-width: 120px;
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-color);
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--tertiary-color);
            width: 0%;
            transition: width 0.5s ease;
        }

        .score-display {
            text-align: right;
            margin-top: 5px;
            font-size: 16px;
            color: var(--text-color);
        }

        .achievements-container {
            margin-top: 20px;
            background-color: var(--card-color);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .achievements-title {
            font-size: 18px;
            color: var(--primary-color);
            margin-bottom: 10px;
            text-align: center;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .achievement {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        
        .achievement.unlocked {
            opacity: 1;
            background-color: var(--quaternary-color);
        }
        
        .achievement-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .achievement-name {
            font-size: 12px;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: var(--card-color);
            margin: 10% auto;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
        }

        .modal-title {
            color: var(--primary-color);
            font-size: 24px;
            margin-bottom: 15px;
        }

        .modal-text {
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .character-info {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .character-img {
            width: 80px;
            height: 80px;
            margin-right: 15px;
        }

        .celebration {
            position: fixed;
            z-index: 999;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            border-radius: 0;
            animation: fall 3s ease-in-out forwards;
        }

        @keyframes fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .streak-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .timer-container {
            margin-top: 10px;
            text-align: center;
        }

        .timer {
            font-size: 18px;
            color: var(--text-color);
            font-weight: bold;
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .bounce {
            animation: bounce 0.5s ease-in-out;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .character-svg {
            width: 100%;
            height: 100%;
        }

        .mastery-badge {
            display: inline-block;
            font-size: 14px;
            margin-left: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background-color: var(--quaternary-color);
            color: var(--text-color);
        }

        .rule-card {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .rule-card h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .rule-card p {
            margin-bottom: 10px;
        }

        .rule-card .example {
            background-color: var(--quaternary-color);
            padding: 8px;
            border-radius: 5px;
            margin-top: 5px;
            font-family: monospace;
            font-size: 16px;
        }

        .highlight-tool-shape {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .square-shape {
            width: 30px;
            height: 30px;
        }

        .circle-shape {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }

        .cloud-shape {
            position: relative;
            width: 30px;
            height: 20px;
            border-radius: 10px;
        }

        .cloud-shape:before {
            content: '';
            position: absolute;
            top: -10px;
            left: 5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: inherit;
        }

        .cloud-shape:after {
            content: '';
            position: absolute;
            top: -6px;
            right: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: inherit;
        }

        .star-shape {
            position: relative;
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 10px;
            margin-right: 10px;
            border-right: 10px solid transparent;
            border-bottom: 7px solid white;
            border-left: 10px solid transparent;
            transform: rotate(35deg);
        }

        .star-shape:before {
            content: '';
            position: absolute;
            height: 0;
            width: 0;
            top: -4px;
            left: -6px;
            border-bottom: 8px solid white;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            transform: rotate(-35deg);
        }

        .star-shape:after {
            content: '';
            position: absolute;
            top: 0;
            left: -10px;
            width: 0;
            height: 0;
            border-right: 10px solid transparent;
            border-bottom: 7px solid white;
            border-left: 10px solid transparent;
            transform: rotate(-70deg);
        }

        .diamond-shape {
            width: 30px;
            height: 30px;
            transform: rotate(45deg);
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid white;
        }

        .pentagon-shape {
            position: relative;
            width: 30px;
            height: 28px;
            background-color: inherit;
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
        }

        .hexagon-shape {
            width: 30px;
            height: 26px;
            background-color: inherit;
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        }

        .eraser-shape {
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #757575;
        }

        .tool-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 12px;
            font-weight: bold;
            color: var(--text-color);
        }

        .term-combining-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: #f1f8e9;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .combine-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: var(--primary-color);
            font-weight: bold;
        }

        .combine-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .combine-terms {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .combine-symbol {
            font-size: 24px;
            margin: 0 10px;
        }

        .combine-result {
            font-size: 20px;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 8px;
            margin-left: 10px;
        }

        .terms-draggable {
            cursor: grab;
        }

        .combine-dropzone {
            min-height: 50px;
            padding: 10px;
            border: 2px dashed #aaa;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            min-width: 300px;
        }

        .combine-dropzone.active {
            background-color: rgba(0, 0, 0, 0.05);
            border-color: var(--primary-color);
        }

        .combine-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .combine-btn {
            background-color: var(--tertiary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .combine-btn:hover {
            background-color: var(--primary-color);
        }

        .reset-combine-btn {
            background-color: #757575;
        }

        .reset-combine-btn:hover {
            background-color: #616161;
        }

        /* New styles for answer input */
        .user-answer-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .answer-label {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .answer-input-field {
            width: 100%;
            max-width: 400px;
            height: 45px;
            font-size: 20px;
            padding: 5px 15px;
            border: 2px solid var(--tertiary-color);
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .answer-input-field:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
        }

        .answer-button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .answer-helper-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
        }

        .helper-btn {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .helper-btn:hover {
            background-color: #e0e0e0;
            transform: translateY(-2px);
        }

        .feedback-container {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .feedback-correct {
            background-color: rgba(102, 187, 106, 0.2);
            color: #2e7d32;
        }

        .feedback-incorrect {
            background-color: rgba(239, 83, 80, 0.2);
            color: #c62828;
        }

        .answer-attempts {
            margin-top: 10px;
            font-size: 14px;
            color: #757575;
        }

        .extra-help {
            margin-top: 10px;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 8px;
            font-size: 16px;
            display: none;
        }

        /* For medium and small screens */
        @media (max-width: 768px) {
            .header {
                font-size: 28px;
            }
            
            .visualization-container {
                height: 250px;
            }
            
            .control-group {
                min-width: 100%;
            }
            
            .highlight-tool {
                width: 40px;
                height: 40px;
            }
            
            .highlight-tool-shape {
                width: 25px;
                height: 25px;
            }
            
            .problem-container {
                font-size: 20px;
                padding: 15px;
            }
            
            .term {
                padding: 4px 8px;
                margin: 0 3px;
            }
            
            .action-btns {
                flex-wrap: wrap;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 16px;
            }

            .answer-input-field {
                width: 90%;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="header">Like Terms Explorer: Algebraic Grouping Adventure</h1>
        
        <div class="levels-container" id="levels-container">
            <!-- Level buttons will be added here -->
        </div>
        
        <div class="character-container">
            <div class="character" id="professor-poly">
                <svg class="character-svg" viewBox="0 0 100 100">
                    <!-- Professor Poly -->
                    <circle cx="50" cy="50" r="40" fill="#4a6fa5" />
                    <circle cx="35" cy="40" r="5" fill="white" />
                    <circle cx="35" cy="40" r="2" fill="black" />
                    <circle cx="65" cy="40" r="5" fill="white" />
                    <circle cx="65" cy="40" r="2" fill="black" />
                    <path d="M 35 65 Q 50 75 65 65" stroke="white" stroke-width="3" fill="transparent" />
                    <ellipse cx="50" cy="30" rx="10" ry="5" fill="white" transform="rotate(-10, 50, 30)" />
                </svg>
                <div class="character-speech" id="professor-speech">
                    Welcome to Like Terms Explorer! I'm Professor Poly!
                </div>
            </div>
            
            <div class="character" id="variable-vicky">
                <svg class="character-svg" viewBox="0 0 100 100">
                    <!-- Variable Vicky -->
                    <circle cx="50" cy="50" r="40" fill="#ff9a76" />
                    <circle cx="35" cy="40" r="5" fill="white" />
                    <circle cx="35" cy="40" r="2" fill="black" />
                    <circle cx="65" cy="40" r="5" fill="white" />
                    <circle cx="65" cy="40" r="2" fill="black" />
                    <path d="M 35 60 Q 50 70 65 60" stroke="white" stroke-width="3" fill="transparent" />
                    <path d="M 30 25 L 50 15 L 70 25" stroke="black" stroke-width="2" fill="transparent" />
                    <path d="M 50 15 L 50 30" stroke="black" stroke-width="2" fill="transparent" />
                </svg>
                <div class="character-speech" id="vicky-speech">
                    I'm Variable Vicky! I'll teach you which terms are alike!
                </div>
            </div>
            
            <div class="character" id="term-terry">
                <svg class="character-svg" viewBox="0 0 100 100">
                    <!-- Term Terry (formerly Exponent Eddie) -->
                    <circle cx="50" cy="50" r="40" fill="#6ecb63" />
                    <circle cx="35" cy="40" r="5" fill="white" />
                    <circle cx="35" cy="40" r="2" fill="black" />
                    <circle cx="65" cy="40" r="5" fill="white" />
                    <circle cx="65" cy="40" r="2" fill="black" />
                    <path d="M 35 65 Q 50 55 65 65" stroke="white" stroke-width="3" fill="transparent" />
                    <text x="37" y="30" font-size="16" font-weight="bold" fill="white">3x+2y</text>
                </svg>
                <div class="character-speech" id="terry-speech">
                    I'm Term Terry! I'll help you combine like terms in expressions!
                </div>
            </div>
        </div>
        
        <div class="visualization-container" id="visualization">
            <!-- Three.js visualization will be rendered here -->
        </div>
        
        <div class="controls-container">
            <div class="control-group">
                <div class="control-title">Game Settings</div>
                <div class="slider-container">
                    <label class="slider-label" for="difficulty-slider">Problem Difficulty: <span id="difficulty-value">Medium</span></label>
                    <input type="range" min="1" max="3" value="2" class="slider" id="difficulty-slider">
                </div>
                <div class="slider-container">
                    <label class="slider-label" for="timer-slider">Timer: <span id="timer-value">Off</span></label>
                    <input type="range" min="0" max="3" value="0" class="slider" id="timer-slider">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">Visualization Settings</div>
                <div class="slider-container">
                    <label class="slider-label" for="speed-slider">Animation Speed: <span id="speed-value">5</span></label>
                    <input type="range" min="1" max="10" value="5" class="slider" id="speed-slider">
                </div>
                <div class="slider-container">
                    <label class="slider-label" for="color-slider">Color Theme: <span id="color-value">Vibrant</span></label>
                    <input type="range" min="1" max="3" value="1" class="slider" id="color-slider">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">Help & Info</div>
                <div class="slider-container">
                    <label class="slider-label" for="character-slider">Character Help Level: <span id="character-value">Medium</span></label>
                    <input type="range" min="1" max="3" value="2" class="slider" id="character-slider">
                </div>
                <button class="btn" id="rules-btn" style="margin-top: 10px; margin-right: 5px; background-color: var(--tertiary-color); color: var(--text-color);">Like Terms Rules</button>
                <button class="btn" id="intro-btn" style="margin-top: 10px; background-color: var(--quaternary-color); color: var(--text-color);">Meet Characters</button>
            </div>
        </div>
        
        <div class="quiz-container">
            <h2 class="quiz-header">Like Terms Challenge</h2>
            <div class="level-info" id="level-info">
                Select a level to begin!
            </div>
            
            <div class="timer-container">
                <div class="timer" id="timer">Time: 00:00</div>
            </div>
            
            <div class="problem-container" id="problem-display">
                Choose a level to get started!
            </div>
            
            <div class="highlight-tools-container" id="highlight-tools">
                <button class="highlight-tool blue-square-tool" data-highlight="blue-square">
                    <div class="highlight-tool-shape square-shape"></div>
                    <span class="tool-label">Blue Square</span>
                </button>
                <button class="highlight-tool orange-cloud-tool" data-highlight="orange-cloud">
                    <div class="highlight-tool-shape cloud-shape"></div>
                    <span class="tool-label">Orange Cloud</span>
                </button>
                <button class="highlight-tool purple-circle-tool" data-highlight="purple-circle">
                    <div class="highlight-tool-shape circle-shape"></div>
                    <span class="tool-label">Purple Circle</span>
                </button>
                <button class="highlight-tool pink-star-tool" data-highlight="pink-star">
                    <div class="highlight-tool-shape">
                        <div class="star-shape"></div>
                    </div>
                    <span class="tool-label">Pink Star</span>
                </button>
                <button class="highlight-tool teal-diamond-tool" data-highlight="teal-diamond">
                    <div class="highlight-tool-shape diamond-shape"></div>
                    <span class="tool-label">Teal Diamond</span>
                </button>
                <button class="highlight-tool red-triangle-tool" data-highlight="red-triangle">
                    <div class="highlight-tool-shape triangle-shape"></div>
                    <span class="tool-label">Red Triangle</span>
                </button>
                <button class="highlight-tool green-pentagon-tool" data-highlight="green-pentagon">
                    <div class="highlight-tool-shape pentagon-shape"></div>
                    <span class="tool-label">Green Pentagon</span>
                </button>
                <button class="highlight-tool yellow-hexagon-tool" data-highlight="yellow-hexagon">
                    <div class="highlight-tool-shape hexagon-shape"></div>
                    <span class="tool-label">Yellow Hexagon</span>
                </button>
                <button class="highlight-tool" id="eraser-tool">
                    <div class="highlight-tool-shape eraser-shape">⌫</div>
                    <span class="tool-label">Eraser</span>
                </button>
                <button class="clear-highlights-btn" id="clear-highlights-btn">Clear All</button>
            </div>
            
            <div class="term-combining-container" id="term-combining-container">
                <div class="combine-title">Combine Like Terms</div>
                <div class="combine-dropzone" id="combine-dropzone">
                    <!-- Terms will be dragged here for combining -->
                    <span id="dropzone-instruction">Drag highlighted terms here to combine them!</span>
                </div>
                <div class="combine-buttons">
                    <button class="combine-btn" id="combine-terms-btn">Combine Terms</button>
                    <button class="combine-btn reset-combine-btn" id="reset-combine-btn">Reset</button>
                </div>
                <div id="combine-result" class="combine-result"></div>
            </div>
            
            <!-- New Answer Input Container -->
            <div class="user-answer-container" id="user-answer-container">
                <div class="answer-label">Type your simplified expression:</div>
                <input type="text" id="user-answer-input" class="answer-input-field" placeholder="e.g., 3x + 2y - 5" autocomplete="off">
                
                <div class="answer-helper-buttons" id="helper-buttons">
                    <button class="helper-btn" data-value="x">x</button>
                    <button class="helper-btn" data-value="y">y</button>
                    <button class="helper-btn" data-value="z">z</button>
                    <button class="helper-btn" data-value="²">²</button>
                    <button class="helper-btn" data-value="³">³</button>
                    <button class="helper-btn" data-value="+">+</button>
                    <button class="helper-btn" data-value="-">-</button>
                    <button class="helper-btn" data-value="=">=</button>
                </div>
                
                <div class="feedback-container" id="answer-feedback"></div>
                <div class="answer-attempts" id="answer-attempts">Attempts: 0 / 3</div>
                <div class="extra-help" id="extra-help"></div>
            </div>
            
            <div class="action-btns">
                <button class="btn hint-btn" id="hint-btn">Get Hint</button>
                <button class="btn check-btn" id="check-btn">Check Answer</button>
                <button class="btn new-problem-btn" id="new-problem-btn">New Problem</button>
            </div>
            
            <div class="result-message" id="result-message"></div>
            
            <div class="hint-panel" id="hint-panel">
                <div class="hint-title">Helpful Hint:</div>
                <div id="hint-content"></div>
            </div>
        </div>
        
        <div class="progress-container">
            <div class="progress-title">Your Learning Progress</div>
            <div class="progress-stats">
                <div class="progress-stat">
                    <div class="stat-value" id="total-points">0</div>
                    <div class="stat-label">Total Points</div>
                </div>
                <div class="progress-stat">
                    <div class="stat-value" id="current-level">1</div>
                    <div class="stat-label">Current Level</div>
                </div>
                <div class="progress-stat">
                    <div class="stat-value" id="current-streak">0</div>
                    <div class="stat-label">Current Streak</div>
                </div>
                <div class="progress-stat">
                    <div class="stat-value" id="highest-streak">0</div>
                    <div class="stat-label">Highest Streak</div>
                </div>
                <div class="progress-stat">
                    <div class="stat-value" id="mastery-count">0</div>
                    <div class="stat-label">Levels Mastered</div>
                </div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="score-display">
                Score: <span id="correct-count">0</span> / <span id="total-count">0</span>
            </div>
        </div>
        
        <div class="achievements-container">
            <div class="achievements-title">Achievements</div>
            <div class="achievements-grid" id="achievements-grid">
                <!-- Achievements will be added here dynamically -->
            </div>
        </div>
    </div>
    
    <div id="characters-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="close-modal">&times;</span>
            <h2 class="modal-title">Meet Your Like Terms Explorer Friends!</h2>
            
            <div class="character-info">
                <svg class="character-img" viewBox="0 0 100 100">
                    <!-- Professor Poly -->
                    <circle cx="50" cy="50" r="40" fill="#4a6fa5" />
                    <circle cx="35" cy="40" r="5" fill="white" />
                    <circle cx="35" cy="40" r="2" fill="black" />
                    <circle cx="65" cy="40" r="5" fill="white" />
                    <circle cx="65" cy="40" r="2" fill="black" />
                    <path d="M 35 65 Q 50 75 65 65" stroke="white" stroke-width="3" fill="transparent" />
                    <ellipse cx="50" cy="30" rx="10" ry="5" fill="white" transform="rotate(-10, 50, 30)" />
                </svg>
                <div>
                    <h3>Professor Poly</h3>
                    <p>A brilliant mathematician who loves teaching about algebra. Professor Poly will guide you through identifying and combining like terms!</p>
                </div>
            </div>
            
            <div class="character-info">
                <svg class="character-img" viewBox="0 0 100 100">
                    <!-- Variable Vicky -->
                    <circle cx="50" cy="50" r="40" fill="#ff9a76" />
                    <circle cx="35" cy="40" r="5" fill="white" />
                    <circle cx="35" cy="40" r="2" fill="black" />
                    <circle cx="65" cy="40" r="5" fill="white" />
                    <circle cx="65" cy="40" r="2" fill="black" />
                    <path d="M 35 60 Q 50 70 65 60" stroke="white" stroke-width="3" fill="transparent" />
                    <path d="M 30 25 L 50 15 L 70 25" stroke="black" stroke-width="2" fill="transparent" />
                    <path d="M 50 15 L 50 30" stroke="black" stroke-width="2" fill="transparent" />
                </svg>
                <div>
                    <h3>Variable Vicky</h3>
                    <p>A world traveler who can identify variables in any expression. She'll teach you how to recognize which terms have the same variables and exponents!</p>
                </div>
            </div>
            
            <div class="character-info">
                <svg class="character-img" viewBox="0 0 100 100">
                    <!-- Term Terry -->
                    <circle cx="50" cy="50" r="40" fill="#6ecb63" />
                    <circle cx="35" cy="40" r="5" fill="white" />
                    <circle cx="35" cy="40" r="2" fill="black" />
                    <circle cx="65" cy="40" r="5" fill="white" />
                    <circle cx="65" cy="40" r="2" fill="black" />
                    <path d="M 35 65 Q 50 55 65 65" stroke="white" stroke-width="3" fill="transparent" />
                    <text x="37" y="30" font-size="16" font-weight="bold" fill="white">3x+2y</text>
                </svg>
                <div>
                    <h3>Term Terry</h3>
                    <p>An energetic character who's passionate about organizing algebraic terms! Terry will help you understand how to combine like terms to simplify expressions!</p>
                </div>
            </div>
            
            <div class="modal-text">
                <p>Together, these friends will help you master the art of combining like terms, from basic expressions to complex algebraic puzzles. Are you ready for the adventure?</p>
            </div>
        </div>
    </div>
    
    <div id="rules-modal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
            <span class="close" id="close-rules-modal">&times;</span>
            <h2 class="modal-title">Like Terms Reference Guide</h2>
            
            <div class="rule-card">
                <h3>1. What are Terms?</h3>
                <p>In algebra, a term is a mathematical expression that can contain numbers, variables, and exponents combined with multiplication and division.</p>
                <div class="example">Terms: 3x, 5y², -7z, 4xy, 12</div>
                <p>Terms are separated by addition or subtraction signs in an expression.</p>
            </div>
            
            <div class="rule-card">
                <h3>2. What are Like Terms?</h3>
                <p>Like terms are terms that have exactly the same variables with exactly the same exponents.</p>
                <div class="example">3x and 5x are like terms (same variable)</div>
                <div class="example">2y² and -4y² are like terms (same variable and exponent)</div>
                <div class="example">7xy and 3xy are like terms (same variables)</div>
                <p>Only the coefficients (the numbers) can be different in like terms.</p>
            </div>
            
            <div class="rule-card">
                <h3>3. What are Unlike Terms?</h3>
                <p>Unlike terms have different variables or different exponents on the same variables.</p>
                <div class="example">3x and 4y are unlike terms (different variables)</div>
                <div class="example">2x and 5x² are unlike terms (different exponents)</div>
                <div class="example">7xy and 2xz are unlike terms (different variables)</div>
            </div>
            
            <div class="rule-card">
                <h3>4. How to Combine Like Terms</h3>
                <p>To combine like terms, add or subtract their coefficients while keeping the variables and exponents the same.</p>
                <div class="example">3x + 5x = 8x</div>
                <div class="example">7y² - 2y² = 5y²</div>
                <div class="example">4xy + 9xy - xy = 12xy</div>
            </div>
            
            <div class="rule-card">
                <h3>5. Simplifying Expressions</h3>
                <p>To simplify an algebraic expression, combine all the like terms.</p>
                <div class="example">2x + 3y + 5x - y = 7x + 2y</div>
                <div class="example">3a² + 4b - a² + 2b = 2a² + 6b</div>
            </div>
            
            <div class="rule-card">
                <h3>6. Constants as Terms</h3>
                <p>Constants (numbers without variables) are also terms and can be combined with other constants.</p>
                <div class="example">3x + 5 + 2x + 7 = 5x + 12</div>
            </div>
            
            <div class="rule-card">
                <h3>7. Distributive Property</h3>
                <p>The distributive property helps create like terms that can be combined.</p>
                <div class="example">3(x + 2) = 3x + 6</div>
                <div class="example">2(a + b) + 5a = 2a + 2b + 5a = 7a + 2b</div>
            </div>
            
            <div class="rule-card">
                <h3>8. Combining Terms with Exponents</h3>
                <p>Remember that terms must have the same variables AND the same exponents to be "like terms".</p>
                <div class="example">x² and x³ are NOT like terms</div>
                <div class="example">3xy² and 5xy² ARE like terms</div>
                <div class="example">2x²y and 4xy² are NOT like terms</div>
            </div>
        </div>
    </div>
    
    <div id="level-up-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="close-level-modal">&times;</span>
            <h2 class="modal-title">Level Up!</h2>
            <div id="level-up-content">
                <!-- Level up content will be added here dynamically -->
            </div>
        </div>
    </div>

    <div id="mastery-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="close-mastery-modal">&times;</span>
            <h2 class="modal-title">Level Mastered!</h2>
            <div id="mastery-content">
                <!-- Mastery content will be added here dynamically -->
            </div>
        </div>
    </div>
    
    <div class="celebration" id="celebration"></div>
    
    <div class="streak-indicator" id="streak-indicator">Streak: 0</div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let currentProblem = null;
        let score = { correct: 0, total: 0 };
        let levelStats = {}; // Store stats for each level
        let points = 0;
        let streak = 0;
        let highestStreak = 0;
        let currentLevel = 1;
        let variablesInfo = {};
        let animationSpeed = 5;
        let colorTheme = 1;
        let helpLevel = 2;
        let objects = [];
        let timer = null;
        let timerInterval = null;
        let timerSeconds = 0;
        let achievements = {};
        let problemStartTime;
        let masteredLevels = [];
        let currentHighlightTool = null;
        let termHighlights = {}; // Stores which terms have which highlight
        let allTerms = []; // Store all terms in the current problem
        let draggedTerms = []; // Terms dragged to the combining area
        let answerAttempts = 0; // Track number of answer attempts
        let maxAttempts = 3; // Maximum attempts allowed per problem

        // Level definitions with clear progression for Like Terms
        const levels = [
            {
                id: 1,
                name: "Term Basics",
                description: "Learn what terms are and identify them",
                color: "var(--level1-color)",
                textColor: "var(--text-color)",
                rule: "A term contains variables, coefficients, and exponents",
                unlockRequirement: 0,
                masteryRequirement: 10 // Correctly answer 10 questions
            },
            {
                id: 2,
                name: "Like vs Unlike Terms",
                description: "Distinguish between like and unlike terms",
                color: "var(--level2-color)",
                textColor: "var(--text-color)",
                rule: "Like terms have the same variables with the same exponents",
                unlockRequirement: 100, // Points needed
                masteryRequirement: 12
            },
            {
                id: 3,
                name: "Simple Combining",
                description: "Combine like terms with the same variable",
                color: "var(--level3-color)",
                textColor: "var(--text-color)",
                rule: "Add or subtract the coefficients of like terms",
                unlockRequirement: 250,
                masteryRequirement: 15
            },
            {
                id: 4,
                name: "Multi-Variable Terms",
                description: "Identify and combine terms with multiple variables",
                color: "var(--level4-color)",
                textColor: "white",
                rule: "Terms must have the same variables and exponents to be 'like'",
                unlockRequirement: 500,
                masteryRequirement: 15
            },
            {
                id: 5,
                name: "Terms with Exponents",
                description: "Combine terms with the same variables and exponents",
                color: "var(--level5-color)",
                textColor: "white",
                rule: "Terms with different exponents are not like terms",
                unlockRequirement: 800,
                masteryRequirement: 18
            },
            {
                id: 6,
                name: "Distributive Property",
                description: "Use the distributive property to create and combine like terms",
                color: "var(--level6-color)",
                textColor: "white",
                rule: "Distribute coefficients to create like terms: a(b + c) = ab + ac",
                unlockRequirement: 1200,
                masteryRequirement: 20
            },
            {
                id: 7,
                name: "Mixed Expressions",
                description: "Simplify expressions with multiple types of terms",
                color: "var(--level7-color)",
                textColor: "white",
                rule: "Group and combine like terms in complex expressions",
                unlockRequirement: 1800,
                masteryRequirement: 25
            },
            {
                id: 8,
                name: "Expert Challenge",
                description: "Master complex expressions with many different terms",
                color: "var(--level8-color)",
                textColor: "white",
                rule: "Apply all rules to simplify complex algebraic expressions",
                unlockRequirement: 2500,
                masteryRequirement: 30
            }
        ];

        // Achievement definitions
        const achievementsList = [
            {
                id: "first_correct",
                name: "First Steps",
                icon: "🏆",
                description: "Solve your first problem correctly",
                condition: () => score.correct >= 1
            },
            {
                id: "level_2",
                name: "Level Up!",
                icon: "🔼",
                description: "Unlock Level 2",
                condition: () => isLevelUnlocked(2)
            },
            {
                id: "streak_5",
                name: "On Fire!",
                icon: "🔥",
                description: "Get a streak of 5 correct answers",
                condition: () => streak >= 5 || highestStreak >= 5
            },
            {
                id: "master_highlighter",
                name: "Master Highlighter",
                icon: "🖌️",
                description: "Use all highlight tools in a single problem",
                condition: () => false // Will be checked separately
            },
            {
                id: "first_mastery",
                name: "Mastery Begins",
                icon: "📚",
                description: "Master your first level",
                condition: () => masteredLevels.length >= 1
            },
            {
                id: "speed_demon",
                name: "Speed Demon",
                icon: "⏱️",
                description: "Solve a problem in under 10 seconds",
                condition: () => false // Will be checked separately
            },
            {
                id: "term_tamer",
                name: "Term Tamer",
                icon: "🧩",
                description: "Correctly identify 20 different like terms",
                condition: () => false // Tracked separately
            },
            {
                id: "half_mastery",
                name: "Halfway Expert",
                icon: "🏅",
                description: "Master 4 out of 8 levels",
                condition: () => masteredLevels.length >= 4
            },
            {
                id: "perfect_math",
                name: "Perfect Math",
                icon: "🎯",
                description: "Enter the correct answer on the first try 5 times in a row",
                condition: () => false // Will be tracked separately
            },
            {
                id: "algebra_master",
                name: "Algebra Master",
                icon: "🌟",
                description: "Master all 8 levels",
                condition: () => masteredLevels.length >= 8
            },
            {
                id: "century",
                name: "Century",
                icon: "💯",
                description: "Reach 100 correct answers",
                condition: () => score.correct >= 100
            }
        ];

        // Character messages for different levels and situations
        const characterMessages = {
            professor: {
                generic: [
                    "Remember to look for the same variables and exponents!",
                    "Take your time and think step by step.",
                    "Like terms have exactly the same variables and exponents.",
                    "When in doubt, break down the problem into smaller parts.",
                    "The key to algebra is understanding like terms!"
                ],
                level1: [
                    "A term can have variables, coefficients, and exponents!",
                    "Variables like x, y, and z represent unknown quantities.",
                    "The coefficient is the number in front of a variable.",
                    "Examples of terms: 3x, -5y², 7ab, and 12 (constants are terms too)."
                ],
                level2: [
                    "Like terms must have the same variables with the same exponents!",
                    "3x and 5x are like terms, but 3x and 5y are not.",
                    "2x² and -7x² are like terms, but 2x² and 3x are not.",
                    "Only the coefficients can be different in like terms."
                ],
                level3: [
                    "To combine like terms, add or subtract their coefficients!",
                    "3x + 4x = 7x because 3 + 4 = 7!",
                    "5y - 2y = 3y because 5 - 2 = 3!",
                    "Only like terms can be combined. Leave unlike terms as they are."
                ],
                level4: [
                    "Terms with multiple variables follow the same rules!",
                    "4xy and 7xy are like terms, but 4xy and 7xz are not.",
                    "Remember that order doesn't matter: xy = yx",
                    "But 3xy² and 3x²y are not like terms!"
                ],
                level5: [
                    "Watch the exponents carefully!",
                    "x² and x³ are not like terms - the exponents are different!",
                    "5y⁴ and 3y⁴ are like terms - same variable and exponent.",
                    "Remember: like terms need the same variables AND the same exponents."
                ],
                level6: [
                    "Use the distributive property to expand expressions!",
                    "3(x + 2) = 3x + 6",
                    "2(a + b) - 4(a - c) = 2a + 2b - 4a + 4c = -2a + 2b + 4c",
                    "After distributing, combine the like terms."
                ],
                level7: [
                    "Group like terms together first, then combine them.",
                    "Look for terms with identical variables and exponents.",
                    "Don't forget about constant terms - they're like terms too!",
                    "Take it step by step and you'll master any expression."
                ],
                level8: [
                    "Complex expressions can be broken down into groups of like terms.",
                    "Identify each type of term and combine them separately.",
                    "Use all the skills you've learned to simplify expressions.",
                    "Remember to check your work by verifying like terms."
                ],
                answer_feedback: [
                    "Try again! Remember to combine like terms by adding their coefficients.",
                    "Not quite! Make sure you're only combining terms with the same variables and exponents.",
                    "Let's double-check your work. Are you keeping track of positive and negative signs?",
                    "Look at your simplified terms. Did you write the variables correctly?",
                    "Almost there! Make sure your answer is in the simplest form."
                ]
            },
            vicky: {
                generic: [
                    "Variables are the heart of algebra!",
                    "Each variable represents a specific value that we're trying to find.",
                    "Different variables represent different unknown values.",
                    "Variables with the same name represent the same value.",
                    "The fun part is figuring out what each variable equals!"
                ],
                hint: [
                    "Try using the highlight tools to mark terms with the same variables!",
                    "Use different colors for different types of terms!",
                    "Group the yellow terms together, then the blue terms, and so on!",
                    "If two terms have different highlights, they're not like terms!",
                    "Highlighting helps you see patterns in the expression!"
                ],
                answer_feedback: [
                    "When typing your answer, make sure you write the variables exactly as they appear in the problem.",
                    "Remember to include the exponents in your answer if they're in the original terms.",
                    "Check that you've accounted for all the different types of terms in your answer.",
                    "Make sure the variables in your answer match the ones in the original problem."
                ]
            },
            terry: {
                generic: [
                    "Combining like terms makes expressions simpler!",
                    "Like terms are your friends - they want to be together!",
                    "Think of like terms as similar objects that can be counted together.",
                    "Simplifying expressions makes them easier to work with!"
                ],
                level1: [
                    "Let's learn to identify different types of terms!",
                    "Each term can have different properties.",
                    "We'll use highlighting to identify similar terms!"
                ],
                level2: [
                    "Like terms are terms with the same variables and exponents!",
                    "3x and 5x are like terms - both have x raised to the first power.",
                    "Different variables? Not like terms! Different exponents? Not like terms!"
                ],
                level3: [
                    "Time to combine like terms!",
                    "Add their coefficients to combine like terms: 2x + 3x = 5x",
                    "Subtract their coefficients: 7y - 4y = 3y"
                ],
                level4: [
                    "Multi-variable terms can be combined too!",
                    "4xy and 7xy are like terms - add coefficients: 4xy + 7xy = 11xy",
                    "But xy and x²y have different exponents - they're not like terms!"
                ],
                level5: [
                    "Pay attention to the exponents!",
                    "5x² and 3x² are like terms because they have the same variable and exponent.",
                    "But x and x² are not like terms - different exponents!"
                ],
                level6: [
                    "Use the distributive property to expand parentheses!",
                    "2(x + 3) = 2x + 6",
                    "After expanding, look for like terms to combine!"
                ],
                level7: [
                    "Group like terms together, then combine each group!",
                    "3x + 5y + 2x + 7y = (3x + 2x) + (5y + 7y) = 5x + 12y",
                    "Step by step, we can simplify complex expressions!"
                ],
                level8: [
                    "You can handle any expression by identifying like terms!",
                    "Break it down into steps: highlight, group, combine!",
                    "You're becoming an algebra master!"
                ],
                correct: [
                    "Great job! You're getting the hang of like terms!",
                    "Excellent! You're becoming an algebra pro!",
                    "Perfect! Your algebra skills are growing!",
                    "Absolutely correct! You're on fire!",
                    "Amazing work! You're a like terms expert!"
                ],
                streak: [
                    "Wow! Your streak is growing algebraically!",
                    "What a streak! You're on a roll!",
                    "Keep up that streak! You're unstoppable!",
                    "Look at that streak go! You're a math machine!"
                ],
                answer_feedback: [
                    "Perfect! That's exactly right!",
                    "Magnificent! You've combined those terms perfectly!",
                    "Awesome job! Your simplified answer is correct!",
                    "You've got it! That's the correct simplified expression!",
                    "Well done! You've mastered combining like terms!"
                ]
            }
        };

        // Latin alphabet and common variables
        const commonVariables = ["x", "y", "z", "a", "b", "c", "m", "n", "p", "t"];
        
        // More interesting variables for higher levels
        const specialVariables = ["α", "β", "γ", "θ", "λ", "ω", "φ", "ψ"];

        // Initialize the game when the page loads
        window.onload = initGame;

        function initGame() {
            initThreeJS();
            loadProgress();
            createLevelButtons();
            setupEventListeners();
            updateControlLabels();
            createAchievements();
            showCharacterIntroductions();
            setupAnswerHelpers();
            
            // Initialize the level stats in localStorage if not already present
            for (let i = 1; i <= levels.length; i++) {
                if (!localStorage.getItem(`level_${i}_stats`)) {
                    levelStats[i] = { correct: 0, total: 0, points: 0 };
                    saveLevelStats(i, levelStats[i]);
                } else {
                    levelStats[i] = getLevelStats(i);
                }
            }
            
            // Update mastery count
            updateMasteryCount();
        }

        // Initialize Three.js visualization
        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f8ff);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, document.getElementById('visualization').offsetWidth / document.getElementById('visualization').offsetHeight, 0.1, 1000);
            camera.position.z = 5;

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(document.getElementById('visualization').offsetWidth, document.getElementById('visualization').offsetHeight);
            document.getElementById('visualization').appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = document.getElementById('visualization').offsetWidth / document.getElementById('visualization').offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(document.getElementById('visualization').offsetWidth, document.getElementById('visualization').offsetHeight);
            });

            // Start animation loop
            animate();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate objects based on animation speed
            objects.forEach((obj) => {
                obj.rotation.x += 0.001 * animationSpeed;
                obj.rotation.y += 0.002 * animationSpeed;
            });
            
            renderer.render(scene, camera);
        }

        // Create level selection buttons
        function createLevelButtons() {
            const levelsContainer = document.getElementById('levels-container');
            levelsContainer.innerHTML = '';
            
            levels.forEach(level => {
                const levelBtn = document.createElement('button');
                levelBtn.className = 'level-btn';
                levelBtn.id = `level-${level.id}-btn`;
                levelBtn.textContent = `Level ${level.id}: ${level.name}`;
                levelBtn.style.backgroundColor = level.color;
                levelBtn.style.color = level.textColor;
                
                // Check if level is mastered
                if (masteredLevels.includes(level.id)) {
                    const masteryBadge = document.createElement('span');
                    masteryBadge.className = 'mastery-badge';
                    masteryBadge.textContent = '★ Mastered';
                    levelBtn.appendChild(document.createElement('br'));
                    levelBtn.appendChild(masteryBadge);
                }
                
                // Add click event listener - all levels are accessible
                levelBtn.addEventListener('click', () => selectLevel(level.id));
                
                // Highlight current level
                if (level.id === currentLevel) {
                    levelBtn.classList.add('selected');
                }
                
                levelsContainer.appendChild(levelBtn);
            });
        }

        // Setup event listeners for controls and buttons
        function setupEventListeners() {
            // Slider event listeners
            document.getElementById('difficulty-slider').addEventListener('input', function() {
                const difficultyLabels = ["Easy", "Medium", "Hard"];
                document.getElementById('difficulty-value').textContent = difficultyLabels[this.value - 1];
            });
            
            document.getElementById('timer-slider').addEventListener('input', function() {
                const timerLabels = ["Off", "30 sec", "60 sec", "90 sec"];
                document.getElementById('timer-value').textContent = timerLabels[this.value];
                
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                document.getElementById('timer').textContent = "Time: 00:00";
                timerSeconds = 0;
                
                if (this.value > 0 && currentProblem) {
                    startTimer(parseInt(this.value) * 30);
                }
            });
            
            document.getElementById('speed-slider').addEventListener('input', function() {
                document.getElementById('speed-value').textContent = this.value;
                animationSpeed = parseInt(this.value);
            });
            
            document.getElementById('color-slider').addEventListener('input', function() {
                const colorLabels = ["Vibrant", "Pastel", "Monochrome"];
                document.getElementById('color-value').textContent = colorLabels[this.value - 1];
                colorTheme = parseInt(this.value);
                updateVisualization();
            });
            
            document.getElementById('character-slider').addEventListener('input', function() {
                const helpLabels = ["Minimal", "Medium", "Maximum"];
                document.getElementById('character-value').textContent = helpLabels[this.value - 1];
                helpLevel = parseInt(this.value);
            });
            
            // Button event listeners
            document.getElementById('hint-btn').addEventListener('click', showHint);
            document.getElementById('check-btn').addEventListener('click', checkAnswer);
            document.getElementById('new-problem-btn').addEventListener('click', generateNewProblem);
            document.getElementById('intro-btn').addEventListener('click', showCharactersModal);
            document.getElementById('rules-btn').addEventListener('click', showRulesModal);
            document.getElementById('close-modal').addEventListener('click', hideCharactersModal);
            document.getElementById('close-rules-modal').addEventListener('click', hideRulesModal);
            document.getElementById('close-level-modal').addEventListener('click', hideLevelUpModal);
            document.getElementById('close-mastery-modal').addEventListener('click', hideMasteryModal);
            
            // Setup highlight tool listeners
            const highlightTools = document.querySelectorAll('.highlight-tool');
            highlightTools.forEach(tool => {
                tool.addEventListener('click', function() {
                    const highlight = this.dataset.highlight;
                    
                    // Toggle currently selected tool
                    document.querySelectorAll('.highlight-tool').forEach(t => t.classList.remove('active'));
                    
                    if (currentHighlightTool === highlight && this.id !== 'eraser-tool') {
                        currentHighlightTool = null;
                    } else {
                        this.classList.add('active');
                        currentHighlightTool = highlight;
                    }
                });
            });
            
            // Eraser tool special case
            document.getElementById('eraser-tool').addEventListener('click', function() {
                document.querySelectorAll('.highlight-tool').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                currentHighlightTool = 'eraser';
            });
            
            // Clear all highlights button
            document.getElementById('clear-highlights-btn').addEventListener('click', clearAllHighlights);
            
            // Combine terms button
            document.getElementById('combine-terms-btn').addEventListener('click', combineSelectedTerms);
            
            // Reset combine button
            document.getElementById('reset-combine-btn').addEventListener('click', resetCombineArea);
            
            // User answer input - check on Enter key
            document.getElementById('user-answer-input').addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    checkUserAnswer();
                }
            });
            
            // Close modals when clicking outside of them
            window.addEventListener('click', function(event) {
                if (event.target === document.getElementById('characters-modal')) {
                    hideCharactersModal();
                }
                if (event.target === document.getElementById('rules-modal')) {
                    hideRulesModal();
                }
                if (event.target === document.getElementById('level-up-modal')) {
                    hideLevelUpModal();
                }
                if (event.target === document.getElementById('mastery-modal')) {
                    hideMasteryModal();
                }
            });
        }

        // Setup helper buttons for answer input
        function setupAnswerHelpers() {
            // Add dynamic variables from current problem
            updateHelperButtons();

            // Add event listeners to helper buttons
            document.getElementById('helper-buttons').addEventListener('click', function(event) {
                if (event.target.classList.contains('helper-btn')) {
                    const answerInput = document.getElementById('user-answer-input');
                    const value = event.target.dataset.value;
                    
                    // Insert value at cursor position
                    const startPos = answerInput.selectionStart;
                    const endPos = answerInput.selectionEnd;
                    const currentValue = answerInput.value;
                    
                    answerInput.value = currentValue.substring(0, startPos) + value + currentValue.substring(endPos);
                    
                    // Reset cursor position
                    answerInput.selectionStart = answerInput.selectionEnd = startPos + value.length;
                    answerInput.focus();
                }
            });
        }

        // Update helper buttons based on current problem
        function updateHelperButtons() {
            const helperContainer = document.getElementById('helper-buttons');
            
            // Clear existing buttons
            helperContainer.innerHTML = '';
            
            // Add standard helper buttons
            const standardButtons = ['+', '-', '='];
            
            // Add problem-specific variable buttons
            let uniqueVars = new Set();
            if (currentProblem && currentProblem.terms) {
                currentProblem.terms.forEach(term => {
                    if (term.variables) {
                        term.variables.forEach(variable => {
                            uniqueVars.add(variable.name);
                            if (variable.exponent > 1) {
                                uniqueVars.add(`${variable.name}²`);
                                uniqueVars.add(`${variable.name}³`);
                            }
                        });
                    }
                });
            } else {
                // Default variables if no problem is loaded
                uniqueVars = new Set(['x', 'y', 'z', 'x²', 'y²', 'z²']);
            }
            
            // Create buttons for all variables
            [...uniqueVars].sort().forEach(variable => {
                const btn = document.createElement('button');
                btn.className = 'helper-btn';
                btn.dataset.value = variable;
                btn.textContent = variable;
                helperContainer.appendChild(btn);
            });
            
            // Add standard buttons
            standardButtons.forEach(symbol => {
                const btn = document.createElement('button');
                btn.className = 'helper-btn';
                btn.dataset.value = symbol;
                btn.textContent = symbol;
                helperContainer.appendChild(btn);
            });
            
            // Add exponent buttons
            const exponentBtn1 = document.createElement('button');
            exponentBtn1.className = 'helper-btn';
            exponentBtn1.dataset.value = '²';
            exponentBtn1.textContent = '²';
            helperContainer.appendChild(exponentBtn1);
            
            const exponentBtn2 = document.createElement('button');
            exponentBtn2.className = 'helper-btn';
            exponentBtn2.dataset.value = '³';
            exponentBtn2.textContent = '³';
            helperContainer.appendChild(exponentBtn2);
        }

        // Update control labels based on slider values
        function updateControlLabels() {
            const difficultyLabels = ["Easy", "Medium", "Hard"];
            document.getElementById('difficulty-value').textContent = difficultyLabels[document.getElementById('difficulty-slider').value - 1];
            
            const timerLabels = ["Off", "30 sec", "60 sec", "90 sec"];
            document.getElementById('timer-value').textContent = timerLabels[document.getElementById('timer-slider').value];
            
            document.getElementById('speed-value').textContent = document.getElementById('speed-slider').value;
            
            const colorLabels = ["Vibrant", "Pastel", "Monochrome"];
            document.getElementById('color-value').textContent = colorLabels[document.getElementById('color-slider').value - 1];
            
            const helpLabels = ["Minimal", "Medium", "Maximum"];
            document.getElementById('character-value').textContent = helpLabels[document.getElementById('character-slider').value - 1];
        }

        // Show character introductions with animations
        function showCharacterIntroductions() {
            const speeches = [
                document.getElementById('professor-speech'),
                document.getElementById('vicky-speech'),
                document.getElementById('terry-speech')
            ];
            
            // Clear any existing timeouts
            speeches.forEach(s => {
                s.style.opacity = 0;
            });
            
            // Show speech bubbles sequentially
            setTimeout(() => {
                speeches[0].style.opacity = 1;
                setTimeout(() => {
                    speeches[0].style.opacity = 0;
                    speeches[1].style.opacity = 1;
                    setTimeout(() => {
                        speeches[1].style.opacity = 0;
                        speeches[2].style.opacity = 1;
                        setTimeout(() => {
                            speeches[2].style.opacity = 0;
                        }, 3000);
                    }, 3000);
                }, 3000);
            }, 1000);
        }

        // Select a level
        function selectLevel(levelId) {
            currentLevel = levelId;
            document.getElementById('current-level').textContent = levelId;
            
            // Update level buttons to highlight the selected level
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            const selectedLevelBtn = document.getElementById(`level-${levelId}-btn`);
            selectedLevelBtn.classList.add('selected');
            
            // Update level info display
            const levelInfo = levels.find(level => level.id === levelId);
            document.getElementById('level-info').textContent = `Level ${levelId}: ${levelInfo.name} - ${levelInfo.description}`;
            document.getElementById('level-info').style.backgroundColor = levelInfo.color;
            document.getElementById('level-info').style.color = levelInfo.textColor;
            
            // Generate a new problem for this level
            generateNewProblem();
            
            // Show character message about the level
            showLevelCharacterMessage(levelId);
            
            // Save current level to localStorage
            localStorage.setItem('current_level', levelId);
        }

        // Show a character message about the selected level
        function showLevelCharacterMessage(levelId) {
            const levelMessages = characterMessages.professor[`level${levelId}`];
            if (levelMessages && levelMessages.length > 0) {
                const randomMessage = levelMessages[Math.floor(Math.random() * levelMessages.length)];
                showCharacterMessage('professor', randomMessage);
            }
        }

        // Check if a level is unlocked based on points
        function isLevelUnlocked(levelId) {
            const level = levels.find(l => l.id === levelId);
            return points >= level.unlockRequirement;
        }

        // Generate a new problem based on the current level
        function generateNewProblem() {
            // Clear previous problem
            clearProblemDisplay();

            // Hide hint panel
            document.getElementById('hint-panel').style.display = 'none';
            
            // Reset result message
            const resultMessage = document.getElementById('result-message');
            resultMessage.textContent = '';
            resultMessage.style.opacity = 0;
            resultMessage.style.backgroundColor = '';
            
            // Reset answer input
            document.getElementById('user-answer-input').value = '';
            document.getElementById('answer-feedback').textContent = '';
            document.getElementById('answer-feedback').className = 'feedback-container';
            document.getElementById('extra-help').style.display = 'none';
            
            // Reset answer attempts
            answerAttempts = 0;
            document.getElementById('answer-attempts').textContent = `Attempts: ${answerAttempts} / ${maxAttempts}`;
            
            // Reset combine area
            resetCombineArea();
            
            // Clear all highlights
            clearAllHighlights();
            
            // Reset selected highlight tool
            currentHighlightTool = null;
            document.querySelectorAll('.highlight-tool').forEach(t => t.classList.remove('active'));
            
            // Get problem settings
            const difficulty = parseInt(document.getElementById('difficulty-slider').value);
            
            // Generate problem based on current level
            currentProblem = createProblemForLevel(currentLevel, difficulty);
            
            // Display problem
            displayProblem(currentProblem);
            
// Update visualization
updateVisualization();
            
            // Update helper buttons for the new problem
            updateHelperButtons();
            
            // Show random character message
            showRandomCharacterMessage();
            
            // Record problem start time for speed achievement
            problemStartTime = new Date();
            
            // Start timer if enabled
            const timerSetting = parseInt(document.getElementById('timer-slider').value);
            if (timerSetting > 0) {
                startTimer(timerSetting * 30); // Convert to seconds
            }
        }

        // Check user's answer when they click "Check Answer" or press Enter
        function checkUserAnswer() {
            if (!currentProblem) return;
            
            const userAnswer = document.getElementById('user-answer-input').value.trim();
            const feedback = document.getElementById('answer-feedback');
            const extraHelp = document.getElementById('extra-help');
            
            // If answer is empty, prompt user
            if (!userAnswer) {
                feedback.textContent = "Please enter your answer before checking!";
                feedback.className = 'feedback-container feedback-incorrect';
                feedback.style.opacity = 1;
                return;
            }

            // Increment attempt counter
            answerAttempts++;
            document.getElementById('answer-attempts').textContent = `Attempts: ${answerAttempts} / ${maxAttempts}`;
            
            // Check if answer is correct
            const isCorrect = checkAnswerCorrectness(userAnswer, currentProblem.simplifiedExpression);
            
            if (isCorrect) {
                // Show success feedback
                feedback.textContent = "Correct! Great job!";
                feedback.className = 'feedback-container feedback-correct';
                feedback.style.opacity = 1;
                
                // Show character celebration message
                const terryMessages = characterMessages.terry.answer_feedback;
                const randomMessage = terryMessages[Math.floor(Math.random() * terryMessages.length)];
                showCharacterMessage('terry', randomMessage);
                
                // Process correct answer (update score, etc.)
                processCorrectAnswer();
                
                // Disable input
                document.getElementById('user-answer-input').disabled = true;
            } else {
                // Show failure feedback
                feedback.textContent = "Not quite right. Try again!";
                feedback.className = 'feedback-container feedback-incorrect';
                feedback.style.opacity = 1;
                
                // Show character help message
                const character = answerAttempts <= 1 ? 'professor' : 'vicky';
                const messageList = characterMessages[character].answer_feedback;
                const message = messageList[Math.min(answerAttempts - 1, messageList.length - 1)];
                showCharacterMessage(character, message);
                
                // If max attempts reached, show solution
                if (answerAttempts >= maxAttempts) {
                    showSolution();
                }
                // On second attempt, provide more detailed help
                else if (answerAttempts >= 2) {
                    showExtraHelp();
                }
            }
        }
        
        // Check if user's answer is mathematically equivalent to the correct answer
        function checkAnswerCorrectness(userAnswer, correctAnswer) {
            try {
                // Standardize inputs for comparison
                const standardizedUser = standardizeExpression(userAnswer);
                const standardizedCorrect = standardizeExpression(correctAnswer);
                
                // For simple comparison, check if they're the same
                if (standardizedUser === standardizedCorrect) {
                    return true;
                }
                
                // Try to use MathJS to check if expressions are equivalent
                try {
                    // Parse both expressions with mathjs
                    const userExpr = math.parse(standardizedUser);
                    const correctExpr = math.parse(standardizedCorrect);
                    
                    // Check if they simplify to the same expression
                    const userSimplified = userExpr.toString();
                    const correctSimplified = correctExpr.toString();
                    
                    return userSimplified === correctSimplified;
                } catch (mathError) {
                    // Math.js parsing failed, fall back to simpler checks
                    console.log("Math parsing error:", mathError);
                }
                
                // For more advanced comparison (future enhancement)
                // We could expand this by checking for algebraic equivalence
                
                return false;
            } catch (error) {
                console.error("Error comparing answers:", error);
                return false;
            }
        }
        
        // Standardize expression for comparison
        function standardizeExpression(expr) {
            if (!expr) return "";
            
            // Replace unicode exponents with carets
            let standardized = expr.replace(/²/g, "^2").replace(/³/g, "^3");
            
            // Remove all spaces
            standardized = standardized.replace(/\s+/g, "");
            
            // Replace -- with + (double negative)
            standardized = standardized.replace(/--/g, "+");
            
            // Replace +- with - (simplify signs)
            standardized = standardized.replace(/\+-/g, "-");
            
            // Ensure there's no leading + sign
            standardized = standardized.replace(/^\+/, "");
            
            // Replace explicit multiplication signs if present
            standardized = standardized.replace(/\*/g, "");
            
            return standardized;
        }
        
        // Show the correct solution after max attempts
        function showSolution() {
            const extraHelp = document.getElementById('extra-help');
            extraHelp.innerHTML = `
                <p><strong>The correct simplified expression is:</strong></p>
                <p style="font-size: 24px; font-weight: bold; margin: 10px 0;">${currentProblem.simplifiedExpression}</p>
                <p>Let's see why:</p>
                <ol style="text-align: left; padding-left: 20px;">
            `;
            
            // Add explanation steps based on level
            currentProblem.steps.forEach(step => {
                extraHelp.innerHTML += `<li>${step}</li>`;
            });
            
            extraHelp.innerHTML += `</ol>`;
            extraHelp.style.display = 'block';
            
            // Show character message with explanation
            showCharacterMessage('professor', "Don't worry if you didn't get it this time. Let's look at the correct answer together!");
        }
        
        // Show additional help after second attempt
        function showExtraHelp() {
            const extraHelp = document.getElementById('extra-help');
            extraHelp.innerHTML = `
                <p><strong>Hint:</strong> Remember to identify like terms first!</p>
                <p>Like terms have the same variables with the same exponents.</p>
                <p>Group like terms together, then add or subtract their coefficients.</p>
            `;
            
            // Add specific examples based on the current problem
            if (currentProblem.likeTermGroups && currentProblem.likeTermGroups.length > 0) {
                extraHelp.innerHTML += `<p>For example, in this problem:</p><ul>`;
                
                for (let i = 0; i < Math.min(2, currentProblem.likeTermGroups.length); i++) {
                    const group = currentProblem.likeTermGroups[i];
                    if (group.length >= 2) {
                        const terms = group.map(term => term.raw).join(' and ');
                        extraHelp.innerHTML += `<li>${terms} are like terms</li>`;
                    }
                }
                
                extraHelp.innerHTML += `</ul>`;
            }
            
            extraHelp.style.display = 'block';
        }
        
        // Process a correct answer (update score, streak, etc.)
        function processCorrectAnswer() {
            // Calculate time taken
            const endTime = new Date();
            const timeTaken = (endTime - problemStartTime) / 1000; // in seconds
            
            // Update score
            score.total++;
            score.correct++;
            document.getElementById('total-count').textContent = score.total;
            document.getElementById('correct-count').textContent = score.correct;
            
            // Get or initialize level stats
            if (!levelStats[currentProblem.levelId]) {
                levelStats[currentProblem.levelId] = { correct: 0, total: 0, points: 0 };
            }
            
            // Update level stats
            levelStats[currentProblem.levelId].total++;
            levelStats[currentProblem.levelId].correct++;
            
            // Calculate points based on level, difficulty, and time
            const basePoints = currentProblem.levelId * 25;
            const difficultyBonus = currentProblem.difficulty * 15;
            const timeBonus = Math.max(0, 60 - Math.floor(timeTaken)) * 2; // Faster solutions get more points
            const attemptBonus = Math.max(0, (maxAttempts - answerAttempts + 1) * 15); // Fewer attempts get more points
            
            const earnedPoints = basePoints + difficultyBonus + timeBonus + attemptBonus;
            points += earnedPoints;
            levelStats[currentProblem.levelId].points += earnedPoints;
            
            // Update streak
            streak++;
            if (streak > highestStreak) {
                highestStreak = streak;
                document.getElementById('highest-streak').textContent = highestStreak;
            }
            
            document.getElementById('current-streak').textContent = streak;
            document.getElementById('total-points').textContent = points;
            
            // Show streak indicator
            showStreakIndicator();
            
            // Check for speed achievement
            if (timeTaken < 10) {
                unlockAchievement('speed_demon');
            }
            
            // Check if level is mastered
            checkLevelMastery(currentProblem.levelId);
            
            // Check for other achievements
            checkAchievements();
            
            // Show celebration for correct answer
            if (streak >= 3) {
                showCelebration();
            }
            
            // Update result message
            const resultMessage = document.getElementById('result-message');
            resultMessage.textContent = `Correct! You earned ${earnedPoints} points!`;
            resultMessage.style.backgroundColor = "rgba(102, 187, 106, 0.2)";
            resultMessage.style.opacity = 1;
            
            // Show congratulatory character message
            if (streak >= 5) {
                const streakMessages = characterMessages.terry.streak;
                const randomMessage = streakMessages[Math.floor(Math.random() * streakMessages.length)];
                showCharacterMessage('terry', randomMessage);
            }
            
            // Save level stats
            saveLevelStats(currentProblem.levelId, levelStats[currentProblem.levelId]);
            
            // Update progress bar
            updateProgress();
            
            // Save progress to localStorage
            saveProgress();
            
            // Stop timer if running
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Start a timer for the problem
        function startTimer(seconds) {
            // Clear any existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerSeconds = 0;
            const timerDisplay = document.getElementById('timer');
            timerDisplay.textContent = "Time: 00:00";
            timerDisplay.style.color = "var(--text-color)";
            
            timerInterval = setInterval(() => {
                timerSeconds++;
                
                // Format the time
                const minutes = Math.floor(timerSeconds / 60);
                const secs = timerSeconds % 60;
                timerDisplay.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                
                // Add warning color when less than 10 seconds left
                if (seconds > 0 && timerSeconds >= seconds - 10 && timerSeconds < seconds) {
                    timerDisplay.style.color = "orange";
                }
                
                // Check if time is up
                if (seconds > 0 && timerSeconds >= seconds) {
                    clearInterval(timerInterval);
                    timerDisplay.textContent = "Time's up!";
                    timerDisplay.style.color = "red";
                    
                    // Auto-check the answer
                    checkUserAnswer();
                }
            }, 1000);
        }

        // Create a problem based on the current level and difficulty
        function createProblemForLevel(levelId, difficulty) {
            let problem = {
                levelId,
                difficulty,
                expression: "",
                terms: [],
                likeTermGroups: [],
                simplifiedExpression: "",
                steps: []
            };
            
            // Generate problem based on level
            switch (levelId) {
                case 1: // Term Basics
                    problem = generateTermBasicsProblem(problem, difficulty);
                    break;
                case 2: // Like vs Unlike Terms
                    problem = generateLikeUnlikeProblem(problem, difficulty);
                    break;
                case 3: // Simple Combining
                    problem = generateSimpleCombiningProblem(problem, difficulty);
                    break;
                case 4: // Multi-Variable Terms
                    problem = generateMultiVariableProblem(problem, difficulty);
                    break;
                case 5: // Terms with Exponents
                    problem = generateExponentTermsProblem(problem, difficulty);
                    break;
                case 6: // Distributive Property
                    problem = generateDistributiveProblem(problem, difficulty);
                    break;
                case 7: // Mixed Expressions
                    problem = generateMixedExpressionProblem(problem, difficulty);
                    break;
                case 8: // Expert Challenge
                    problem = generateExpertChallengeProblem(problem, difficulty);
                    break;
                default:
                    // Default to basic term problem
                    problem = generateTermBasicsProblem(problem, difficulty);
            }
            
            // Store all terms for the problem
            allTerms = [...problem.terms];
            
            return problem;
        }

        // Generate Term Basics problem (Level 1)
        function generateTermBasicsProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVariables = difficulty + 1; // 2 to 4 variables
            const variables = getRandomVariables(numVariables, false);
            
            // Generate terms with single variables
            let terms = [];
            const numTerms = difficulty * 2 + 2; // 4, 6, or 8 terms
            
            for (let i = 0; i < numTerms; i++) {
                const variable = variables[Math.floor(Math.random() * variables.length)];
                const coefficient = Math.floor(Math.random() * 9) + 1; // 1 to 9
                const sign = Math.random() > 0.5 ? '+' : '-';
                
                terms.push({
                    coefficient: sign === '-' ? -coefficient : coefficient,
                    variables: [{ name: variable, exponent: 1 }],
                    display: `${i === 0 ? (sign === '-' ? '-' : '') : sign} ${coefficient}${variable}`,
                    raw: `${sign === '-' ? '-' : ''}${coefficient}${variable}`,
                    group: variable // Group by variable
                });
            }
            
            // Add constant term
            if (difficulty > 1 || Math.random() > 0.5) {
                const constant = Math.floor(Math.random() * 20) + 1; // 1 to 20
                const sign = Math.random() > 0.5 ? '+' : '-';
                
                terms.push({
                    coefficient: sign === '-' ? -constant : constant,
                    variables: [],
                    display: `${sign} ${constant}`,
                    raw: `${sign === '-' ? '-' : ''}${constant}`,
                    group: 'constant'
                });
            }
            
            // Create problem expression
            let expression = '';
            terms.forEach((term, index) => {
                if (index === 0) {
                    expression += term.display.replace(/^\+ /, ''); // Remove leading + if present
                } else {
                    expression += ' ' + term.display; // Add space before the term
                }
            });
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Create simplified expression for Level 1
            let simplifiedTerms = [];
            for (const [group, groupTerms] of Object.entries(likeTermGroups)) {
                // For level 1, we don't actually combine terms - just identify them
                // But we need a simplified expression for checking answers
                // Just use each term as is
                simplifiedTerms.push(...groupTerms);
            }
            
            // Sort the terms for consistent output
            simplifiedTerms.sort((a, b) => {
                // Constants last
                if (a.group === 'constant' && b.group !== 'constant') return 1;
                if (a.group !== 'constant' && b.group === 'constant') return -1;
                
                // Alphabetical by variable name
                return a.group.localeCompare(b.group);
            });
            
            let simplifiedExpression = '';
            simplifiedTerms.forEach((term, index) => {
                if (index === 0) {
                    simplifiedExpression += term.raw.replace(/^\+/, ''); // Remove leading + if present
                } else {
                    const sign = term.coefficient >= 0 ? ' + ' : ' ';
                    simplifiedExpression += sign + term.raw.replace(/^[+-]/, ''); // Add space and appropriate sign
                }
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = expression; // For level 1, simplified is same as original
            
            // For level 1, the user just needs to identify terms
            problem.steps = ["Identify the variables in each term.", 
                           "Look for terms with the same variable.", 
                           "Group terms with the same variable together."];
            
            return problem;
        }

        // Generate Like vs Unlike Terms problem (Level 2)
        function generateLikeUnlikeProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVariables = Math.min(difficulty + 2, 5); // 3 to 5 variables
            const variables = getRandomVariables(numVariables, false);
            
            // Generate terms with single variables
            let terms = [];
            const numTerms = difficulty * 3 + 3; // 6, 9, or 12 terms
            
            for (let i = 0; i < numTerms; i++) {
                const variable = variables[Math.floor(Math.random() * variables.length)];
                const coefficient = Math.floor(Math.random() * 9) + 1; // 1 to 9
                const sign = Math.random() > 0.5 ? '+' : '-';
                
                // Decide on exponent
                let exponent = 1;
                if (difficulty > 1 && Math.random() > 0.6) {
                    exponent = Math.floor(Math.random() * 2) + 2; // Occasionally use exponents 2 or 3
                }
                
                const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                
                terms.push({
                    coefficient: sign === '-' ? -coefficient : coefficient,
                    variables: [{ name: variable, exponent: exponent }],
                    display: `${i === 0 ? (sign === '-' ? '-' : '') : sign} ${coefficient}${variable}${exponentDisplay}`,
                    raw: `${sign === '-' ? '-' : ''}${coefficient}${variable}${exponentDisplay}`,
                    group: `${variable}^${exponent}` // Group by variable and exponent
                });
            }
            
            // Create problem expression
            let expression = '';
            terms.forEach((term, index) => {
                if (index === 0) {
                    expression += term.display.replace(/^\+ /, ''); // Remove leading + if present
                } else {
                    expression += ' ' + term.display; // Add space before the term
                }
            });
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            
            // For level 2, the user needs to distinguish like and unlike terms
            problem.steps = ["Identify terms with the same variable and same exponent.", 
                           "These are like terms and can be combined.", 
                           "Terms with different variables or different exponents are unlike terms."];
            
            // Create simplified expression for level 2 (for answer checking)
            // We'll actually combine like terms here even though that's not the main focus of this level
            let simplifiedTerms = [];
            for (const [group, groupTerms] of Object.entries(likeTermGroups)) {
                let sumCoefficient = 0;
                groupTerms.forEach(term => {
                    sumCoefficient += term.coefficient;
                });
                
                if (sumCoefficient !== 0) {
                    // Get variable and exponent from the group
                    const parts = group.split('^');
                    const variable = parts[0];
                    const exponent = parts.length > 1 ? parts[1] : 1;
                    
                    // Create a new term with the combined coefficient
                    const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                    const sign = sumCoefficient < 0 ? '-' : '+';
                    const absCoef = Math.abs(sumCoefficient);
                    
                    simplifiedTerms.push({
                        coefficient: sumCoefficient,
                        variables: [{ name: variable, exponent: parseInt(exponent) }],
                        display: `${sign} ${absCoef}${variable}${exponentDisplay}`,
                        raw: `${sign === '-' ? '-' : ''}${absCoef}${variable}${exponentDisplay}`,
                        group: group
                    });
                }
            }
            
            // Sort the simplified terms
            simplifiedTerms.sort((a, b) => {
                return a.group.localeCompare(b.group);
            });
            
            // Create the simplified expression string
            let simplifiedExpression = '';
            simplifiedTerms.forEach((term, index) => {
                if (index === 0) {
                    simplifiedExpression += term.display.replace(/^\+ /, '');
                } else {
                    simplifiedExpression += ' ' + term.display;
                }
            });
            
            if (simplifiedExpression === '') {
                simplifiedExpression = '0';
            }
            
            problem.simplifiedExpression = simplifiedExpression;
            
            return problem;
        }

        // Generate Simple Combining problem (Level 3)
        function generateSimpleCombiningProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVariables = Math.min(difficulty + 1, 3); // 2 to 3 variables
            const variables = getRandomVariables(numVariables, false);
            
            // Generate expressions with like terms to combine
            let terms = [];
            let simplifiedTerms = [];
            
            // Generate like terms for each variable
            variables.forEach(variable => {
                // Generate 2-3 like terms for this variable
                const numTerms = Math.floor(Math.random() * 2) + 2; // 2 to 3 terms
                let totalCoefficient = 0;
                
                for (let i = 0; i < numTerms; i++) {
                    const coefficient = Math.floor(Math.random() * 9) + 1; // 1 to 9
                    const sign = Math.random() > 0.5 ? '+' : '-';
                    const actualCoefficient = sign === '-' ? -coefficient : coefficient;
                    
                    totalCoefficient += actualCoefficient;
                    
                    terms.push({
                        coefficient: actualCoefficient,
                        variables: [{ name: variable, exponent: 1 }],
                        display: `${i === 0 && terms.length === 0 ? (sign === '-' ? '-' : '') : sign} ${coefficient}${variable}`,
                        raw: `${sign === '-' ? '-' : ''}${coefficient}${variable}`,
                        group: variable // Group by variable
                    });
                }
                
                // Add simplified term to the solution
                if (totalCoefficient !== 0) {
                    simplifiedTerms.push({
                        coefficient: totalCoefficient,
                        variables: [{ name: variable, exponent: 1 }],
                        display: totalCoefficient < 0 ? `- ${Math.abs(totalCoefficient)}${variable}` : `+ ${totalCoefficient}${variable}`,
                        raw: `${totalCoefficient < 0 ? '-' : ''}${Math.abs(totalCoefficient)}${variable}`,
                        group: variable
                    });
                }
            });
            
            // Create problem expression
            let expression = '';
            terms.forEach((term, index) => {
                if (index === 0) {
                    expression += term.display.replace(/^\+ /, ''); // Remove leading + if present
                } else {
                    expression += ' ' + term.display; // Add space before the term
                }
            });
            
            // Create simplified expression
            let simplifiedExpression = '';
            simplifiedTerms.forEach((term, index) => {
                if (index === 0) {
                    simplifiedExpression += term.display.replace(/^\+ /, ''); // Remove leading + if present
                } else {
                    simplifiedExpression += ' ' + term.display; // Add space before the term
                }
            });
            
            // If simplified expression starts with "+", remove it
            simplifiedExpression = simplifiedExpression.replace(/^\+ /, '');
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = simplifiedExpression;
            
            // For level 3, the user needs to combine like terms
            problem.steps = [
                "Identify terms with the same variable.", 
                "Add or subtract the coefficients of like terms.", 
                "Write the result with the same variable."
            ];
            
            return problem;
        }

        // Generate Multi-Variable Terms problem (Level 4)
        function generateMultiVariableProblem(problem, difficulty) {
            // Choose base variables for the problem
            const baseVars = getRandomVariables(3, false); // Get 3 base variables
            
            // Create multi-variable combinations
            const variableCombinations = [
                { vars: [baseVars[0]], display: baseVars[0] },
                { vars: [baseVars[1]], display: baseVars[1] },
                { vars: [baseVars[0], baseVars[1]], display: `${baseVars[0]}${baseVars[1]}` },
            ];
            
            if (difficulty > 1) {
                variableCombinations.push(
                    { vars: [baseVars[2]], display: baseVars[2] },
                    { vars: [baseVars[0], baseVars[2]], display: `${baseVars[0]}${baseVars[2]}` }
                );
            }
            
            if (difficulty > 2) {
                variableCombinations.push(
                    { vars: [baseVars[1], baseVars[2]], display: `${baseVars[1]}${baseVars[2]}` },
                    { vars: [baseVars[0], baseVars[1], baseVars[2]], display: `${baseVars[0]}${baseVars[1]}${baseVars[2]}` }
                );
            }
            
            // Generate terms with the selected variable combinations
            let terms = [];
            let simplifiedTerms = {};
            
            // Generate 2-3 terms for each variable combination
            variableCombinations.forEach((combo, comboIndex) => {
                // For each combination, create 2-3 terms
                const numTerms = difficulty === 1 ? 2 : Math.floor(Math.random() * 2) + 2; // 2 to 3 terms
                let totalCoefficient = 0;
                
                for (let i = 0; i < numTerms; i++) {
                    const coefficient = Math.floor(Math.random() * 5) + 1; // 1 to 5 for simplicity
                    const sign = Math.random() > 0.5 ? '+' : '-';
                    const actualCoefficient = sign === '-' ? -coefficient : coefficient;
                    
                    totalCoefficient += actualCoefficient;
                    
                    terms.push({
                        coefficient: actualCoefficient,
                        variables: combo.vars.map(v => ({ name: v, exponent: 1 })),
                        display: `${terms.length === 0 ? (sign === '-' ? '-' : '') : sign} ${coefficient}${combo.display}`,
                        raw: `${sign === '-' ? '-' : ''}${coefficient}${combo.display}`,
                        group: combo.display // Group by variable combination
                    });
                }
                
                // Store the combined coefficient for the simplified expression
                if (totalCoefficient !== 0) {
                    simplifiedTerms[combo.display] = totalCoefficient;
                }
            });
            
            // Shuffle the terms for a more natural expression
            shuffleArray(terms);
            
            // Create problem expression
            let expression = '';
            terms.forEach((term, index) => {
                if (index === 0) {
                    expression += term.display.replace(/^\+ /, ''); // Remove leading + if present
                } else {
                    expression += ' ' + term.display; // Add space before the term
                }
            });
            
            // Create simplified expression
            let simplifiedExpressionTerms = [];
            for (const [varCombo, coef] of Object.entries(simplifiedTerms)) {
                if (coef < 0) {
                    simplifiedExpressionTerms.push(`- ${Math.abs(coef)}${varCombo}`);
                } else {
                    simplifiedExpressionTerms.push(`+ ${coef}${varCombo}`);
                }
            }
            
            // Sort terms for consistency
            simplifiedExpressionTerms.sort();
            
            let simplifiedExpression = simplifiedExpressionTerms.join(' ');
            // If simplified expression starts with '+', remove it
            simplifiedExpression = simplifiedExpression.replace(/^\+ /, '');
            // If empty, it's zero
            if (!simplifiedExpression) simplifiedExpression = '0';
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = simplifiedExpression;
            
            problem.steps = [
                "Identify terms with the same variables (like xy and xy).", 
                "Group like terms together.", 
                "Add or subtract the coefficients of like terms.",
                "Terms with different variables (like xy and xz) cannot be combined."
            ];
            
            return problem;
        }

        // Generate Terms with Exponents problem (Level 5)
        function generateExponentTermsProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVars = Math.min(difficulty + 1, 3); // 2 to 3 variables
            const variables = getRandomVariables(numVars, true); // Allow special variables
            
            // Generate terms with various exponents
            let terms = [];
            let simplifiedTerms = {};
            
            // For each variable, create terms with different exponents
            variables.forEach((variable, varIndex) => {
                // Choose 2-3 different exponents for this variable
                const exponents = [1, 2]; // Always include x and x²
                if (difficulty > 1) {
                    exponents.push(3); // Add x³ for medium/hard
                }
                if (difficulty > 2 && Math.random() > 0.5) {
                    exponents.push(4); // Occasionally add x⁴ for hard
                }
                
                // For each exponent, create 1-3 terms
                exponents.forEach(exponent => {
                    const numTerms = Math.floor(Math.random() * 2) + 1; // 1 to 2 terms
                    let totalCoefficient = 0;
                    
                    for (let i = 0; i < numTerms; i++) {
                        const coefficient = Math.floor(Math.random() * 5) + 1; // 1 to 5
                        const sign = Math.random() > 0.5 ? '+' : '-';
                        const actualCoefficient = sign === '-' ? -coefficient : coefficient;
                        
                        totalCoefficient += actualCoefficient;
                        
                        const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                        
                        terms.push({
                            coefficient: actualCoefficient,
                            variables: [{ name: variable, exponent: exponent }],
                            display: `${terms.length === 0 ? (sign === '-' ? '-' : '') : sign} ${coefficient}${variable}${exponentDisplay}`,
                            raw: `${sign === '-' ? '-' : ''}${coefficient}${variable}${exponentDisplay}`,
                            group: `${variable}^${exponent}` // Group by variable and exponent
                        });
                    }
                    
                    // Store the combined coefficient for the simplified expression
                    if (totalCoefficient !== 0) {
                        simplifiedTerms[`${variable}^${exponent}`] = {
                            coefficient: totalCoefficient,
                            variable: variable,
                            exponent: exponent
                        };
                    }
                });
            });
            
            // Shuffle the terms for a more natural expression
            shuffleArray(terms);
            
            // Create problem expression
            let expression = '';
            terms.forEach((term, index) => {
                if (index === 0) {
                    expression += term.display.replace(/^\+ /, ''); // Remove leading + if present
                } else {
                    expression += ' ' + term.display; // Add space before the term
                }
            });
            
            // Create simplified expression
            let simplifiedExpressionTerms = [];
            for (const [groupKey, termInfo] of Object.entries(simplifiedTerms)) {
                const { coefficient, variable, exponent } = termInfo;
                const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                
                if (coefficient < 0) {
                    simplifiedExpressionTerms.push(`- ${Math.abs(coefficient)}${variable}${exponentDisplay}`);
                } else {
                    simplifiedExpressionTerms.push(`+ ${coefficient}${variable}${exponentDisplay}`);
                }
            }
            
            // Sort terms by variable and exponent for consistency
            simplifiedExpressionTerms.sort();
            
            let simplifiedExpression = simplifiedExpressionTerms.join(' ');
            // If simplified expression starts with '+', remove it
            simplifiedExpression = simplifiedExpression.replace(/^\+ /, '');
            // If empty, it's zero
            if (!simplifiedExpression) simplifiedExpression = '0';
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = simplifiedExpression;
            
            problem.steps = [
                "Identify terms with the same variable AND same exponent.", 
                "Remember: x and x² are NOT like terms.", 
                "Group like terms together and combine their coefficients.",
                "Keep the variable and exponent unchanged when combining."
            ];
            
            return problem;
        }

        // Generate Distributive Property problem (Level 6)
        function generateDistributiveProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVars = Math.min(difficulty + 1, 3); // 2 to 3 variables
            const variables = getRandomVariables(numVars, false);
            
            // Create expression with parentheses
            let expression = '';
            let expandedTerms = [];
            let distribSteps = [];
            
            // Create 1-2 distributive expressions
            const numDistributive = difficulty > 1 ? 2 : 1;
            
            for (let d = 0; d < numDistributive; d++) {
                const outsideCoef = Math.floor(Math.random() * 5) + 1; // 1 to 5
                const outsideSign = Math.random() > 0.5 ? '+' : '-';
                const actualOutsideCoef = outsideSign === '-' ? -outsideCoef : outsideCoef;
                
                // Create terms inside parentheses
                const insideTerms = [];
                const numInsideTerms = difficulty + 1; // 2 to 4 terms
                
                for (let i = 0; i < numInsideTerms; i++) {
                    const variable = variables[Math.floor(Math.random() * variables.length)];
                    const coefficient = Math.floor(Math.random() * 5) + 1; // 1 to 5
                    const insideSign = Math.random() > 0.5 ? '+' : '-';
                    const actualInsideCoef = insideSign === '-' ? -coefficient : coefficient;
                    
                    // Occasionally add exponents for higher difficulties
                    let exponent = 1;
                    if (difficulty > 1 && Math.random() > 0.7) {
                        exponent = 2;
                    }
                    
                    const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                    
                    insideTerms.push({
                        coefficient: actualInsideCoef,
                        variable: variable,
                        exponent: exponent,
                        display: `${i === 0 ? (insideSign === '-' ? '-' : '') : insideSign} ${coefficient}${variable}${exponentDisplay}`
                    });
                    
                    // Calculate the distributed term
                    const distributedCoef = actualOutsideCoef * actualInsideCoef;
                    
                    // Add to expanded terms
                    expandedTerms.push({
                        coefficient: distributedCoef,
                        variables: [{ name: variable, exponent: exponent }],
                        display: distributedCoef < 0 ? `- ${Math.abs(distributedCoef)}${variable}${exponentDisplay}` : `+ ${distributedCoef}${variable}${exponentDisplay}`,
                        raw: `${distributedCoef < 0 ? '-' : ''}${Math.abs(distributedCoef)}${variable}${exponentDisplay}`,
                        group: `${variable}^${exponent}` // Group by variable and exponent
                    });
                }
                
                // Create the inner expression
                let innerExpression = '';
                insideTerms.forEach((term, idx) => {
                    innerExpression += idx === 0 ? term.display.replace(/^\+ /, '') : ' ' + term.display;
                });
                
                // Add to the overall expression
                if (d === 0) {
                    expression = `${outsideSign === '-' ? '-' : ''}${outsideCoef}(${innerExpression})`;
                } else {
                    expression += ` ${outsideSign} ${outsideCoef}(${innerExpression})`;
                }
                
                // Document distribution step
                distribSteps.push(`Distribute ${outsideCoef} to each term inside the parentheses: ${outsideCoef}(${innerExpression})`);
                
                let distributedStep = '';
                insideTerms.forEach((term, idx) => {
                    const distributedCoef = actualOutsideCoef * term.coefficient;
                    const exponentDisplay = term.exponent === 1 ? '' : `^${term.exponent}`;
                    
                    if (idx === 0) {
                        distributedStep += distributedCoef < 0 ? `- ${Math.abs(distributedCoef)}${term.variable}${exponentDisplay}` : `${distributedCoef}${term.variable}${exponentDisplay}`;
                    } else {
                        distributedStep += distributedCoef < 0 ? ` - ${Math.abs(distributedCoef)}${term.variable}${exponentDisplay}` : ` + ${distributedCoef}${term.variable}${exponentDisplay}`;
                    }
                });
                
                distribSteps.push(`= ${distributedStep}`);
            }
            
            // After distribution, further combine like terms
            const likeTermsMap = {};
            expandedTerms.forEach(term => {
                const group = term.group;
                if (!likeTermsMap[group]) {
                    likeTermsMap[group] = 0;
                }
                likeTermsMap[group] += term.coefficient;
            });
            
            // Create the simplified expression
            let simplifiedExpressionTerms = [];
            for (const [group, coef] of Object.entries(likeTermsMap)) {
                if (coef !== 0) {
                    // Extract variable and exponent from group
                    const varMatch = group.match(/([^~]+)~?(\d*)/);
                    const variable = varMatch[1];
                    const exponent = varMatch[2] || '1';
                    const exponentDisplay = exponent === '1' ? '' : `^${exponent}`;
                    
                    if (coef < 0) {
                        simplifiedExpressionTerms.push(`- ${Math.abs(coef)}${variable}${exponentDisplay}`);
                    } else {
                        simplifiedExpressionTerms.push(`+ ${coef}${variable}${exponentDisplay}`);
                    }
                }
            }
            
            // Sort terms for consistency
            simplifiedExpressionTerms.sort();
            
            let simplifiedExpression = simplifiedExpressionTerms.join(' ');
            // If simplified expression starts with '+', remove it
            simplifiedExpression = simplifiedExpression.replace(/^\+ /, '');
            // If empty, it's zero
            if (!simplifiedExpression) simplifiedExpression = '0';
            
            // Create terms from expanded expression
            let terms = [];
            let expandedExpression = '';
            
            expandedTerms.forEach((term, index) => {
                terms.push({
                    coefficient: term.coefficient,
                    variables: term.variables,
                    display: index === 0 ? term.display.replace(/^\+ /, '') : term.display,
                    raw: term.raw,
                    group: term.group
                });
                
                expandedExpression += index === 0 ? term.display.replace(/^\+ /, '') : ' ' + term.display;
            });
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.expandedExpression = expandedExpression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = simplifiedExpression;
            
            problem.steps = [
                "First, use the distributive property: a(b + c) = ab + ac", 
                ...distribSteps,
                "Then identify like terms in the expanded expression.", 
                "Combine like terms by adding their coefficients."
            ];
            
            return problem;
        }

        // Generate Mixed Expressions problem (Level 7)
        function generateMixedExpressionProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVars = Math.min(difficulty + 2, 4); // 3 to 4 variables
            const variables = getRandomVariables(numVars, true); // Allow special variables
            
            // Create a mixed expression with various types of terms
            let terms = [];
            
            // Add some single variable terms with different exponents
            variables.forEach(variable => {
                // Add terms with exponents 1 and 2 for each variable
                [1, 2].forEach(exponent => {
                    const numTerms = Math.floor(Math.random() * 2) + 1; // 1-2 terms
                    
                    for (let i = 0; i < numTerms; i++) {
                        const coefficient = Math.floor(Math.random() * 7) + 1; // 1-7
                        const sign = Math.random() > 0.5 ? '+' : '-';
                        const actualCoef = sign === '-' ? -coefficient : coefficient;
                        
                        const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                        
                        terms.push({
                            coefficient: actualCoef,
                            variables: [{ name: variable, exponent: exponent }],
                            display: `${sign} ${coefficient}${variable}${exponentDisplay}`,
                            raw: `${sign === '-' ? '-' : ''}${coefficient}${variable}${exponentDisplay}`,
                            group: `${variable}^${exponent}`
                        });
                    }
                });
            });
            
            // Add some multi-variable terms
            if (variables.length >= 2) {
                for (let i = 0; i < difficulty + 1; i++) {
                    // Create a multi-variable term
                    const var1 = variables[Math.floor(Math.random() * variables.length)];
                    let var2;
                    do {
                        var2 = variables[Math.floor(Math.random() * variables.length)];
                    } while (var2 === var1);
                    
                    const coefficient = Math.floor(Math.random() * 5) + 1; // 1-5
                    const sign = Math.random() > 0.5 ? '+' : '-';
                    const actualCoef = sign === '-' ? -coefficient : coefficient;
                    
                    terms.push({
                        coefficient: actualCoef,
                        variables: [
                            { name: var1, exponent: 1 },
                            { name: var2, exponent: 1 }
                        ],
                        display: `${sign} ${coefficient}${var1}${var2}`,
                        raw: `${sign === '-' ? '-' : ''}${coefficient}${var1}${var2}`,
                        group: `${var1}${var2}`
                    });
                }
            }
            
            // Add some constant terms
            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                const constant = Math.floor(Math.random() * 10) + 1; // 1-10
                const sign = Math.random() > 0.5 ? '+' : '-';
                const actualConstant = sign === '-' ? -constant : constant;
                
                terms.push({
                    coefficient: actualConstant,
                    variables: [],
                    display: `${sign} ${constant}`,
                    raw: `${sign === '-' ? '-' : ''}${constant}`,
                    group: 'constant'
                });
            }
            
            // Shuffle the terms
            shuffleArray(terms);
            
            // Fix the first term's display
            if (terms.length > 0) {
                const firstTerm = terms[0];
                if (firstTerm.coefficient > 0) {
                    firstTerm.display = firstTerm.display.replace(/^\+ /, '');
                }
            }
            
            // Create the expression
            let expression = terms.map(term => term.display).join(' ');
            
            // Group like terms and calculate the simplified expression
            const likeTermsMap = {};
            
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermsMap[group]) {
                    likeTermsMap[group] = 0;
                }
                likeTermsMap[group] += term.coefficient;
            });
            
            // Create the simplified expression
            let simplifiedExpressionTerms = [];
            for (const [group, coef] of Object.entries(likeTermsMap)) {
                if (coef === 0) continue; // Skip terms that sum to zero
                
                if (group === 'constant') {
                    // Handle constant terms
                    if (coef < 0) {
                        simplifiedExpressionTerms.push(`- ${Math.abs(coef)}`);
                    } else {
                        simplifiedExpressionTerms.push(`+ ${coef}`);
                    }
                } else {
                    // Handle variable terms
                    const hasExponent = group.includes('^');
                    let varPart;
                    
                    if (hasExponent) {
                        const parts = group.split('^');
                        const variable = parts[0];
                        const exponent = parts[1];
                        varPart = exponent === '1' ? variable : `${variable}^${exponent}`;
                    } else {
                        varPart = group;
                    }
                    
                    if (coef < 0) {
                        simplifiedExpressionTerms.push(`- ${Math.abs(coef)}${varPart}`);
                    } else {
                        simplifiedExpressionTerms.push(`+ ${coef}${varPart}`);
                    }
                }
            }
            
            // Sort terms for consistency (constants last)
            simplifiedExpressionTerms.sort((a, b) => {
                const aIsConstant = !a.match(/[a-zα-ωA-Z]/); // No variables
                const bIsConstant = !b.match(/[a-zα-ωA-Z]/); // No variables
                
                if (aIsConstant && !bIsConstant) return 1;
                if (!aIsConstant && bIsConstant) return -1;
                return a.localeCompare(b);
            });
            
            let simplifiedExpression = simplifiedExpressionTerms.join(' ');
            // If simplified expression starts with '+', remove it
            simplifiedExpression = simplifiedExpression.replace(/^\+ /, '');
            // If empty, it's zero
            if (!simplifiedExpression) simplifiedExpression = '0';
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = simplifiedExpression;
            
            problem.steps = [
                "Identify and highlight all different types of terms in the expression.", 
                "Group like terms together (same variables with same exponents).", 
                "Add or subtract the coefficients within each group.",
                "Write the final simplified expression with all the combined terms."
            ];
            
            return problem;
        }

        // Generate Expert Challenge problem (Level 8)
        function generateExpertChallengeProblem(problem, difficulty) {
            // Choose variables for the problem
            const numVars = Math.min(difficulty + 2, 5); // 3 to 5 variables
            const variables = getRandomVariables(numVars, true); // Allow special variables
            
            // Create a complex expression with distributive property and various terms
            let expression = '';
            let expandedTerms = [];
            
            // Part 1: Create a distributive expression
            const outsideCoef1 = Math.floor(Math.random() * 5) + 1; // 1 to 5
            const outsideSign1 = Math.random() > 0.5 ? '+' : '-';
            
            // Create terms inside first parentheses
            const insideTerms1 = [];
            const numInsideTerms1 = difficulty + 1; // 2 to 4 terms
            
            for (let i = 0; i < numInsideTerms1; i++) {
                const variable = variables[Math.floor(Math.random() * variables.length)];
                const coefficient = Math.floor(Math.random() * 3) + 1; // 1 to 3
                const insideSign = Math.random() > 0.5 ? '+' : '-';
                const actualInsideCoef = insideSign === '-' ? -coefficient : coefficient;
                
                let exponent = 1;
                if (difficulty > 1 && Math.random() > 0.7) {
                    exponent = 2;
                }
                
                const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                
                insideTerms1.push({
                    coefficient: actualInsideCoef,
                    variable: variable,
                    exponent: exponent,
                    display: `${i === 0 ? (insideSign === '-' ? '-' : '') : insideSign} ${coefficient}${variable}${exponentDisplay}`
                });
                
                // Calculate the distributed term
                const distributedCoef = outsideSign1 === '-' ? -outsideCoef1 * actualInsideCoef : outsideCoef1 * actualInsideCoef;
                
                // Add to expanded terms
                expandedTerms.push({
                    coefficient: distributedCoef,
                    variables: [{ name: variable, exponent: exponent }],
                    display: distributedCoef < 0 ? `- ${Math.abs(distributedCoef)}${variable}${exponentDisplay}` : `+ ${distributedCoef}${variable}${exponentDisplay}`,
                    raw: `${distributedCoef < 0 ? '-' : ''}${Math.abs(distributedCoef)}${variable}${exponentDisplay}`,
                    group: `${variable}^${exponent}`
                });
            }
            
            // Create the first inner expression
            let innerExpression1 = '';
            insideTerms1.forEach((term, idx) => {
                innerExpression1 += idx === 0 ? term.display.replace(/^\+ /, '') : ' ' + term.display;
            });
            
            // First part of the expression
            expression = `${outsideSign1 === '-' ? '-' : ''}${outsideCoef1}(${innerExpression1})`;
            
            // Part 2: Create another distributive expression or mixed terms
            if (difficulty > 1 && Math.random() > 0.4) {
                // Another distributive expression
                const outsideCoef2 = Math.floor(Math.random() * 5) + 1; // 1 to 5
                const outsideSign2 = Math.random() > 0.5 ? '+' : '-';
                
                // Create terms inside second parentheses
                const insideTerms2 = [];
                const numInsideTerms2 = difficulty; // 2 to 3 terms
                
                for (let i = 0; i < numInsideTerms2; i++) {
                    const variable = variables[Math.floor(Math.random() * variables.length)];
                    const coefficient = Math.floor(Math.random() * 3) + 1; // 1 to 3
                    const insideSign = Math.random() > 0.5 ? '+' : '-';
                    const actualInsideCoef = insideSign === '-' ? -coefficient : coefficient;
                    
                    let exponent = 1;
                    if (Math.random() > 0.7) {
                        exponent = 2;
                    }
                    
                    const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                    
                    insideTerms2.push({
                        coefficient: actualInsideCoef,
                        variable: variable,
                        exponent: exponent,
                        display: `${i === 0 ? (insideSign === '-' ? '-' : '') : insideSign} ${coefficient}${variable}${exponentDisplay}`
                    });
                    
                    // Calculate the distributed term
                    const distributedCoef = outsideSign2 === '-' ? -outsideCoef2 * actualInsideCoef : outsideCoef2 * actualInsideCoef;
                    
                    // Add to expanded terms
                    expandedTerms.push({
                        coefficient: distributedCoef,
                        variables: [{ name: variable, exponent: exponent }],
                        display: distributedCoef < 0 ? `- ${Math.abs(distributedCoef)}${variable}${exponentDisplay}` : `+ ${distributedCoef}${variable}${exponentDisplay}`,
                        raw: `${distributedCoef < 0 ? '-' : ''}${Math.abs(distributedCoef)}${variable}${exponentDisplay}`,
                        group: `${variable}^${exponent}`
                    });
                }
                
                // Create the second inner expression
                let innerExpression2 = '';
                insideTerms2.forEach((term, idx) => {
                    innerExpression2 += idx === 0 ? term.display.replace(/^\+ /, '') : ' ' + term.display;
                });
                
                // Add to the overall expression
                expression += ` ${outsideSign2} ${outsideCoef2}(${innerExpression2})`;
            } else {
                // Add some additional mixed terms
                const numAdditionalTerms = difficulty + 1; // 2 to 4 terms
                
                for (let i = 0; i < numAdditionalTerms; i++) {
                    const variable = variables[Math.floor(Math.random() * variables.length)];
                    const coefficient = Math.floor(Math.random() * 5) + 1; // 1 to 5
                    const sign = Math.random() > 0.5 ? '+' : '-';
                    const actualCoef = sign === '-' ? -coefficient : coefficient;
                    
                    let exponent = 1;
                    if (Math.random() > 0.6) {
                        exponent = Math.floor(Math.random() * 2) + 1; // 1 to 2
                    }
                    
                    const exponentDisplay = exponent === 1 ? '' : `^${exponent}`;
                    
                    // Add term to the expression
                    expression += ` ${sign} ${coefficient}${variable}${exponentDisplay}`;
                    
                    // Add to expanded terms
                    expandedTerms.push({
                        coefficient: actualCoef,
                        variables: [{ name: variable, exponent: exponent }],
                        display: `${sign} ${coefficient}${variable}${exponentDisplay}`,
                        raw: `${sign === '-' ? '-' : ''}${coefficient}${variable}${exponentDisplay}`,
                        group: `${variable}^${exponent}`
                    });
                }
            }
            
            // Create terms from expanded expression for display
            let terms = [];
            expandedTerms.forEach((term, index) => {
                terms.push({
                    coefficient: term.coefficient,
                    variables: term.variables,
                    display: index === 0 ? term.display.replace(/^\+ /, '') : term.display,
                    raw: term.raw,
                    group: term.group
                });
            });
            
            // Group like terms
            const likeTermGroups = {};
            terms.forEach(term => {
                const group = term.group;
                if (!likeTermGroups[group]) {
                    likeTermGroups[group] = [];
                }
                likeTermGroups[group].push(term);
            });
            
            // Calculate simplified expression
            const simplifiedTerms = {};
            terms.forEach(term => {
                const group = term.group;
                if (!simplifiedTerms[group]) {
                    simplifiedTerms[group] = 0;
                }
                simplifiedTerms[group] += term.coefficient;
            });
            
            // Create simplified expression
            let simplifiedExpressionTerms = [];
            for (const [group, coef] of Object.entries(simplifiedTerms)) {
                if (coef === 0) continue; // Skip terms that sum to zero
                
                // Parse the group to get variable and exponent
                const hasExponent = group.includes('^');
                let varPart;
                
                if (hasExponent) {
                    const parts = group.split('^');
                    const variable = parts[0];
                    const exponent = parts[1];
                    varPart = exponent === '1' ? variable : `${variable}^${exponent}`;
                } else {
                    varPart = group;
                }
                
                if (coef < 0) {
                    simplifiedExpressionTerms.push(`- ${Math.abs(coef)}${varPart}`);
                } else {
                    simplifiedExpressionTerms.push(`+ ${coef}${varPart}`);
                }
            }
            
            // Sort for consistency
            simplifiedExpressionTerms.sort();
            
            let simplifiedExpression = simplifiedExpressionTerms.join(' ');
            // If simplified expression starts with '+', remove it
            simplifiedExpression = simplifiedExpression.replace(/^\+ /, '');
            // If empty, it's zero
            if (!simplifiedExpression) simplifiedExpression = '0';
            
            // Set problem properties
            problem.expression = expression;
            problem.terms = terms;
            problem.likeTermGroups = Object.values(likeTermGroups);
            problem.simplifiedExpression = simplifiedExpression;
            
            problem.steps = [
                "First, apply the distributive property to expressions in parentheses.",
                "Expand all terms and rewrite the expression without parentheses.",
                "Identify like terms by looking for the same variables with the same exponents.",
                "Group and combine like terms by adding or subtracting their coefficients.",
                "Write the final simplified expression."
            ];
            
            return problem;
        }

        // Get random variables
        function getRandomVariables(count, allowSpecial) {
            const variables = [];
            
            // Use common variables for lower levels
            const availableVars = allowSpecial ? 
                [...commonVariables, ...specialVariables] : 
                commonVariables;
            
            // Select random variables
            while (variables.length < count && availableVars.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableVars.length);
                const variable = availableVars[randomIndex];
                
                // Only add if not already in the variables array
                if (!variables.includes(variable)) {
                    variables.push(variable);
                }
            }
            
            return variables;
        }

        // Shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Display the problem
        function displayProblem(problem) {
            const problemDisplay = document.getElementById('problem-display');
            problemDisplay.innerHTML = '';
            
            const instructions = document.createElement('p');
            instructions.textContent = "Identify and combine like terms in this expression:";
            instructions.style.marginBottom = '15px';
            instructions.style.fontSize = '18px';
            problemDisplay.appendChild(instructions);
            
            const expressionContainer = document.createElement('div');
            expressionContainer.style.fontSize = '28px';
            expressionContainer.style.fontWeight = 'bold';
            expressionContainer.style.margin = '20px 0';
            
            // Parse the expression and create clickable terms
            if (problem.level <= 2) {
                // For level 1-2, display the original expression with clickable terms
                createClickableTermsFromExpression(expressionContainer, problem.expression, problem.terms);
            } else {
                // For levels 3+, use the expanded expression if available
                if (problem.expandedExpression) {
                    createClickableTermsFromExpression(expressionContainer, problem.expandedExpression, problem.terms);
                } else {
                    createClickableTermsFromExpression(expressionContainer, problem.expression, problem.terms);
                }
            }
            
            problemDisplay.appendChild(expressionContainer);
            
            // Setup term click handlers
            setupTermClickHandlers();
        }

        // Create clickable terms from an expression
        function createClickableTermsFromExpression(container, expression, terms) {
            // For each term in the problem, create a clickable span
            terms.forEach((term, index) => {
                const termElement = document.createElement('span');
                termElement.className = 'term';
                termElement.dataset.index = index;
                termElement.dataset.term = JSON.stringify(term);
                
                // Format the term display with exponents
                let displayText = term.display;
                if (displayText.includes('^')) {
                    displayText = displayText.replace(/\^(\d+)/g, '<sup>$1</sup>');
                }
                
                // Remove leading + and spaces
                if (index === 0) {
                    displayText = displayText.replace(/^\+ /, '');
                }
                
                termElement.innerHTML = displayText;
                
                // Add drag functionality
                termElement.draggable = true;
                termElement.classList.add('terms-draggable');
                
                termElement.addEventListener('dragstart', function(event) {
                    event.dataTransfer.setData('text/plain', this.dataset.index);
                    this.classList.add('dragging');
                });
                
                termElement.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                });
                
                container.appendChild(termElement);
            });
            
            // Setup dropzone
            const dropzone = document.getElementById('combine-dropzone');
            
            dropzone.addEventListener('dragover', function(event) {
                event.preventDefault();
                this.classList.add('active');
            });
            
            dropzone.addEventListener('dragleave', function() {
                this.classList.remove('active');
            });
            
            dropzone.addEventListener('drop', function(event) {
                event.preventDefault();
                this.classList.remove('active');
                
                const termIndex = event.dataTransfer.getData('text/plain');
                const termElement = document.querySelector(`.term[data-index="${termIndex}"]`);
                
                if (termElement) {
                    const termData = JSON.parse(termElement.dataset.term);
                    
                    // Only add if not already in draggedTerms
                    if (!draggedTerms.some(t => t.raw === termData.raw)) {
                        draggedTerms.push(termData);
                        
                        // Create a clone of the term in the dropzone
                        const clonedTerm = termElement.cloneNode(true);
                        clonedTerm.classList.add('in-dropzone');
                        clonedTerm.draggable = false;
                        
                        // Add a remove button
                        const removeBtn = document.createElement('span');
                        removeBtn.innerHTML = ' ✕';
                        removeBtn.style.cursor = 'pointer';
                        removeBtn.style.color = 'red';
                        removeBtn.style.marginLeft = '5px';
                        
                        removeBtn.addEventListener('click', function() {
                            const removedTermRaw = termData.raw;
                            draggedTerms = draggedTerms.filter(t => t.raw !== removedTermRaw);
                            clonedTerm.remove();
                            
                            // Update instruction if no terms left
                            if (draggedTerms.length === 0 && dropzone.childNodes.length === 1) {
                                document.getElementById('dropzone-instruction').style.display = 'block';
                            }
                        });
                        
                        clonedTerm.appendChild(removeBtn);
                        
                        // Hide instruction if this is the first term
                        if (draggedTerms.length === 1) {
                            document.getElementById('dropzone-instruction').style.display = 'none';
                        }
                        
                        dropzone.appendChild(clonedTerm);
                    }
                }
            });
        }

        // Setup click handlers for terms
        function setupTermClickHandlers() {
            document.querySelectorAll('.term').forEach(term => {
                term.addEventListener('click', function() {
                    if (currentHighlightTool) {
                        const termIndex = this.dataset.index;
                        
                        if (currentHighlightTool === 'eraser') {
                            // Remove any highlight
                            this.className = 'term';
                            delete termHighlights[termIndex];
                        } else {
                            // Apply the selected highlight
                            // Remove any existing highlights first
                            this.className = 'term';
                            // Add the new highlight
                            this.classList.add(currentHighlightTool);
                            this.classList.add('highlighted');
                            
                            // Store the highlight for this term
                            termHighlights[termIndex] = currentHighlightTool;
                            
                            // Check if all highlight tools have been used (for achievement)
                            checkHighlightToolsAchievement();
                        }
                    }
                });
            });
        }

        // Check if all highlight tools have been used
        function checkHighlightToolsAchievement() {
            const highlightTypes = new Set(Object.values(termHighlights));
            
            // There are 8 different highlight types
            if (highlightTypes.size >= 8) {
                unlockAchievement('master_highlighter');
            }
        }

        // Clear all highlights
        function clearAllHighlights() {
            document.querySelectorAll('.term').forEach(term => {
                term.className = 'term';
            });
            
            termHighlights = {};
        }

        // Combine selected terms
        function combineSelectedTerms() {
            if (draggedTerms.length === 0) {
                showCharacterMessage('terry', "Drag some terms to the combining area first!");
                return;
            }
            
            // Check if all terms are like terms
            const firstTerm = draggedTerms[0];
            const allLikeTerms = draggedTerms.every(term => {
                if (!term.variables || !firstTerm.variables) return false;
                
                if (term.variables.length !== firstTerm.variables.length) return false;
                
                return term.group === firstTerm.group;
            });
            
            if (!allLikeTerms) {
                showCharacterMessage('professor', "These terms are not all like terms! Remember, like terms have the same variables with the same exponents.");
                document.getElementById('combine-result').textContent = "Cannot combine unlike terms!";
                document.getElementById('combine-result').style.color = "red";
                return;
            }
            
            // Calculate the combined coefficient
            let combinedCoef = 0;
            draggedTerms.forEach(term => {
                combinedCoef += term.coefficient;
            });
            
            // Create the result
            let resultText = "";
            
            if (firstTerm.variables && firstTerm.variables.length > 0) {
                // This is a variable term
                const varPart = firstTerm.group;
                
                if (combinedCoef === 0) {
                    resultText = "0";
                } else if (combinedCoef === 1) {
                    resultText = varPart;
                } else if (combinedCoef === -1) {
                    resultText = `-${varPart}`;
                } else {
                    resultText = `${combinedCoef}${varPart}`;
                }
            } else {
                // This is a constant term
                resultText = combinedCoef.toString();
            }
            
            // Format exponents in the result
            resultText = resultText.replace(/\^(\d+)/g, '<sup>$1</sup>');
            
            // Display the result
            document.getElementById('combine-result').innerHTML = resultText;
            document.getElementById('combine-result').style.color = "green";
            
            // Update the answer input field with this result
            // Check if the input is empty or has just been started
            const answerInput = document.getElementById('user-answer-input');
            const currentAnswer = answerInput.value.trim();
            
            // If this is the first term being added (no answer yet)
            if (currentAnswer === '') {
                answerInput.value = resultText.replace(/<sup>(\d+)<\/sup>/g, '^$1');
            } else {
                // Otherwise, add to the existing answer with a + or - sign
                const sign = combinedCoef < 0 ? '' : ' + '; // Negative sign is already in resultText
                answerInput.value = currentAnswer + sign + resultText.replace(/<sup>(\d+)<\/sup>/g, '^$1');
            }
            
            // Show encouraging message
            showCharacterMessage('terry', "Great job combining those like terms!");
        }

        // Reset combine area
        function resetCombineArea() {
            const dropzone = document.getElementById('combine-dropzone');
            
            // Clear all except the instruction
            while (dropzone.firstChild) {
                if (dropzone.firstChild.id === 'dropzone-instruction') {
                    dropzone.firstChild.style.display = 'block';
                    break;
                }
                dropzone.removeChild(dropzone.firstChild);
            }
            
            // Clear dragged terms array
            draggedTerms = [];
            
            // Clear result
            document.getElementById('combine-result').textContent = '';
        }

        // Update the Three.js visualization
        function updateVisualization() {
            // Clear existing objects
            objects.forEach(obj => {
                scene.remove(obj);
            });
            objects = [];
            
            if (!currentProblem) return;
            
            // Get color scheme based on theme
            let colors;
            if (colorTheme === 1) { // Vibrant
                colors = [0xff5733, 0x33ff57, 0x3357ff, 0xff33f5, 0xf5ff33, 0x33f5ff, 0xffb533, 0xa833ff];
            } else if (colorTheme === 2) { // Pastel
                colors = [0xffb6c1, 0xadd8e6, 0xb0e0e6, 0xdda0dd, 0xffdab9, 0xc1ffc1, 0xe6e6fa, 0xfffacd];
            } else { // Monochrome
                colors = [0x333333, 0x555555, 0x777777, 0x999999, 0xbbbbbb, 0xdddddd, 0xeeeeee, 0x111111];
            }
            
            // Create 3D visualization of the like term groups
            const likeTermGroups = currentProblem.likeTermGroups;
            
            likeTermGroups.forEach((group, groupIndex) => {
                const colorIndex = groupIndex % colors.length;
                const color = colors[colorIndex];
                
                // Create a color to match the highlight tools
                const highlightColors = {
                    'blue-square': 0x2196f3,
                    'orange-cloud': 0xff9800,
                    'purple-circle': 0x9c27b0,
                    'pink-star': 0xe91e63,
                    'teal-diamond': 0x009688,
                    'red-triangle': 0xf44336,
                    'green-pentagon': 0x4caf50,
                    'yellow-hexagon': 0xffeb3b
                };
                
                // Check if any terms in this group are highlighted
                let groupHighlightType = null;
                for (const [termIndex, highlightType] of Object.entries(termHighlights)) {
                    const term = currentProblem.terms[termIndex];
                    if (term && group.includes(term)) {
                        groupHighlightType = highlightType;
                        break;
                    }
                }
                
                // Create a group container
                const groupObject = new THREE.Group();
                
                // Create objects for each term in the group
                group.forEach((term, termIndex) => {
                    // Create geometry based on variables in term
                    let geometry;
                    let size = 0.4;
                    
                    if (groupHighlightType) {
                        // Match the shape to the highlight type
                        switch (groupHighlightType) {
                            case 'blue-square':
                                geometry = new THREE.BoxGeometry(size, size, size);
                                break;
                            case 'orange-cloud':
                                geometry = new THREE.DodecahedronGeometry(size, 0);
                                break;
                            case 'purple-circle':
                                geometry = new THREE.SphereGeometry(size, 32, 32);
                                break;
                            case 'pink-star':
                                geometry = new THREE.IcosahedronGeometry(size);
                                break;
                            case 'teal-diamond':
                                geometry = new THREE.OctahedronGeometry(size);
                                break;
                            case 'red-triangle':
                                geometry = new THREE.TetrahedronGeometry(size);
                                break;
                            case 'green-pentagon':
                                geometry = new THREE.DodecahedronGeometry(size, 0);
                                break;
                            case 'yellow-hexagon':
                                geometry = new THREE.DodecahedronGeometry(size, 0);
                                break;
                            default:
                                geometry = new THREE.SphereGeometry(size, 32, 32);
                        }
                    } else {
                        // Default shapes based on the term type
                        if (term.variables && term.variables.length === 0) {
                            // Constant - small cube
                            geometry = new THREE.BoxGeometry(size, size, size);
                        } else if (term.variables && term.variables.length === 1) {
                            // Single variable - sphere
                            const exponent = term.variables[0].exponent || 1;
                            if (exponent === 1) {
                                geometry = new THREE.SphereGeometry(size, 32, 32);
                            } else {
                                // Higher exponent - torus
                                geometry = new THREE.TorusGeometry(size, size / 3, 16, 32);
                            }
                        } else {
                            // Multiple variables - more complex shape
                            geometry = new THREE.IcosahedronGeometry(size);
                        }
                    }
                    
                    // Create material with color based on group index
                    const material = new THREE.MeshPhongMaterial({ 
                        color: groupHighlightType ? highlightColors[groupHighlightType] : color,
                        shininess: 100 
                    });
                    
                    // Create mesh
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Position the term within its group
                    const spacing = 0.6;
                    mesh.position.x = (termIndex - (group.length - 1) / 2) * spacing;
                    
                    // Add to group
                    groupObject.add(mesh);
                });
                
                // Position the group in the scene
                const groupSpacing = 2;
                groupObject.position.x = (groupIndex - (likeTermGroups.length - 1) / 2) * groupSpacing;
                
                // Add group to scene
                scene.add(groupObject);
                objects.push(groupObject);
            });

            // If there are no objects, add a default object
            if (objects.length === 0) {
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x4a6fa5, shininess: 100 });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                objects.push(mesh);
            }
        }

        // Show a hint for the current problem
        function showHint() {
            const hintPanel = document.getElementById('hint-panel');
            const hintContent = document.getElementById('hint-content');
            
            if (!currentProblem) return;
            
            // Generate hint based on the problem's level
            let hint = "";
            
            // Add the rule for this level
            const levelInfo = levels.find(level => level.id === currentProblem.levelId);
            hint += `<div class="exponent-rule">${levelInfo.rule}</div>`;
            
            // Add rule explanation
            hint += `<div class="rule-explanation">
                <h3>How to solve this problem:</h3>
                <ol class="rule-steps">`;
            
            // Show the steps from the problem
            for (let i = 0; i < currentProblem.steps.length; i++) {
                hint += `<li>${currentProblem.steps[i]}</li>`;
            }
            
            hint += `</ol></div>`;
            
            // Add example of like terms
            hint += `<div class="rule-explanation">
                <h3>Like Terms Examples:</h3>
                <p>Like terms have the same variables with the same exponents:</p>
                <ul>`;
            
            // Show examples from the problem
            const likeTermsExamples = [];
            currentProblem.likeTermGroups.forEach(group => {
                if (group.length >= 2) {
                    const terms = group.slice(0, 2).map(term => term.raw).join(' and ');
                    likeTermsExamples.push(`<li>${terms} are like terms</li>`);
                }
            });
            
            // If no good examples in the problem, show generic ones
            if (likeTermsExamples.length === 0) {
                hint += `
                    <li>3x and 5x are like terms</li>
                    <li>2y² and -7y² are like terms</li>
                    <li>4ab and 9ab are like terms</li>
                `;
            } else {
                hint += likeTermsExamples.join('');
            }
            
            hint += `</ul></div>`;
            
            // Add hint for highlighting
            hint += `<div class="rule-explanation">
                <h3>Using Highlight Tools:</h3>
                <p>Click on a highlight tool (like the blue square or orange cloud), then click on terms to highlight them.</p>
                <p>Use the same color for like terms to group them visually.</p>
                <p>Drag highlighted terms to the "Combine Like Terms" area to add them together.</p>
                <p>Once you've simplified the expression, type your answer in the answer box below.</p>
            </div>`;
            
            hintContent.innerHTML = hint;
            hintPanel.style.display = 'block';
            
            // Show character message about variable information
            const hintMessages = characterMessages.vicky.hint;
            if (hintMessages && hintMessages.length > 0) {
                const randomMessage = hintMessages[Math.floor(Math.random() * hintMessages.length)];
                showCharacterMessage('vicky', randomMessage);
            }
            
            // Deduct points for using hint (but ensure points don't go negative)
            const hintCost = 10;
            if (points >= hintCost) {
                points -= hintCost;
                document.getElementById('total-points').textContent = points;
                
                // Save updated points
                saveProgress();
            }
        }

        // Check the answer (called when Check Answer button is clicked)
        function checkAnswer() {
            checkUserAnswer();
        }

        // Check if highlighting is correct
        function checkHighlightingCorrectness() {
            const groupedByHighlight = {};
            
            // Group term indices by their highlight type
            for (const [termIndex, highlightType] of Object.entries(termHighlights)) {
                if (!groupedByHighlight[highlightType]) {
                    groupedByHighlight[highlightType] = [];
                }
                groupedByHighlight[highlightType].push(parseInt(termIndex));
            }
            
            // Check if each highlight group contains only like terms
            for (const [highlight, termIndices] of Object.entries(groupedByHighlight)) {
                if (termIndices.length <= 1) continue; // Skip single terms
                
                // Get the terms corresponding to these indices
                const terms = termIndices.map(index => currentProblem.terms[index]);
                
                // Check if all terms in this group have the same group property
                const firstGroup = terms[0].group;
                const allSameGroup = terms.every(term => term.group === firstGroup);
                
                if (!allSameGroup) {
                    return false; // Found unlike terms with the same highlight
                }
            }
            
            // Check if each like term group is consistently highlighted
            for (const group of currentProblem.likeTermGroups) {
                if (group.length <= 1) continue; // Skip singleton groups
                
                // Find the indices of these terms
                const termIndices = group.map(term => {
                    return currentProblem.terms.findIndex(t => t.raw === term.raw);
                });
                
                // Check if these terms have highlights
                const highlightTypes = termIndices.map(index => termHighlights[index]).filter(h => h);
                
                if (highlightTypes.length < 2) {
                    continue; // Not enough highlighted terms to check
                }
                
                // Check if all highlighted terms have the same highlight
                const firstHighlight = highlightTypes[0];
                const allSameHighlight = highlightTypes.every(h => h === firstHighlight);
                
                if (!allSameHighlight) {
                    return false; // Like terms with different highlights
                }
            }
            
            // For beginner levels, consider it correct if at least a few terms are properly highlighted
            const totalHighlightedTerms = Object.keys(termHighlights).length;
            return totalHighlightedTerms >= Math.min(currentProblem.terms.length / 2, 4);
        }

        // Check if combining is correct
        function checkCombiningCorrectness() {
            // For this implementation, we'll check if at least some combining has been done correctly
            // and if the user has identified at least some of the like terms
            
            // If no terms have been dragged, it's not correct
            if (draggedTerms.length === 0) {
                return false;
            }
            
            // Check if dragged terms are all like terms
            const firstTerm = draggedTerms[0];
            const allLikeTerms = draggedTerms.every(term => {
                if (!term.variables || !firstTerm.variables) return false;
                
                if (term.variables.length !== firstTerm.variables.length) return false;
                
                return term.group === firstTerm.group;
            });
            
            if (!allLikeTerms) {
                return false;
            }
            
            // Check if at least 2 like terms have been dragged
            if (draggedTerms.length >= 2) {
                return true;
            }
            
            // Check if highlighting has been done correctly (as a fallback)
            return checkHighlightingCorrectness();
        }

        // Check if a level has been mastered
        function checkLevelMastery(levelId) {
            // Get level stats
            const stats = levelStats[levelId];
            const level = levels.find(l => l.id === levelId);
            
            // Check if mastery criteria is met
            if (stats.correct >= level.masteryRequirement && !masteredLevels.includes(levelId)) {
                // Add to mastered levels
                masteredLevels.push(levelId);
                
                // Save mastered levels
                localStorage.setItem('mastered_levels', JSON.stringify(masteredLevels));
                
                // Update mastery count
                updateMasteryCount();
                
                // Show mastery modal
                showMasteryModal(levelId);
                
                // Update level buttons to show mastery badge
                createLevelButtons();
                
                // Check for mastery achievements
                checkAchievements();
            }
        }

        // Show mastery modal
        function showMasteryModal(levelId) {
            const level = levels.find(l => l.id === levelId);
            const modal = document.getElementById('mastery-modal');
            const content = document.getElementById('mastery-content');
            
            content.innerHTML = `
                <div style="text-align: center;">
                    <h3 style="color: ${level.color}; margin: 15px 0;">Level ${level.id}: ${level.name}</h3>
                    <div style="font-size: 50px; margin: 20px 0;">🌟</div>
                    <p>Congratulations! You've mastered this level by correctly solving ${level.masteryRequirement} problems!</p>
                    <p>Keep practicing to master all levels and become an Algebra Expert!</p>
                    <button class="btn" style="background-color: ${level.color}; color: ${level.textColor}; margin-top: 20px;" id="continue-mastery-btn">Continue Learning</button>
                </div>
            `;
            
            modal.style.display = 'block';
            
            // Add event listener to continue button
            document.getElementById('continue-mastery-btn').addEventListener('click', hideMasteryModal);
            
            // Show character congratulations
            showCharacterMessage('professor', `Amazing work! You've mastered Level ${levelId}: ${level.name}!`);
        }

        // Hide mastery modal
        function hideMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'none';
        }

        // Update mastery count
        function updateMasteryCount() {
            document.getElementById('mastery-count').textContent = masteredLevels.length;
        }

        // Show celebration animation
        function showCelebration() {
            const celebration = document.getElementById('celebration');
            celebration.innerHTML = '';
            celebration.style.display = 'block';
            
            // Create confetti
            const colors = ['#ff5733', '#33ff57', '#3357ff', '#ff33f5', '#f5ff33'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = Math.random() * 10 + 5 + 'px';
                confetti.style.height = Math.random() * 10 + 5 + 'px';
                confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
                
                // Random shapes
                const shapes = ['50%', '0']; // Circle or square
                confetti.style.borderRadius = shapes[Math.floor(Math.random() * shapes.length)];
                
                celebration.appendChild(confetti);
            }
            
            // Hide celebration after animation completes
            setTimeout(() => {
                celebration.style.display = 'none';
            }, 5000);
        }

        // Show streak indicator
        function showStreakIndicator() {
            const indicator = document.getElementById('streak-indicator');
            indicator.textContent = `Streak: ${streak}`;
            indicator.style.opacity = 1;
            
            // Add animation class
            indicator.classList.add('pulse');
            
            // Remove animation class after it completes
            setTimeout(() => {
                indicator.classList.remove('pulse');
            }, 500);
            
            // Hide indicator after a few seconds
            setTimeout(() => {
                indicator.style.opacity = 0;
            }, 3000);
        }

        // Check if any achievements have been earned
        function checkAchievements() {
            achievementsList.forEach(achievement => {
                // Skip already unlocked achievements
                if (achievements[achievement.id] && achievements[achievement.id].unlocked) {
                    return;
                }
                
                // Check achievement condition
                if (achievement.condition()) {
                    unlockAchievement(achievement.id);
                }
            });
            
            // Save achievements to localStorage
            localStorage.setItem('achievements', JSON.stringify(achievements));
        }

        // Unlock an achievement
        function unlockAchievement(achievementId) {
            // Find the achievement
            const achievement = achievementsList.find(a => a.id === achievementId);
            
            if (!achievement) return;
            
            // Update achievements object
            achievements[achievementId] = {
                unlocked: true,
                date: new Date().toISOString()
            };
            
            // Update UI
            const achievementElement = document.getElementById(`achievement-${achievementId}`);
            if (achievementElement) {
                achievementElement.classList.add('unlocked');
                
                // Add bounce animation
                achievementElement.classList.add('bounce');
                setTimeout(() => {
                    achievementElement.classList.remove('bounce');
                }, 1000);
            }
            
            // Show character message
            showCharacterMessage('vicky', `Congratulations! You earned the "${achievement.name}" achievement!`);
        }

        // Create achievements display
        function createAchievements() {
            const achievementsGrid = document.getElementById('achievements-grid');
            achievementsGrid.innerHTML = '';
            
            // Load achievements from localStorage
            const savedAchievements = localStorage.getItem('achievements');
            achievements = savedAchievements ? JSON.parse(savedAchievements) : {};
            
            achievementsList.forEach(achievement => {
                const achievementElement = document.createElement('div');
                achievementElement.className = 'achievement';
                achievementElement.id = `achievement-${achievement.id}`;
                
                if (achievements[achievement.id] && achievements[achievement.id].unlocked) {
                    achievementElement.classList.add('unlocked');
                }
                
                achievementElement.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-name">${achievement.name}</div>
                `;
                
                // Add tooltip with description
                achievementElement.title = achievement.description;
                
                achievementsGrid.appendChild(achievementElement);
            });
        }

        // Update the progress bar
        function updateProgress() {
            const progressBar = document.getElementById('progress-bar');
            const percentage = score.total > 0 ? (score.correct / score.total) * 100 : 0;
            progressBar.style.width = `${percentage}%`;
        }

        // Show a random character message
        function showRandomCharacterMessage() {
            const characters = ['professor', 'vicky', 'terry'];
            const character = characters[Math.floor(Math.random() * characters.length)];
            
            // Only show message if help level is medium or maximum
            if (helpLevel >= 2) {
                showCharacterMessage(character);
            }
        }

        // Show a message from a character
        function showCharacterMessage(character, customMessage = null) {
            let message = customMessage;
            
            if (!message) {
                // Get level-specific messages if available
                const levelSpecificMessages = characterMessages[character][`level${currentLevel}`];
                const genericMessages = characterMessages[character].generic;
                
                const messages = levelSpecificMessages && levelSpecificMessages.length > 0 ? 
                    levelSpecificMessages : genericMessages;
                
                message = messages[Math.floor(Math.random() * messages.length)];
            }
            
            let speechBubble;
            if (character === 'professor') {
                speechBubble = document.getElementById('professor-speech');
            } else if (character === 'vicky') {
                speechBubble = document.getElementById('vicky-speech');
            } else {
                speechBubble = document.getElementById('terry-speech');
            }
            
            speechBubble.textContent = message;
            speechBubble.style.opacity = 1;
            
            setTimeout(() => {
                speechBubble.style.opacity = 0;
            }, 5000);
        }

        // Show the character modal
        function showCharactersModal() {
            document.getElementById('characters-modal').style.display = 'block';
        }

        // Hide the character modal
        function hideCharactersModal() {
            document.getElementById('characters-modal').style.display = 'none';
        }

        // Show the rules modal
        function showRulesModal() {
            document.getElementById('rules-modal').style.display = 'block';
        }

        // Hide the rules modal
        function hideRulesModal() {
            document.getElementById('rules-modal').style.display = 'none';
        }

        // Hide level up modal
        function hideLevelUpModal() {
            document.getElementById('level-up-modal').style.display = 'none';
        }

        // Clear the problem display
        function clearProblemDisplay() {
            document.getElementById('problem-display').innerHTML = 'Loading new problem...';
            document.getElementById('combine-result').textContent = '';
        }

        // Get level stats from localStorage
        function getLevelStats(levelId) {
            const statsString = localStorage.getItem(`level_${levelId}_stats`);
            if (statsString) {
                return JSON.parse(statsString);
            } else {
                return { correct: 0, total: 0, points: 0 };
            }
        }

        // Save level stats to localStorage
        function saveLevelStats(levelId, stats) {
            localStorage.setItem(`level_${levelId}_stats`, JSON.stringify(stats));
        }

        // Save progress to localStorage
        function saveProgress() {
            localStorage.setItem('score', JSON.stringify(score));
            localStorage.setItem('points', points);
            localStorage.setItem('streak', streak);
            localStorage.setItem('highest_streak', highestStreak);
            localStorage.setItem('current_level', currentLevel);
            localStorage.setItem('mastered_levels', JSON.stringify(masteredLevels));
        }

        // Load progress from localStorage
        function loadProgress() {
            // Load score
            const savedScore = localStorage.getItem('score');
            if (savedScore) {
                score = JSON.parse(savedScore);
                document.getElementById('correct-count').textContent = score.correct;
                document.getElementById('total-count').textContent = score.total;
            }
            
            // Load points
            const savedPoints = localStorage.getItem('points');
            if (savedPoints) {
                points = parseInt(savedPoints);
                document.getElementById('total-points').textContent = points;
            }
            
            // Load streak info
            const savedStreak = localStorage.getItem('streak');
            if (savedStreak) {
                streak = parseInt(savedStreak);
                document.getElementById('current-streak').textContent = streak;
            }
            
            const savedHighestStreak = localStorage.getItem('highest_streak');
            if (savedHighestStreak) {
                highestStreak = parseInt(savedHighestStreak);
                document.getElementById('highest-streak').textContent = highestStreak;
            }
            
            // Load current level
            const savedLevel = localStorage.getItem('current_level');
            if (savedLevel) {
                currentLevel = parseInt(savedLevel);
                document.getElementById('current-level').textContent = currentLevel;
            }
            
            // Load mastered levels
            const savedMasteredLevels = localStorage.getItem('mastered_levels');
            if (savedMasteredLevels) {
                masteredLevels = JSON.parse(savedMasteredLevels);
            }
            
            // Update progress bar
            updateProgress();
        }

        // Reset game progress (for testing)
        function resetProgress() {
            // Clear all localStorage items
            localStorage.removeItem('score');
            localStorage.removeItem('points');
            localStorage.removeItem('streak');
            localStorage.removeItem('highest_streak');
            localStorage.removeItem('current_level');
            localStorage.removeItem('mastered_levels');
            localStorage.removeItem('achievements');
            
            // Clear level stats
            for (let i = 1; i <= levels.length; i++) {
                localStorage.removeItem(`level_${i}_stats`);
            }
            
            // Reload the page
            window.location.reload();
        }
    </script>
</body>
</html>