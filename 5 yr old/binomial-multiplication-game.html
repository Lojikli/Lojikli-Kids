<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binomial Garden Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #e8f5e9;
            overflow-x: hidden;
        }
        
        #game-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .header {
            text-align: center;
            color: #2e7d32;
            margin-bottom: 20px;
        }
        
        .game-section {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .character {
            display: inline-block;
            width: 23%;
            text-align: center;
            vertical-align: top;
            margin: 0 1%;
        }
        
        .character-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            border-radius: 50%;
        }
        
        .settings-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .setting-group {
            flex: 1;
            min-width: 200px;
            background-color: #f1f8e9;
            padding: 15px;
            border-radius: 10px;
        }
        
        button {
            background-color: #4caf50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #388e3c;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        select, input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #aaa;
            font-size: 14px;
            margin-top: 5px;
            width: 100%;
        }
        
        .canvas-container {
            margin: 20px auto;
            display: flex;
            justify-content: center;
        }
        
        .quiz-container {
            background-color: #f9fbe7;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .quiz-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .quiz-option {
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.3s;
        }
        
        .quiz-option:hover {
            background-color: #c8e6c9;
        }
        
        .feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        
        .correct {
            background-color: #dff2bf;
            color: #4f8a10;
        }
        
        .incorrect {
            background-color: #ffbaba;
            color: #d8000c;
        }
        
        .explanation-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #e1f5fe;
            border-radius: 10px;
            display: none;
        }
        
        #advanced-explanation {
            font-size: 14px;
            line-height: 1.5;
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }
        
        .step {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #ddd;
            margin: 0 5px;
        }
        
        .step.active {
            background-color: #4caf50;
        }
        
        .character-speech {
            background-color: white;
            border: 2px solid #aaa;
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            position: relative;
            display: none;
        }
        
        .character-speech:before {
            content: "";
            position: absolute;
            top: -10px;
            left: 20px;
            border-width: 0 10px 10px;
            border-style: solid;
            border-color: #aaa transparent;
        }
        
        .character-speech:after {
            content: "";
            position: absolute;
            top: -7px;
            left: 22px;
            border-width: 0 8px 8px;
            border-style: solid;
            border-color: white transparent;
        }
        
        #help-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="header">
            <h1>The Binomial Garden Adventure</h1>
            <p>Explore the magic of multiplying binomials with our garden friends!</p>
        </div>
        
        <div class="game-section">
            <h2>Meet Your Garden Helpers</h2>
            <div class="characters-container">
                <div class="character">
                    <div class="character-icon" style="background-color: #ffcdd2;">
                        <svg viewBox="0 0 100 100" width="80" height="80">
                            <!-- Frankie First (Butterfly) -->
                            <circle cx="50" cy="50" r="20" fill="#ef9a9a"/>
                            <ellipse cx="30" cy="40" rx="20" ry="15" fill="#ffcdd2" transform="rotate(-20, 30, 40)"/>
                            <ellipse cx="70" cy="40" rx="20" ry="15" fill="#ffcdd2" transform="rotate(20, 70, 40)"/>
                            <path d="M50 60 L45 70 L55 70 Z" fill="#ef9a9a"/>
                            <circle cx="45" cy="45" r="3" fill="black"/>
                            <circle cx="55" cy="45" r="3" fill="black"/>
                            <path d="M45 55 Q50 60 55 55" fill="none" stroke="black" stroke-width="2"/>
                        </svg>
                    </div>
                    <h3>Frankie First</h3>
                    <p>Helps with the <strong>First</strong> terms</p>
                </div>
                <div class="character">
                    <div class="character-icon" style="background-color: #fff9c4;">
                        <svg viewBox="0 0 100 100" width="80" height="80">
                            <!-- Ollie Outer (Bee) -->
                            <ellipse cx="50" cy="50" rx="20" ry="15" fill="#ffeb3b"/>
                            <ellipse cx="50" cy="60" rx="15" ry="15" fill="#ffeb3b"/>
                            <rect x="45" y="38" width="10" height="28" fill="black"/>
                            <rect x="39" y="42" width="22" height="4" fill="black"/>
                            <rect x="39" y="52" width="22" height="4" fill="black"/>
                            <circle cx="70" cy="45" r="10" fill="#fff9c4" stroke="black" stroke-width="1"/>
                            <circle cx="30" cy="45" r="10" fill="#fff9c4" stroke="black" stroke-width="1"/>
                            <circle cx="40" cy="35" r="3" fill="black"/>
                            <circle cx="60" cy="35" r="3" fill="black"/>
                            <path d="M45 45 Q50 48 55 45" fill="none" stroke="black" stroke-width="2"/>
                        </svg>
                    </div>
                    <h3>Ollie Outer</h3>
                    <p>Works with the <strong>Outer</strong> terms</p>
                </div>
                <div class="character">
                    <div class="character-icon" style="background-color: #c8e6c9;">
                        <svg viewBox="0 0 100 100" width="80" height="80">
                            <!-- Izzy Inner (Ant) -->
                            <ellipse cx="50" cy="40" rx="10" ry="8" fill="#4caf50"/>
                            <ellipse cx="50" cy="55" rx="15" ry="12" fill="#4caf50"/>
                            <ellipse cx="50" cy="73" rx="12" ry="10" fill="#4caf50"/>
                            <line x1="30" y1="40" x2="20" y2="25" stroke="#4caf50" stroke-width="2"/>
                            <line x1="70" y1="40" x2="80" y2="25" stroke="#4caf50" stroke-width="2"/>
                            <line x1="30" y1="45" x2="15" y2="45" stroke="#4caf50" stroke-width="2"/>
                            <line x1="70" y1="45" x2="85" y2="45" stroke="#4caf50" stroke-width="2"/>
                            <line x1="30" y1="50" x2="20" y2="65" stroke="#4caf50" stroke-width="2"/>
                            <line x1="70" y1="50" x2="80" y2="65" stroke="#4caf50" stroke-width="2"/>
                            <circle cx="45" cy="38" r="2" fill="black"/>
                            <circle cx="55" cy="38" r="2" fill="black"/>
                            <path d="M48 42 Q50 44 52 42" fill="none" stroke="black" stroke-width="1"/>
                        </svg>
                    </div>
                    <h3>Izzy Inner</h3>
                    <p>Takes care of the <strong>Inner</strong> terms</p>
                </div>
                <div class="character">
                    <div class="character-icon" style="background-color: #bbdefb;">
                        <svg viewBox="0 0 100 100" width="80" height="80">
                            <!-- Lenny Last (Ladybug) -->
                            <circle cx="50" cy="50" r="25" fill="#e53935"/>
                            <path d="M50 25 C 30 30, 30 70, 50 75" fill="black"/>
                            <circle cx="40" cy="40" r="5" fill="black"/>
                            <circle cx="60" cy="40" r="5" fill="black"/>
                            <circle cx="35" cy="55" r="5" fill="black"/>
                            <circle cx="50" cy="60" r="5" fill="black"/>
                            <circle cx="65" cy="55" r="5" fill="black"/>
                            <circle cx="45" cy="35" r="2" fill="white"/>
                            <circle cx="65" cy="35" r="2" fill="white"/>
                            <path d="M45 70 Q50 75 55 70" fill="none" stroke="black" stroke-width="2"/>
                        </svg>
                    </div>
                    <h3>Lenny Last</h3>
                    <p>Completes with the <strong>Last</strong> terms</p>
                </div>
            </div>
        </div>
        
        <div class="game-section">
            <h2>Garden Settings</h2>
            <div class="settings-panel">
                <div class="setting-group">
                    <h3>Garden Difficulty</h3>
                    <label for="difficulty">Choose your level:</label>
                    <select id="difficulty">
                        <option value="1">Level 1: Simple Numbers</option>
                        <option value="2">Level 2: Mixed Numbers</option>
                        <option value="3">Level 3: Negative Numbers</option>
                        <option value="4">Level 4: Variables (x,y)</option>
                        <option value="5">Level 5: Mixed Variables</option>
                    </select>
                </div>
                
                <div class="setting-group">
                    <h3>Animation Speed</h3>
                    <label for="speed">Adjust speed:</label>
                    <input type="range" id="speed" min="1" max="5" value="3">
                    <div style="display: flex; justify-content: space-between;">
                        <span>Slower</span>
                        <span>Faster</span>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3>Explanation Level</h3>
                    <label for="explanation">How detailed:</label>
                    <select id="explanation">
                        <option value="basic">Simple (Age 5-6)</option>
                        <option value="medium">Medium (Age 7-9)</option>
                        <option value="advanced">Advanced (Age 10+)</option>
                        <option value="expert">Expert (PhD Level Simplified)</option>
                    </select>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px;">
                <button id="start-button">Start Garden Adventure</button>
                <button id="help-button">How To Play</button>
            </div>
        </div>
        
        <div class="game-section">
            <h2>Binomial Garden</h2>
            <div class="step-indicator">
                <div class="step active" data-step="intro"></div>
                <div class="step" data-step="first"></div>
                <div class="step" data-step="outer"></div>
                <div class="step" data-step="inner"></div>
                <div class="step" data-step="last"></div>
                <div class="step" data-step="result"></div>
            </div>
            
            <div id="current-problem">
                <h3>Current Binomial Multiplication:</h3>
                <p id="problem-display" style="font-size: 24px; text-align: center;">Let's start our garden adventure!</p>
            </div>
            
            <div id="character-message" class="character-speech">
                Welcome to the Binomial Garden! I'll guide you through multiplying these special plant boxes!
            </div>
            
            <div class="canvas-container">
                <div id="garden-canvas"></div>
            </div>
            
            <div style="text-align: center; margin-top: 10px;">
                <button id="prev-step" disabled>Previous Step</button>
                <button id="next-step">Next Step</button>
                <button id="show-explanation">Show Explanation</button>
                <button id="new-problem">New Problem</button>
            </div>
            
            <div id="explanation-box" class="explanation-panel">
                <h3>Understanding Binomial Multiplication</h3>
                <div id="basic-explanation"></div>
                <div id="advanced-explanation"></div>
            </div>
        </div>
        
        <div id="quiz-section" class="game-section" style="display: none;">
            <h2>Garden Quiz</h2>
            <div class="quiz-container">
                <h3 id="quiz-question">Question goes here</h3>
                <div class="quiz-options" id="quiz-options">
                    <!-- Options will be inserted here -->
                </div>
                <div id="quiz-feedback" class="feedback"></div>
                <div style="text-align: center; margin-top: 15px;">
                    <button id="check-answer" style="display: none;">Check Answer</button>
                    <button id="next-question" style="display: none;">Next Question</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="overlay"></div>
    <div id="help-panel">
        <h2>How to Play Binomial Garden Adventure</h2>
        <p>Welcome to a magical garden where you'll learn to multiply binomials using the FOIL method!</p>
        
        <h3>What is a Binomial?</h3>
        <p>A binomial is like a special plant box with two different plants in it. For example: (3 + x) or (2a - 5)</p>
        
        <h3>What is FOIL?</h3>
        <p>FOIL is a fun way to remember how to multiply binomials:</p>
        <ul>
            <li><strong>F</strong>irst: Multiply the first terms in each binomial</li>
            <li><strong>O</strong>uter: Multiply the outer terms</li>
            <li><strong>I</strong>nner: Multiply the inner terms</li>
            <li><strong>L</strong>ast: Multiply the last terms</li>
        </ul>
        
        <h3>How to Play:</h3>
        <ol>
            <li>Choose your settings in the Garden Settings panel</li>
            <li>Click "Start Garden Adventure"</li>
            <li>Follow along with your garden friends as they show you each step</li>
            <li>Use the "Next Step" and "Previous Step" buttons to navigate</li>
            <li>Take the quiz to test your knowledge!</li>
        </ol>
        
        <p>Remember, our garden friends are here to help you understand this math concept in a fun way!</p>
        
        <div style="text-align: center; margin-top: 15px;">
            <button id="close-help">Got it!</button>
        </div>
    </div>

    <script>
        // Main game variables
        let currentStep = 0;
        let currentProblem = {};
        let quizQuestions = [];
        let currentQuizIndex = 0;
        let selectedOption = null;
        let quizActive = false;
        let sketch = null;
        
        // Game settings and state
        const gameState = {
            difficulty: 1,
            speed: 3,
            explanationLevel: "basic",
            currentStep: 0,
            steps: ["intro", "first", "outer", "inner", "last", "result"],
            firstTerm: 0,
            outerTerm: 0,
            innerTerm: 0,
            lastTerm: 0,
            result: "",
            simplified: "",
            foilElements: []
        };
        
        // DOM elements
        const difficultySelect = document.getElementById("difficulty");
        const speedSlider = document.getElementById("speed");
        const explanationSelect = document.getElementById("explanation");
        const startButton = document.getElementById("start-button");
        const helpButton = document.getElementById("help-button");
        const closeHelpButton = document.getElementById("close-help");
        const prevStepButton = document.getElementById("prev-step");
        const nextStepButton = document.getElementById("next-step");
        const showExplanationButton = document.getElementById("show-explanation");
        const newProblemButton = document.getElementById("new-problem");
        const problemDisplay = document.getElementById("problem-display");
        const characterMessage = document.getElementById("character-message");
        const explanationBox = document.getElementById("explanation-box");
        const basicExplanation = document.getElementById("basic-explanation");
        const advancedExplanation = document.getElementById("advanced-explanation");
        const quizSection = document.getElementById("quiz-section");
        const quizQuestion = document.getElementById("quiz-question");
        const quizOptions = document.getElementById("quiz-options");
        const quizFeedback = document.getElementById("quiz-feedback");
        const checkAnswerButton = document.getElementById("check-answer");
        const nextQuestionButton = document.getElementById("next-question");
        const overlay = document.getElementById("overlay");
        const helpPanel = document.getElementById("help-panel");
        
        // Event listeners
        startButton.addEventListener("click", startGame);
        helpButton.addEventListener("click", showHelp);
        closeHelpButton.addEventListener("click", hideHelp);
        prevStepButton.addEventListener("click", previousStep);
        nextStepButton.addEventListener("click", nextStep);
        showExplanationButton.addEventListener("click", toggleExplanation);
        newProblemButton.addEventListener("click", generateNewProblem);
        checkAnswerButton.addEventListener("click", checkAnswer);
        nextQuestionButton.addEventListener("click", nextQuizQuestion);
        
        difficultySelect.addEventListener("change", () => {
            gameState.difficulty = parseInt(difficultySelect.value);
        });
        
        speedSlider.addEventListener("input", () => {
            gameState.speed = parseInt(speedSlider.value);
        });
        
        explanationSelect.addEventListener("change", () => {
            gameState.explanationLevel = explanationSelect.value;
            updateExplanation();
        });
        
        // Initialize the game
        function initGame() {
            gameState.difficulty = parseInt(difficultySelect.value);
            gameState.speed = parseInt(speedSlider.value);
            gameState.explanationLevel = explanationSelect.value;
            
            // Setup the p5.js sketch
            setupSketch();
        }
        
        // Setup p5.js canvas
        function setupSketch() {
            // Remove any existing sketch
            if (sketch) {
                sketch.remove();
            }
            
            // Create new p5.js sketch
            sketch = new p5((p) => {
                const width = 600;
                const height = 400;
                let animations = [];
                let characters = {};
                
                p.setup = function() {
                    const canvas = p.createCanvas(width, height);
                    canvas.parent('garden-canvas');
                    
                    // Initialize characters
                    characters = {
                        frankie: {
                            x: 150,
                            y: 100,
                            size: 40,
                            color: p.color(239, 154, 154),
                            active: false
                        },
                        ollie: {
                            x: 250,
                            y: 100,
                            size: 40,
                            color: p.color(255, 235, 59),
                            active: false
                        },
                        izzy: {
                            x: 350,
                            y: 100,
                            size: 40,
                            color: p.color(76, 175, 80),
                            active: false
                        },
                        lenny: {
                            x: 450,
                            y: 100,
                            size: 40,
                            color: p.color(229, 57, 53),
                            active: false
                        }
                    };
                };
                
                p.draw = function() {
                    p.background('#f1f8e9');
                    
                    // Draw garden background
                    drawGarden();
                    
                    // Draw binomials based on current state
                    drawBinomials();
                    
                    // Draw characters
                    drawCharacters();
                    
                    // Run animations
                    updateAnimations();
                };
                
                function drawGarden() {
                    // Draw grass
                    p.fill('#81c784');
                    p.rect(0, height - 80, width, 80);
                    
                    // Draw flowers in the background
                    for (let i = 0; i < 10; i++) {
                        let x = i * 60 + 30;
                        drawFlower(x, height - 50, 15, p.color(p.random(150, 255), p.random(150, 255), p.random(150, 255)));
                    }
                    
                    // Draw sky
                    p.fill('#bbdefb');
                    p.rect(0, 0, width, 60);
                    
                    // Draw sun
                    p.fill('#ffeb3b');
                    p.circle(50, 50, 60);
                }
                
                function drawFlower(x, y, size, color) {
                    p.fill(color);
                    for (let i = 0; i < 5; i++) {
                        let angle = i * p.TWO_PI / 5;
                        let px = x + p.cos(angle) * size;
                        let py = y + p.sin(angle) * size;
                        p.ellipse(px, py, size, size);
                    }
                    p.fill('#ffeb3b');
                    p.circle(x, y, size * 0.8);
                }
                
                function drawBinomials() {
                    if (!currentProblem.firstBinomial) return;
                    
                    // Draw first binomial box
                    p.fill('#c8e6c9');
                    p.stroke(0);
                    p.strokeWeight(2);
                    p.rect(100, 200, 150, 70, 10);
                    
                    // Draw second binomial box
                    p.fill('#bbdefb');
                    p.rect(350, 200, 150, 70, 10);
                    
                    // Draw the binomial expressions
                    p.textSize(24);
                    p.fill(0);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text(`(${currentProblem.firstBinomial})`, 175, 235);
                    p.text(`(${currentProblem.secondBinomial})`, 425, 235);
                    
                    // If we're past the intro step, draw the multiplication symbol
                    if (gameState.currentStep > 0) {
                        p.textSize(36);
                        p.text("×", 300, 235);
                    }
                    
                    // Draw FOIL results based on current step
                    if (gameState.currentStep >= 1) {
                        drawFoilResults();
                    }
                }
                
                function drawFoilResults() {
                    p.textSize(18);
                    p.fill(0);
                    
                    const yPos = 320;
                    const xStart = 100;
                    const spacing = 120;
                    
                    // Draw result boxes
                    if (gameState.currentStep >= 1) {
                        // First
                        p.fill('#ffcdd2');
                        p.stroke(0);
                        p.strokeWeight(1);
                        p.rect(xStart, yPos, 100, 40, 5);
                        if (gameState.foilElements[0]) {
                            p.fill(0);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.text(gameState.foilElements[0], xStart + 50, yPos + 20);
                        }
                    }
                    
                    if (gameState.currentStep >= 2) {
                        // Outer
                        p.fill('#fff9c4');
                        p.rect(xStart + spacing, yPos, 100, 40, 5);
                        if (gameState.foilElements[1]) {
                            p.fill(0);
                            p.text(gameState.foilElements[1], xStart + spacing + 50, yPos + 20);
                        }
                    }
                    
                    if (gameState.currentStep >= 3) {
                        // Inner
                        p.fill('#c8e6c9');
                        p.rect(xStart + spacing * 2, yPos, 100, 40, 5);
                        if (gameState.foilElements[2]) {
                            p.fill(0);
                            p.text(gameState.foilElements[2], xStart + spacing * 2 + 50, yPos + 20);
                        }
                    }
                    
                    if (gameState.currentStep >= 4) {
                        // Last
                        p.fill('#bbdefb');
                        p.rect(xStart + spacing * 3, yPos, 100, 40, 5);
                        if (gameState.foilElements[3]) {
                            p.fill(0);
                            p.text(gameState.foilElements[3], xStart + spacing * 3 + 50, yPos + 20);
                        }
                    }
                    
                    // Draw the final result
                    if (gameState.currentStep >= 5) {
                        p.textSize(24);
                        p.fill('#4caf50');
                        p.text(gameState.result, width / 2, yPos + 70);
                        
                        // If there's a simplified form, show it
                        if (gameState.simplified && gameState.simplified !== gameState.result) {
                            p.textSize(18);
                            p.fill('#2196f3');
                            p.text("Simplified: " + gameState.simplified, width / 2, yPos + 100);
                        }
                    }
                }
                
                function drawCharacters() {
                    // Draw Frankie (Butterfly)
                    drawCharacter('frankie', characters.frankie.x, characters.frankie.y, characters.frankie.size, characters.frankie.color, characters.frankie.active);
                    
                    // Draw Ollie (Bee)
                    drawCharacter('ollie', characters.ollie.x, characters.ollie.y, characters.ollie.size, characters.ollie.color, characters.ollie.active);
                    
                    // Draw Izzy (Ant)
                    drawCharacter('izzy', characters.izzy.x, characters.izzy.y, characters.izzy.size, characters.izzy.color, characters.izzy.active);
                    
                    // Draw Lenny (Ladybug)
                    drawCharacter('lenny', characters.lenny.x, characters.lenny.y, characters.lenny.size, characters.lenny.color, characters.lenny.active);
                }
                
                function drawCharacter(name, x, y, size, color, active) {
                    p.push();
                    p.translate(x, y);
                    
                    if (active) {
                        // Add a glow effect
                        p.noStroke();
                        p.fill(255, 255, 0, 100);
                        p.ellipse(0, 0, size * 1.8, size * 1.8);
                        
                        // Make it slightly larger
                        size *= 1.2;
                    }
                    
                    // Draw the character based on name
                    switch (name) {
                        case 'frankie':
                            // Butterfly
                            p.fill(color);
                            p.ellipse(0, 0, size * 0.8, size * 0.8); // Body
                            
                            // Wings
                            p.fill(p.lerpColor(color, p.color(255), 0.3));
                            p.ellipse(-size/2, -size/5, size * 0.8, size * 0.6);
                            p.ellipse(size/2, -size/5, size * 0.8, size * 0.6);
                            
                            // Face
                            p.fill(0);
                            p.ellipse(-size/8, -size/10, size/10, size/10);
                            p.ellipse(size/8, -size/10, size/10, size/10);
                            
                            // Smile
                            p.noFill();
                            p.stroke(0);
                            p.strokeWeight(1);
                            p.arc(0, size/20, size/4, size/8, 0, p.PI);
                            break;
                            
                        case 'ollie':
                            // Bee
                            p.fill(color);
                            p.ellipse(0, 0, size, size * 0.8); // Body
                            
                            // Stripes
                            p.fill(0);
                            p.rect(-size/4, -size/3, size/2, size/10);
                            p.rect(-size/4, -size/6, size/2, size/10);
                            p.rect(-size/4, 0, size/2, size/10);
                            p.rect(-size/4, size/6, size/2, size/10);
                            
                            // Wings
                            p.fill(255, 255, 255, 180);
                            p.ellipse(-size/3, -size/4, size/2, size/3);
                            p.ellipse(size/3, -size/4, size/2, size/3);
                            
                            // Face
                            p.fill(0);
                            p.ellipse(-size/8, -size/6, size/12, size/12);
                            p.ellipse(size/8, -size/6, size/12, size/12);
                            
                            // Smile
                            p.noFill();
                            p.stroke(0);
                            p.strokeWeight(1);
                            p.arc(0, 0, size/4, size/8, 0, p.PI);
                            break;
                            
                        case 'izzy':
                            // Ant
                            p.fill(color);
                            p.ellipse(-size/5, 0, size/2, size/2); // Head
                            p.ellipse(0, 0, size/1.8, size/1.8); // Body
                            p.ellipse(size/4, 0, size/2.5, size/2.5); // End part
                            
                            // Legs
                            p.stroke(color);
                            p.strokeWeight(2);
                            // Left legs
                            p.line(-size/4, -size/4, -size/2, -size/2);
                            p.line(0, -size/4, -size/4, -size/2);
                            p.line(size/4, -size/4, 0, -size/2);
                            // Right legs
                            p.line(-size/4, size/4, -size/2, size/2);
                            p.line(0, size/4, -size/4, size/2);
                            p.line(size/4, size/4, 0, size/2);
                            
                            // Antennae
                            p.line(-size/3, -size/5, -size/2, -size/2);
                            p.line(-size/6, -size/5, -size/4, -size/2);
                            
                            // Face
                            p.fill(0);
                            p.noStroke();
                            p.ellipse(-size/3, 0, size/12, size/12);
                            p.ellipse(-size/6, 0, size/12, size/12);
                            break;
                            
                        case 'lenny':
                            // Ladybug
                            p.fill(color);
                            p.ellipse(0, 0, size, size * 0.8); // Body
                            
                            // Spots
                            p.fill(0);
                            p.ellipse(-size/4, -size/6, size/6, size/6);
                            p.ellipse(size/4, -size/6, size/6, size/6);
                            p.ellipse(-size/6, size/6, size/6, size/6);
                            p.ellipse(size/6, size/6, size/6, size/6);
                            
                            // Head
                            p.fill(0);
                            p.ellipse(0, -size/3, size/2, size/3);
                            
                            // Eyes
                            p.fill(255);
                            p.ellipse(-size/8, -size/3, size/10, size/10);
                            p.ellipse(size/8, -size/3, size/10, size/10);
                            
                            // Line down middle
                            p.stroke(0);
                            p.strokeWeight(1);
                            p.line(0, -size/6, 0, size/3);
                            break;
                    }
                    
                    p.pop();
                }
                
                function updateAnimations() {
                    // Add character wobble for active character
                    const step = gameState.currentStep;
                    
                    if (step === 1) {
                        characters.frankie.y = 100 + Math.sin(p.frameCount * 0.1) * 5;
                    } else if (step === 2) {
                        characters.ollie.y = 100 + Math.sin(p.frameCount * 0.1) * 5;
                    } else if (step === 3) {
                        characters.izzy.y = 100 + Math.sin(p.frameCount * 0.1) * 5;
                    } else if (step === 4) {
                        characters.lenny.y = 100 + Math.sin(p.frameCount * 0.1) * 5;
                    }
                }
                
                // Public methods to be called from outside the sketch
                p.activateCharacter = function(character, activate) {
                    if (characters[character]) {
                        characters[character].active = activate;
                    }
                };
                
                p.moveCharacterTo = function(character, x, y) {
                    if (characters[character]) {
                        const targetX = x;
                        const targetY = y;
                        const startX = characters[character].x;
                        const startY = characters[character].y;
                        
                        // Add animation to move character
                        const duration = 60 / gameState.speed; // Frames duration
                        
                        animations.push({
                            type: 'movement',
                            character: character,
                            startX: startX,
                            startY: startY,
                            targetX: targetX,
                            targetY: targetY,
                            progress: 0,
                            duration: duration,
                            update: function() {
                                this.progress++;
                                const ratio = this.progress / this.duration;
                                characters[this.character].x = p.lerp(this.startX, this.targetX, ratio);
                                characters[this.character].y = p.lerp(this.startY, this.targetY, ratio);
                                
                                return this.progress >= this.duration;
                            }
                        });
                    }
                };
                
                // This will be our public interface
                return {
                    activateCharacter: p.activateCharacter,
                    moveCharacterTo: p.moveCharacterTo
                };
            });
        }
        
        // Show help panel
        function showHelp() {
            overlay.style.display = "block";
            helpPanel.style.display = "block";
        }
        
        // Hide help panel
        function hideHelp() {
            overlay.style.display = "none";
            helpPanel.style.display = "none";
        }
        
        // Start the game
        function startGame() {
            initGame();
            generateNewProblem();
            updateStepIndicator();
            
            // Reset the game state
            gameState.currentStep = 0;
            prevStepButton.disabled = true;
            nextStepButton.disabled = false;
            
            // Update the UI
            updateUI();
        }
        
        // Generate a new binomial multiplication problem
        function generateNewProblem() {
            const difficulty = gameState.difficulty;
            let firstBinomial, secondBinomial;
            
            switch (difficulty) {
                case 1: // Simple numbers
                    firstBinomial = generateSimpleBinomial(true);
                    secondBinomial = generateSimpleBinomial(true);
                    break;
                case 2: // Mixed numbers
                    firstBinomial = generateSimpleBinomial(false);
                    secondBinomial = generateSimpleBinomial(false);
                    break;
                case 3: // Negative numbers
                    firstBinomial = generateNegativeBinomial();
                    secondBinomial = generateNegativeBinomial();
                    break;
                case 4: // Variables
                    firstBinomial = generateVariableBinomial("x");
                    secondBinomial = generateVariableBinomial("x");
                    break;
                case 5: // Mixed variables
                    firstBinomial = generateMixedBinomial();
                    secondBinomial = generateMixedBinomial();
                    break;
                default:
                    firstBinomial = "3 + 2";
                    secondBinomial = "4 + 1";
            }
            
            currentProblem = {
                firstBinomial: firstBinomial,
                secondBinomial: secondBinomial
            };
            
            // Calculate FOIL elements and result
            calculateFoilElements();
            
            // Reset step to intro
            gameState.currentStep = 0;
            prevStepButton.disabled = true;
            nextStepButton.disabled = false;
            
            // Update the problem display
            problemDisplay.textContent = `(${firstBinomial}) × (${secondBinomial})`;
            
            // Reset character states
            if (sketch) {
                sketch.activateCharacter('frankie', false);
                sketch.activateCharacter('ollie', false);
                sketch.activateCharacter('izzy', false);
                sketch.activateCharacter('lenny', false);
            }
            
            // Update the character message
            characterMessage.style.display = "block";
            characterMessage.textContent = "Let's multiply these binomials together! I'll show you the FOIL method step by step.";
            
            // Update step indicator
            updateStepIndicator();
            
            // Update explanation
            updateExplanation();
            
            // Hide the explanation box initially
            explanationBox.style.display = "none";
            
            // Generate quiz questions
            generateQuizQuestions();
            
            // Hide quiz section initially
            quizSection.style.display = "none";
        }
        
        // Generate a simple binomial with positive numbers
        function generateSimpleBinomial(onlyPositive) {
            const a = Math.floor(Math.random() * 5) + 1;
            let b = Math.floor(Math.random() * 5) + 1;
            
            if (!onlyPositive && Math.random() > 0.5) {
                b = -b;
            }
            
            return b >= 0 ? `${a} + ${b}` : `${a} - ${Math.abs(b)}`;
        }
        
        // Generate a binomial with potential negative numbers
        function generateNegativeBinomial() {
            let a = Math.floor(Math.random() * 6) + 1;
            let b = Math.floor(Math.random() * 6) + 1;
            
            if (Math.random() > 0.5) {
                a = -a;
            }
            
            if (Math.random() > 0.5) {
                b = -b;
            }
            
            return a >= 0 
                ? (b >= 0 ? `${a} + ${b}` : `${a} - ${Math.abs(b)}`)
                : (b >= 0 ? `-${Math.abs(a)} + ${b}` : `-${Math.abs(a)} - ${Math.abs(b)}`);
        }
        
        // Generate a binomial with variables
        function generateVariableBinomial(variable) {
            const a = Math.floor(Math.random() * 5) + 1;
            let b = Math.floor(Math.random() * 5) + 1;
            
            if (Math.random() > 0.5) {
                return b >= 0 ? `${a}${variable} + ${b}` : `${a}${variable} - ${Math.abs(b)}`;
            } else {
                return b >= 0 ? `${b} + ${a}${variable}` : `${b} - ${a}${variable}`;
            }
        }
        
        // Generate a mixed binomial with different variables
        function generateMixedBinomial() {
            const variables = ["x", "y"];
            const variable = variables[Math.floor(Math.random() * variables.length)];
            
            const a = Math.floor(Math.random() * 5) + 1;
            let b = Math.floor(Math.random() * 5) + 1;
            
            if (Math.random() > 0.5) {
                b = -b;
            }
            
            if (Math.random() > 0.7) {
                return b >= 0 
                    ? `${a}${variable} + ${b}${variable}`
                    : `${a}${variable} - ${Math.abs(b)}${variable}`;
            }
            
            return b >= 0 
                ? `${a}${variable} + ${b}`
                : `${a}${variable} - ${Math.abs(b)}`;
        }
        
        // Parse a binomial term
        function parseTerm(term) {
            // Regular expression to match coefficients and variables
            const pattern = /(-?\d*)(x|y)?/g;
            const parts = [];
            
            let match;
            while ((match = pattern.exec(term)) !== null) {
                if (match[0] === '') continue;
                
                let coefficient = match[1];
                if (coefficient === "-") coefficient = "-1";
                else if (coefficient === "") coefficient = "1";
                
                const variable = match[2] || "";
                
                parts.push({
                    coefficient: parseInt(coefficient),
                    variable: variable
                });
            }
            
            return parts;
        }
        
        // Calculate the FOIL elements and result
        function calculateFoilElements() {
            // Parse the binomials
            const first = parseBinomial(currentProblem.firstBinomial);
            const second = parseBinomial(currentProblem.secondBinomial);
            
            // F - First terms
            const firstTerm = multiplyTerms(first.first, second.first);
            
            // O - Outer terms
            const outerTerm = multiplyTerms(first.first, second.second);
            
            // I - Inner terms
            const innerTerm = multiplyTerms(first.second, second.first);
            
            // L - Last terms
            const lastTerm = multiplyTerms(first.second, second.second);
            
            // Store the results
            gameState.foilElements = [
                formatTerm(firstTerm),
                formatTerm(outerTerm),
                formatTerm(innerTerm),
                formatTerm(lastTerm)
            ];
            
            // Calculate the full result
            gameState.result = `${gameState.foilElements[0]} + ${gameState.foilElements[1]} + ${gameState.foilElements[2]} + ${gameState.foilElements[3]}`;
            
            // Fix the display for negative terms
            gameState.result = gameState.result.replace(/\+ -/g, "- ");
            
            // Calculate the simplified form
            gameState.simplified = simplifyExpression([firstTerm, outerTerm, innerTerm, lastTerm]);
        }
        
        // Parse a binomial expression
        function parseBinomial(binomial) {
            // Replace - with + - to make splitting easier
            const normalizedBinomial = binomial.replace(/\s*-\s*/g, " + -");
            
            // Split by + operator
            const terms = normalizedBinomial.split(/\s*\+\s*/);
            
            // Clean up terms
            const cleanTerms = terms.filter(term => term.trim() !== "").map(term => term.trim());
            
            return {
                first: cleanTerms[0],
                second: cleanTerms[1]
            };
        }
        
        // Multiply two terms
        function multiplyTerms(term1, term2) {
            const hasVariable1 = term1.includes("x") || term1.includes("y");
            const hasVariable2 = term2.includes("x") || term2.includes("y");
            
            let coefficient1, variable1;
            let coefficient2, variable2;
            
            // Parse first term
            if (hasVariable1) {
                const match = term1.match(/(-?\d*)([xy])/);
                coefficient1 = match[1] === "-" ? -1 : (match[1] === "" ? 1 : parseInt(match[1]));
                variable1 = match[2];
            } else {
                coefficient1 = parseInt(term1);
                variable1 = "";
            }
            
            // Parse second term
            if (hasVariable2) {
                const match = term2.match(/(-?\d*)([xy])/);
                coefficient2 = match[1] === "-" ? -1 : (match[1] === "" ? 1 : parseInt(match[1]));
                variable2 = match[2];
            } else {
                coefficient2 = parseInt(term2);
                variable2 = "";
            }
            
            // Calculate the product
            const newCoefficient = coefficient1 * coefficient2;
            let newVariable = "";
            
            if (variable1 && variable2) {
                if (variable1 === variable2) {
                    newVariable = `${variable1}²`;
                } else {
                    newVariable = `${variable1}${variable2}`;
                }
            } else {
                newVariable = variable1 || variable2;
            }
            
            return {
                coefficient: newCoefficient,
                variable: newVariable
            };
        }
        
        // Format a term for display
        function formatTerm(term) {
            const { coefficient, variable } = term;
            
            if (variable === "") {
                return `${coefficient}`;
            } else if (coefficient === 1) {
                return variable;
            } else if (coefficient === -1) {
                return `-${variable}`;
            } else {
                return `${coefficient}${variable}`;
            }
        }
        
        // Simplify an expression by combining like terms
        function simplifyExpression(terms) {
            const likeTerms = {};
            
            // Group like terms
            for (const term of terms) {
                const { coefficient, variable } = term;
                const key = variable || "constant";
                
                if (likeTerms[key]) {
                    likeTerms[key] += coefficient;
                } else {
                    likeTerms[key] = coefficient;
                }
            }
            
            // Format the result
            let result = "";
            
            // Handle constants first (no variables)
            if (likeTerms["constant"]) {
                result += likeTerms["constant"];
            }
            
            // Handle single variables (x, y)
            for (const variable of ["x", "y"]) {
                if (likeTerms[variable]) {
                    const coefficient = likeTerms[variable];
                    
                    if (coefficient !== 0) {
                        if (result !== "" && coefficient > 0) {
                            result += " + ";
                        } else if (result !== "" && coefficient < 0) {
                            result += " - ";
                        }
                        
                        const absCoefficient = Math.abs(coefficient);
                        
                        if (result === "" && coefficient < 0) {
                            result += "-";
                        }
                        
                        if (absCoefficient === 1) {
                            result += variable;
                        } else {
                            result += `${absCoefficient}${variable}`;
                        }
                    }
                }
            }
            
            // Handle squared variables (x², y²)
            for (const variable of ["x²", "y²"]) {
                if (likeTerms[variable]) {
                    const coefficient = likeTerms[variable];
                    
                    if (coefficient !== 0) {
                        if (result !== "" && coefficient > 0) {
                            result += " + ";
                        } else if (result !== "" && coefficient < 0) {
                            result += " - ";
                        }
                        
                        const absCoefficient = Math.abs(coefficient);
                        
                        if (result === "" && coefficient < 0) {
                            result += "-";
                        }
                        
                        if (absCoefficient === 1) {
                            result += variable;
                        } else {
                            result += `${absCoefficient}${variable}`;
                        }
                    }
                }
            }
            
            // Handle mixed variables (xy)
            for (const variable of ["xy", "yx"]) {
                if (likeTerms[variable]) {
                    const coefficient = likeTerms[variable];
                    
                    if (coefficient !== 0) {
                        if (result !== "" && coefficient > 0) {
                            result += " + ";
                        } else if (result !== "" && coefficient < 0) {
                            result += " - ";
                        }
                        
                        const absCoefficient = Math.abs(coefficient);
                        
                        if (result === "" && coefficient < 0) {
                            result += "-";
                        }
                        
                        if (absCoefficient === 1) {
                            result += "xy";
                        } else {
                            result += `${absCoefficient}xy`;
                        }
                    }
                }
            }
            
            // If result is empty, return 0
            return result || "0";
        }
        
        // Move to the previous step in the FOIL process
        function previousStep() {
            if (gameState.currentStep > 0) {
                gameState.currentStep--;
                updateUI();
                updateStepIndicator();
            }
            
            // Enable/disable buttons as needed
            prevStepButton.disabled = gameState.currentStep === 0;
            nextStepButton.disabled = false;
        }
        
        // Move to the next step in the FOIL process
        function nextStep() {
            if (gameState.currentStep < gameState.steps.length - 1) {
                gameState.currentStep++;
                updateUI();
                updateStepIndicator();
            }
            
            // Enable/disable buttons as needed
            prevStepButton.disabled = false;
            nextStepButton.disabled = gameState.currentStep === gameState.steps.length - 1;
            
            // If we're at the end, show the quiz
            if (gameState.currentStep === gameState.steps.length - 1) {
                setTimeout(() => {
                    quizSection.style.display = "block";
                    startQuiz();
                }, 1500);
            }
        }
        
        // Toggle explanation visibility
        function toggleExplanation() {
            if (explanationBox.style.display === "none" || explanationBox.style.display === "") {
                explanationBox.style.display = "block";
                showExplanationButton.textContent = "Hide Explanation";
            } else {
                explanationBox.style.display = "none";
                showExplanationButton.textContent = "Show Explanation";
            }
        }
        
        // Update the UI based on the current step
        function updateUI() {
            // Deactivate all characters
            if (sketch) {
                sketch.activateCharacter('frankie', false);
                sketch.activateCharacter('ollie', false);
                sketch.activateCharacter('izzy', false);
                sketch.activateCharacter('lenny', false);
            }
            
            // Update based on current step
            switch (gameState.currentStep) {
                case 0: // Intro
                    characterMessage.textContent = "Welcome to the Binomial Garden! We're going to multiply these binomials using the FOIL method!";
                    break;
                    
                case 1: // First
                    if (sketch) sketch.activateCharacter('frankie', true);
                    characterMessage.textContent = "Hi! I'm Frankie First! We multiply the FIRST terms: " + 
                        parseBinomial(currentProblem.firstBinomial).first + " × " + 
                        parseBinomial(currentProblem.secondBinomial).first + " = " + 
                        gameState.foilElements[0];
                    break;
                    
                case 2: // Outer
                    if (sketch) sketch.activateCharacter('ollie', true);
                    characterMessage.textContent = "Buzz! I'm Ollie Outer! We multiply the OUTER terms: " + 
                        parseBinomial(currentProblem.firstBinomial).first + " × " + 
                        parseBinomial(currentProblem.secondBinomial).second + " = " + 
                        gameState.foilElements[1];
                    break;
                    
                case 3: // Inner
                    if (sketch) sketch.activateCharacter('izzy', true);
                    characterMessage.textContent = "Hello! I'm Izzy Inner! We multiply the INNER terms: " + 
                        parseBinomial(currentProblem.firstBinomial).second + " × " + 
                        parseBinomial(currentProblem.secondBinomial).first + " = " + 
                        gameState.foilElements[2];
                    break;
                    
                case 4: // Last
                    if (sketch) sketch.activateCharacter('lenny', true);
                    characterMessage.textContent = "Hi there! I'm Lenny Last! We multiply the LAST terms: " + 
                        parseBinomial(currentProblem.firstBinomial).second + " × " + 
                        parseBinomial(currentProblem.secondBinomial).second + " = " + 
                        gameState.foilElements[3];
                    break;
                    
                case 5: // Result
                    characterMessage.textContent = "Great job! Now we add all the terms together: " + 
                        gameState.foilElements[0] + " + " + gameState.foilElements[1] + " + " + 
                        gameState.foilElements[2] + " + " + gameState.foilElements[3] + " = " + gameState.simplified;
                    break;
            }
            
            // Update explanation
            updateExplanation();
        }
        
        // Update the explanation based on the current level and step
        function updateExplanation() {
            const level = gameState.explanationLevel;
            const step = gameState.currentStep;
            
            // Basic explanation for all levels
            let basicText = "";
            
            switch (step) {
                case 0:
                    basicText = `<p>We're going to multiply (${currentProblem.firstBinomial}) × (${currentProblem.secondBinomial}) using the FOIL method!</p>`;
                    break;
                    
                case 1:
                    basicText = `<p>Step 1: <strong>F</strong> is for <strong>First</strong>.</p>
                                <p>We multiply the first terms: ${parseBinomial(currentProblem.firstBinomial).first} × ${parseBinomial(currentProblem.secondBinomial).first} = ${gameState.foilElements[0]}</p>`;
                    break;
                    
                case 2:
                    basicText = `<p>Step 2: <strong>O</strong> is for <strong>Outer</strong>.</p>
                                <p>We multiply the outer terms: ${parseBinomial(currentProblem.firstBinomial).first} × ${parseBinomial(currentProblem.secondBinomial).second} = ${gameState.foilElements[1]}</p>`;
                    break;
                    
                case 3:
                    basicText = `<p>Step 3: <strong>I</strong> is for <strong>Inner</strong>.</p>
                                <p>We multiply the inner terms: ${parseBinomial(currentProblem.firstBinomial).second} × ${parseBinomial(currentProblem.secondBinomial).first} = ${gameState.foilElements[2]}</p>`;
                    break;
                    
                case 4:
                    basicText = `<p>Step 4: <strong>L</strong> is for <strong>Last</strong>.</p>
                                <p>We multiply the last terms: ${parseBinomial(currentProblem.firstBinomial).second} × ${parseBinomial(currentProblem.secondBinomial).second} = ${gameState.foilElements[3]}</p>`;
                    break;
                    
                case 5:
                    basicText = `<p>Step 5: Add all the pieces together!</p>
                                <p>${gameState.foilElements[0]} + ${gameState.foilElements[1]} + ${gameState.foilElements[2]} + ${gameState.foilElements[3]} = ${gameState.result}</p>`;
                    if (gameState.simplified !== gameState.result) {
                        basicText += `<p>We can simplify this to: ${gameState.simplified}</p>`;
                    }
                    break;
            }
            
            basicExplanation.innerHTML = basicText;
            
            // Advanced explanation based on level
            let advancedText = "";
            
            if (level === "medium" || level === "advanced" || level === "expert") {
                switch (step) {
                    case 0:
                        advancedText = `<p>FOIL is a special pattern to remember when multiplying two binomials. A binomial is a math expression with two terms, like (a + b).</p>`;
                        break;
                        
                    case 1:
                        advancedText = `<p>The F in FOIL stands for "First." We multiply the first term of each binomial.</p>
                                      <p>In our example, the first terms are ${parseBinomial(currentProblem.firstBinomial).first} and ${parseBinomial(currentProblem.secondBinomial).first}.</p>`;
                        break;
                        
                    case 2:
                        advancedText = `<p>The O in FOIL stands for "Outer." We multiply the outer terms - the first term of the first binomial and the last term of the second binomial.</p>
                                      <p>In our example, the outer terms are ${parseBinomial(currentProblem.firstBinomial).first} and ${parseBinomial(currentProblem.secondBinomial).second}.</p>`;
                        break;
                        
                    case 3:
                        advancedText = `<p>The I in FOIL stands for "Inner." We multiply the inner terms - the last term of the first binomial and the first term of the second binomial.</p>
                                      <p>In our example, the inner terms are ${parseBinomial(currentProblem.firstBinomial).second} and ${parseBinomial(currentProblem.secondBinomial).first}.</p>`;
                        break;
                        
                    case 4:
                        advancedText = `<p>The L in FOIL stands for "Last." We multiply the last term of each binomial.</p>
                                      <p>In our example, the last terms are ${parseBinomial(currentProblem.firstBinomial).second} and ${parseBinomial(currentProblem.secondBinomial).second}.</p>`;
                        break;
                        
                    case 5:
                        advancedText = `<p>Now we combine all the terms by adding them together. This gives us the complete product of the two binomials.</p>`;
                        
                        if (gameState.simplified !== gameState.result) {
                            advancedText += `<p>Sometimes we can simplify our answer by combining "like terms" - terms with the same variables. For example, 2x + 3x = 5x.</p>`;
                        }
                        break;
                }
            }
            
            // Add more advanced content for higher levels
            if (level === "advanced" || level === "expert") {
                switch (step) {
                    case 0:
                        advancedText += `<p>When we multiply two binomials (a + b)(c + d), we get a product with four terms: ac + ad + bc + bd. The FOIL method helps us remember the pattern.</p>`;
                        break;
                        
                    case 5:
                        advancedText += `<p>The distributive property is what allows us to multiply binomials. It states that a(b + c) = ab + ac. When we apply this twice, we get (a + b)(c + d) = a(c + d) + b(c + d) = ac + ad + bc + bd, which is exactly what FOIL helps us calculate.</p>`;
                        break;
                }
            }
            
            // Add PhD level simplified content
            if (level === "expert") {
                switch (step) {
                    case 0:
                        advancedText += `<p>The FOIL method is a specific application of the distributive property of multiplication over addition in algebra. It's conceptually similar to how we multiply multi-digit numbers by considering place values.</p>`;
                        break;
                        
                    case 5:
                        advancedText += `<p>In more advanced mathematics, this concept extends to multiplying polynomials of any degree, matrix multiplication, and even convolution in signal processing. The core idea of distributing the multiplication across all term combinations remains the same.</p>`;
                        
                        advancedText += `<p>Binomial multiplication is also foundational for understanding the binomial theorem, which describes patterns in (a + b)ⁿ for any positive integer n. This has applications in probability, statistics, and combinatorics.</p>`;
                        break;
                }
            }
            
            advancedExplanation.innerHTML = advancedText;
        }
        
        // Update the step indicator
        function updateStepIndicator() {
            const steps = document.querySelectorAll('.step');
            
            steps.forEach((step, index) => {
                if (index <= gameState.currentStep) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }
            });
        }
        
        // Generate quiz questions
        function generateQuizQuestions() {
            quizQuestions = [];
            
            // Question 1: What is the result of multiplying the first terms?
            quizQuestions.push({
                question: `What is the result of multiplying the FIRST terms of (${currentProblem.firstBinomial}) and (${currentProblem.secondBinomial})?`,
                options: [
                    gameState.foilElements[0],
                    gameState.foilElements[1],
                    gameState.foilElements[2],
                    gameState.foilElements[3]
                ],
                correctIndex: 0,
                explanation: `The first terms are ${parseBinomial(currentProblem.firstBinomial).first} and ${parseBinomial(currentProblem.secondBinomial).first}, which multiply to give ${gameState.foilElements[0]}.`
            });
            
            // Question 2: What is the final result?
            const wrongResults = [
                generateWrongResult(),
                generateWrongResult(),
                generateWrongResult()
            ];
            
            quizQuestions.push({
                question: `What is the final result of (${currentProblem.firstBinomial}) × (${currentProblem.secondBinomial})?`,
                options: [
                    gameState.simplified,
                    wrongResults[0],
                    wrongResults[1],
                    wrongResults[2]
                ],
                correctIndex: 0,
                explanation: `Using FOIL: (${currentProblem.firstBinomial}) × (${currentProblem.secondBinomial}) = ${gameState.foilElements[0]} + ${gameState.foilElements[1]} + ${gameState.foilElements[2]} + ${gameState.foilElements[3]} = ${gameState.simplified}`
            });
            
            // Question 3: What does the "I" in FOIL stand for?
            quizQuestions.push({
                question: "What does the 'I' in FOIL stand for?",
                options: [
                    "Inner",
                    "Important",
                    "Integer",
                    "Intermediate"
                ],
                correctIndex: 0,
                explanation: "The 'I' in FOIL stands for 'Inner', meaning we multiply the inner terms of the two binomials."
            });
            
            // Question 4: Match the FOIL step
            quizQuestions.push({
                question: `Which FOIL step would give us the term ${gameState.foilElements[2]}?`,
                options: [
                    "First",
                    "Outer",
                    "Inner",
                    "Last"
                ],
                correctIndex: 2,
                explanation: `The Inner step multiplies ${parseBinomial(currentProblem.firstBinomial).second} and ${parseBinomial(currentProblem.secondBinomial).first} to give ${gameState.foilElements[2]}.`
            });
            
            // Shuffle options for each question
            quizQuestions.forEach(q => {
                const correctOption = q.options[q.correctIndex];
                const shuffledOptions = shuffleArray([...q.options]);
                q.correctIndex = shuffledOptions.indexOf(correctOption);
                q.options = shuffledOptions;
            });
            
            // Shuffle question order
            quizQuestions = shuffleArray(quizQuestions);
        }
        
        // Generate a wrong result for quiz options
        function generateWrongResult() {
            const terms = gameState.foilElements;
            let modifiedTerms; // Declare variable once at the top
            
            // Choose a way to make it wrong
            const errorType = Math.floor(Math.random() * 3);
            
            switch (errorType) {
                case 0: // Change a sign
                    const termToChange = Math.floor(Math.random() * terms.length);
                    modifiedTerms = [...terms]; // Assign here instead of declaring again
                    
                    // Change the sign of one term
                    if (modifiedTerms[termToChange].startsWith("-")) {
                        modifiedTerms[termToChange] = modifiedTerms[termToChange].substring(1);
                    } else {
                        modifiedTerms[termToChange] = "-" + modifiedTerms[termToChange];
                    }
                    
                    return simplifyExpression(modifiedTerms.map(parseTerm));
                    
                case 1: // Change a number
                    const term = Math.floor(Math.random() * terms.length);
                    modifiedTerms = [...terms]; // Assign here instead of declaring again
                    
                    // Extract the number from the term
                    const match = modifiedTerms[term].match(/^(-?\d+)/);
                    
                    if (match) {
                        const number = parseInt(match[0]);
                        const newNumber = number + (Math.random() > 0.5 ? 1 : -1);
                        
                        modifiedTerms[term] = modifiedTerms[term].replace(/^(-?\d+)/, newNumber);
                    }
                    
                    return simplifyExpression(modifiedTerms.map(parseTerm));
                    
                case 2: // Forget a term
                    const termToRemove = Math.floor(Math.random() * terms.length);
                    const reducedTerms = terms.filter((_, i) => i !== termToRemove);
                    
                    return simplifyExpression(reducedTerms.map(parseTerm));
            }
        }
        
        // Shuffle an array
        function shuffleArray(array) {
            const newArray = [...array];
            
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            
            return newArray;
        }
        
        // Start the quiz
        function startQuiz() {
            quizActive = true;
            currentQuizIndex = 0;
            selectedOption = null;
            
            displayCurrentQuestion();
        }
        
        // Display the current quiz question
        function displayCurrentQuestion() {
            const question = quizQuestions[currentQuizIndex];
            
            quizQuestion.textContent = question.question;
            quizOptions.innerHTML = "";
            
            question.options.forEach((option, index) => {
                const optionElement = document.createElement("div");
                optionElement.className = "quiz-option";
                optionElement.textContent = option;
                optionElement.dataset.index = index;
                
                optionElement.addEventListener("click", () => {
                    // Remove previous selection
                    document.querySelectorAll(".quiz-option").forEach(opt => {
                        opt.style.backgroundColor = "";
                    });
                    
                    // Highlight the selected option
                    optionElement.style.backgroundColor = "#a5d6a7";
                    selectedOption = index;
                    
                    // Show the check answer button
                    checkAnswerButton.style.display = "block";
                });
                
                quizOptions.appendChild(optionElement);
            });
            
            // Reset UI elements
            quizFeedback.style.display = "none";
            quizFeedback.className = "feedback";
            checkAnswerButton.style.display = "none";
            nextQuestionButton.style.display = "none";
        }
        
        // Check the quiz answer
        function checkAnswer() {
            const question = quizQuestions[currentQuizIndex];
            
            if (selectedOption === null) return;
            
            if (selectedOption === question.correctIndex) {
                quizFeedback.textContent = "Correct! " + question.explanation;
                quizFeedback.className = "feedback correct";
            } else {
                quizFeedback.textContent = "Not quite. " + question.explanation;
                quizFeedback.className = "feedback incorrect";
            }
            
            quizFeedback.style.display = "block";
            checkAnswerButton.style.display = "none";
            
            // Show next question button if there are more questions
            if (currentQuizIndex < quizQuestions.length - 1) {
                nextQuestionButton.style.display = "block";
            } else {
                nextQuestionButton.textContent = "Finish Quiz";
                nextQuestionButton.style.display = "block";
            }
        }
        
        // Move to the next quiz question
        function nextQuizQuestion() {
            currentQuizIndex++;
            
            if (currentQuizIndex < quizQuestions.length) {
                displayCurrentQuestion();
            } else {
                // Quiz completed
                quizSection.innerHTML = `
                    <h2>Quiz Completed!</h2>
                    <div style="text-align: center; padding: 20px;">
                        <p>Great job completing the binomial multiplication quiz!</p>
                        <button id="restart-button">Try Another Problem</button>
                    </div>
                `;
                
                document.getElementById("restart-button").addEventListener("click", () => {
                    generateNewProblem();
                    quizSection.style.display = "none";
                });
            }
        }
        
        // Initialize the game on load
        window.addEventListener("load", initGame);
    </script>
</body>
</html>
