<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Show Explorer: Amazing Learning Adventure</title>
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2980, #26d0ce);
            overflow: hidden;
            touch-action: manipulation;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Screens */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.5s;
            opacity: 0;
            pointer-events: none;
        }
        
        .screen.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Title Screen */
        #splash-screen {
            background: linear-gradient(135deg, #1a2980, #26d0ce);
            text-align: center;
        }
        
        #splash-screen h1 {
            font-size: 3.5rem;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            margin-bottom: 1rem;
            animation: glow 2s infinite alternate;
        }
        
        .splash-subtitle {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 2rem;
        }
        
        /* Buttons */
        .button {
            padding: 1rem 2rem;
            margin: 0.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            border: none;
            border-radius: 50px;
            background: #fff;
            color: #1a2980;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }
        
        .button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            background: #ffd700;
        }
        
        .button:active {
            transform: translateY(1px);
        }
        
        .large-button {
            padding: 1.5rem 3rem;
            font-size: 1.5rem;
            margin: 1rem;
        }
        
        .icon-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            position: absolute;
            top: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }
        
        #settings-button {
            right: 20px;
        }
        
        #help-button {
            right: 80px;
        }
        
        #back-button {
            left: 20px;
        }

        /* Canvas */
        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        /* Selection Screen */
        #selection-screen {
            background: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
        
        .selection-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 2rem;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .selection-container h2 {
            font-size: 2rem;
            color: #1a2980;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .selection-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .pattern-option {
            background: white;
            border: 3px solid #ccc;
            border-radius: 15px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .pattern-option.selected {
            border-color: #ffd700;
            box-shadow: 0 0 15px #ffd700;
            transform: scale(1.05);
        }
        
        .pattern-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .color-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .color-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .color-option.selected {
            transform: scale(1.2);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        .input-container {
            text-align: center;
            margin-bottom: 1.5rem;
        }
        
        .input-container label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
            color: #333;
        }
        
        .input-container input[type="text"] {
            width: 100%;
            padding: 1rem;
            font-size: 1.2rem;
            border: 2px solid #ccc;
            border-radius: 10px;
            text-align: center;
        }
        
        .input-container input[type="text"]:focus {
            outline: none;
            border-color: #1a2980;
            box-shadow: 0 0 10px rgba(26, 41, 128, 0.3);
        }
        
        .slider-container {
            margin-bottom: 1.5rem;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
            color: #333;
        }
        
        .slider-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .slider-wrapper input[type="range"] {
            flex: 1;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }
        
        /* Quiz Screen */
        #quiz-screen {
            background: rgba(0, 0, 0, 0.8);
            z-index: 20;
        }
        
        .quiz-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .quiz-container h2 {
            font-size: 1.8rem;
            color: #1a2980;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .quiz-question {
            font-size: 1.3rem;
            margin-bottom: 1.5rem;
            text-align: center;
            color: #333;
        }
        
        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .quiz-option {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1rem;
        }
        
        .quiz-option:hover {
            background: #f0f0f0;
        }
        
        .quiz-option.selected {
            border-color: #1a2980;
            background: #e6f0ff;
        }
        
        .quiz-option.correct {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        .quiz-option.incorrect {
            border-color: #f44336;
            background: #ffebee;
        }
        
        /* Character */
        .character-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 50;
            display: flex;
            align-items: flex-end;
        }
        
        .character {
            width: 120px;
            height: 120px;
            transition: all 0.3s;
        }
        
        .speech-bubble {
            background: white;
            border-radius: 20px;
            padding: 1rem;
            max-width: 300px;
            margin-left: 1rem;
            position: relative;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 1rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .speech-bubble:before {
            content: "";
            position: absolute;
            left: -15px;
            bottom: 20px;
            border-width: 15px 15px 0;
            border-style: solid;
            border-color: white transparent;
            transform: rotate(-90deg);
        }
        
        /* Reward Screen */
        #reward-screen {
            background: rgba(0, 0, 0, 0.8);
            z-index: 30;
        }
        
        .reward-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .reward-title {
            font-size: 2rem;
            color: #1a2980;
            margin-bottom: 1rem;
        }
        
        .reward-text {
            font-size: 1.3rem;
            margin-bottom: 2rem;
            color: #333;
        }
        
        .reward-animation {
            height: 200px;
            margin-bottom: 2rem;
            position: relative;
        }
        
        /* Learning Path */
        .learning-path-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 40;
        }
        
        .learning-path {
            display: flex;
            gap: 10px;
        }
        
        .path-segment {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
        }
        
        .path-segment.completed {
            background: #4CAF50;
        }
        
        .path-segment.current {
            background: #ffd700;
            transform: scale(1.3);
            box-shadow: 0 0 10px #ffd700;
        }
        
        /* Parameters Screen */
        #parameters-screen {
            background: rgba(0, 0, 0, 0.8);
            z-index: 25;
        }
        
        .parameters-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .parameters-container h2 {
            font-size: 2rem;
            color: #1a2980;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .parameter-group {
            margin-bottom: 2rem;
        }
        
        .parameter-group h3 {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 1rem;
            border-bottom: 2px solid #eee;
            padding-bottom: 0.5rem;
        }
        
        /* Settings Screen */
        #settings-screen {
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        .settings-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .settings-container h2 {
            font-size: 2rem;
            color: #1a2980;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .settings-group {
            margin-bottom: 1.5rem;
        }
        
        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .toggle-container label {
            font-size: 1.2rem;
            color: #333;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #1a2980;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        /* Help Screen */
        #help-screen {
            background: rgba(0, 0, 0, 0.8);
            z-index: 110;
        }
        
        .help-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .help-container h2 {
            font-size: 2rem;
            color: #1a2980;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .help-section {
            margin-bottom: 2rem;
        }
        
        .help-section h3 {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 1rem;
            border-bottom: 2px solid #eee;
            padding-bottom: 0.5rem;
        }
        
        .help-section p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: #333;
            line-height: 1.5;
        }
        
        /* Hint */
        .hint-container {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 60;
        }
        
        .hint-button {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        
        .hint-text {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            margin-top: 0.5rem;
            font-size: 1rem;
            max-width: 250px;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* Animations */
        @keyframes glow {
            from {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            }
            to {
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 0 0 30px rgba(255, 215, 0, 0.7);
            }
        }
        
        .star {
            position: absolute;
            pointer-events: none;
        }
        
        .bubble {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }
        
        /* Progress Bar */
        .progress-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            height: 15px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            z-index: 30;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #ffd700, #ff9900);
            width: 0%;
            border-radius: 20px;
            transition: width 0.5s;
        }
        
        /* Score display */
        .score-display {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.2rem;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 30;
        }
        
        /* Confetti */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ffd700;
            pointer-events: none;
        }
        
        /* Responsive Adjustments */
        @media (max-width: 768px) {
            #splash-screen h1 {
                font-size: 2.5rem;
            }
            
            .splash-subtitle {
                font-size: 1.2rem;
            }
            
            .large-button {
                padding: 1rem 2rem;
                font-size: 1.2rem;
            }
            
            .character {
                width: 80px;
                height: 80px;
            }
            
            .speech-bubble {
                max-width: 200px;
                padding: 0.8rem;
                font-size: 0.9rem;
            }
            
            .quiz-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Canvas Container -->
        <div id="canvas-container"></div>
        
        <!-- UI Elements -->
        <div id="ui-container">
            <!-- Progress Bar -->
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <!-- Score Display -->
            <div class="score-display" id="score-display">Score: 0</div>
            
            <!-- Character -->
            <div class="character-container">
                <div class="character" id="professor-character"></div>
                <div class="speech-bubble" id="speech-bubble"></div>
            </div>
            
            <!-- Learning Path -->
            <div class="learning-path-container">
                <div class="learning-path" id="learning-path"></div>
            </div>
            
            <!-- Hint -->
            <div class="hint-container">
                <button class="hint-button" id="hint-button">üí°</button>
                <div class="hint-text" id="hint-text"></div>
            </div>
            
            <!-- Control Buttons -->
            <button class="icon-button" id="settings-button">‚öôÔ∏è</button>
            <button class="icon-button" id="help-button">‚ùì</button>
            <button class="icon-button" id="back-button" style="display: none;">‚Üê</button>
        </div>
        
        <!-- Screens -->
        <div id="splash-screen" class="screen visible">
            <h1>Drone Show Explorer</h1>
            <p class="splash-subtitle">An Amazing Learning Adventure!</p>
            <button class="button large-button" id="start-button">Start the Adventure</button>
        </div>
        
        <div id="selection-screen" class="screen">
            <div class="selection-container">
                <h2>Create Your Drone Show</h2>
                
                <div class="input-container">
                    <label for="show-text">What do you want your drones to spell?</label>
                    <input type="text" id="show-text" placeholder="Type your text here" maxlength="15">
                </div>
                
                <h3>Choose a Pattern</h3>
                <div class="selection-options" id="pattern-options">
                    <div class="pattern-option" data-pattern="circle">
                        <div class="pattern-icon">‚≠ï</div>
                        <div>Circle</div>
                    </div>
                    <div class="pattern-option" data-pattern="heart">
                        <div class="pattern-icon">‚ù§Ô∏è</div>
                        <div>Heart</div>
                    </div>
                    <div class="pattern-option" data-pattern="spiral">
                        <div class="pattern-icon">üåÄ</div>
                        <div>Spiral</div>
                    </div>
                    <div class="pattern-option" data-pattern="star">
                        <div class="pattern-icon">‚≠ê</div>
                        <div>Star</div>
                    </div>
                    <div class="pattern-option" data-pattern="firework">
                        <div class="pattern-icon">üéÜ</div>
                        <div>Firework</div>
                    </div>
                    <div class="pattern-option" data-pattern="zigzag">
                        <div class="pattern-icon">‚ö°</div>
                        <div>Zigzag</div>
                    </div>
                </div>
                
                <h3>Choose Drone Colors</h3>
                <div class="color-options" id="color-options">
                    <div class="color-option" style="background-color: #FF0000;" data-color="#FF0000"></div>
                    <div class="color-option" style="background-color: #00FF00;" data-color="#00FF00"></div>
                    <div class="color-option" style="background-color: #0000FF;" data-color="#0000FF"></div>
                    <div class="color-option" style="background-color: #FFFF00;" data-color="#FFFF00"></div>
                    <div class="color-option" style="background-color: #FF00FF;" data-color="#FF00FF"></div>
                    <div class="color-option" style="background-color: #00FFFF;" data-color="#00FFFF"></div>
                    <div class="color-option" style="background-color: #FF8800;" data-color="#FF8800"></div>
                    <div class="color-option selected" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                </div>
                
                <div class="slider-container">
                    <label for="drone-count">Number of Drones</label>
                    <div class="slider-wrapper">
                        <input type="range" id="drone-count" min="50" max="300" value="150" step="10">
                        <span class="slider-value" id="drone-count-value">150</span>
                    </div>
                </div>
                
                <div class="slider-container">
                    <label for="drone-speed">Drone Speed</label>
                    <div class="slider-wrapper">
                        <input type="range" id="drone-speed" min="1" max="10" value="5" step="1">
                        <span class="slider-value" id="drone-speed-value">5</span>
                    </div>
                </div>
                
                <button class="button" id="advanced-button">Advanced Parameters</button>
                <button class="button" id="start-show-button">Start the Show!</button>
            </div>
        </div>
        
        <div id="parameters-screen" class="screen">
            <div class="parameters-container">
                <h2>Advanced Parameters</h2>
                
                <div class="parameter-group">
                    <h3>Physics Parameters</h3>
                    
                    <div class="slider-container">
                        <label for="gravity-effect">Gravity Effect</label>
                        <div class="slider-wrapper">
                            <input type="range" id="gravity-effect" min="0" max="10" value="0" step="1">
                            <span class="slider-value" id="gravity-effect-value">0</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="wind-effect">Wind Effect</label>
                        <div class="slider-wrapper">
                            <input type="range" id="wind-effect" min="0" max="10" value="0" step="1">
                            <span class="slider-value" id="wind-effect-value">0</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="bounce-effect">Bounce Effect</label>
                        <div class="slider-wrapper">
                            <input type="range" id="bounce-effect" min="0" max="10" value="5" step="1">
                            <span class="slider-value" id="bounce-effect-value">5</span>
                        </div>
                    </div>
                </div>
                
                <div class="parameter-group">
                    <h3>Visual Effects</h3>
                    
                    <div class="slider-container">
                        <label for="trail-length">Trail Length</label>
                        <div class="slider-wrapper">
                            <input type="range" id="trail-length" min="0" max="100" value="40" step="5">
                            <span class="slider-value" id="trail-length-value">40</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="glow-intensity">Glow Intensity</label>
                        <div class="slider-wrapper">
                            <input type="range" id="glow-intensity" min="0" max="10" value="5" step="1">
                            <span class="slider-value" id="glow-intensity-value">5</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="pulse-rate">Pulse Rate</label>
                        <div class="slider-wrapper">
                            <input type="range" id="pulse-rate" min="0" max="10" value="3" step="1">
                            <span class="slider-value" id="pulse-rate-value">3</span>
                        </div>
                    </div>
                </div>
                
                <div class="parameter-group">
                    <h3>Pattern Modifications</h3>
                    
                    <div class="slider-container">
                        <label for="pattern-size">Pattern Size</label>
                        <div class="slider-wrapper">
                            <input type="range" id="pattern-size" min="1" max="10" value="5" step="1">
                            <span class="slider-value" id="pattern-size-value">5</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="rotation-speed">Rotation Speed</label>
                        <div class="slider-wrapper">
                            <input type="range" id="rotation-speed" min="0" max="10" value="2" step="1">
                            <span class="slider-value" id="rotation-speed-value">2</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="wave-effect">Wave Effect</label>
                        <div class="slider-wrapper">
                            <input type="range" id="wave-effect" min="0" max="10" value="5" step="1">
                            <span class="slider-value" id="wave-effect-value">5</span>
                        </div>
                    </div>
                </div>
                
                <button class="button" id="parameters-back-button">Back</button>
            </div>
        </div>
        
        <div id="quiz-screen" class="screen">
            <div class="quiz-container">
                <h2>Knowledge Check</h2>
                <div id="quiz-question" class="quiz-question"></div>
                <div id="quiz-options" class="quiz-options"></div>
                <button class="button" id="quiz-check-button">Check Answer</button>
            </div>
        </div>
        
        <div id="reward-screen" class="screen">
            <div class="reward-container">
                <h2 class="reward-title">Great Job!</h2>
                <div id="reward-text" class="reward-text"></div>
                <div id="reward-animation" class="reward-animation"></div>
                <button class="button" id="continue-button">Continue Learning</button>
            </div>
        </div>
        
        <div id="settings-screen" class="screen">
            <div class="settings-container">
                <h2>Settings</h2>
                
                <div class="settings-group">
                    <div class="toggle-container">
                        <label for="sound-toggle">Sound Effects</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="sound-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="slider-container">
                        <label for="sound-volume">Volume</label>
                        <div class="slider-wrapper">
                            <input type="range" id="sound-volume" min="0" max="10" value="7" step="1">
                            <span class="slider-value" id="sound-volume-value">7</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <div class="toggle-container">
                        <label for="music-toggle">Background Music</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="music-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="slider-container">
                        <label for="music-volume">Music Volume</label>
                        <div class="slider-wrapper">
                            <input type="range" id="music-volume" min="0" max="10" value="5" step="1">
                            <span class="slider-value" id="music-volume-value">5</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-group">
                    <div class="toggle-container">
                        <label for="tutorials-toggle">Show Tutorials</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="tutorials-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="toggle-container">
                        <label for="particles-toggle">Show Particles</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="particles-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <button class="button" id="settings-close-button">Close</button>
            </div>
        </div>
        
        <div id="help-screen" class="screen">
            <div class="help-container">
                <h2>How to Play</h2>
                
                <div class="help-section">
                    <h3>Creating Your Drone Show</h3>
                    <p>1. Type the text you want your drones to spell out.</p>
                    <p>2. Choose a pattern for your drones to follow.</p>
                    <p>3. Select colors for your drones.</p>
                    <p>4. Adjust the number of drones and their speed.</p>
                    <p>5. For more options, click "Advanced Parameters".</p>
                    <p>6. Click "Start the Show" to watch your creation!</p>
                </div>
                
                <div class="help-section">
                    <h3>Learning About Drones</h3>
                    <p>As you create shows, you'll learn about coordinates, patterns, and basic physics.</p>
                    <p>Answer quiz questions correctly to earn points and unlock new features!</p>
                    <p>Professor Droney will guide you through your learning journey.</p>
                </div>
                
                <div class="help-section">
                    <h3>Tips for Creating Amazing Shows</h3>
                    <p>- Use shorter text for clearer displays</p>
                    <p>- Try different patterns to see how they affect your show</p>
                    <p>- Experiment with the advanced parameters to create unique effects</p>
                    <p>- Higher drone counts create more detailed patterns</p>
                </div>
                
                <button class="button" id="help-close-button">Got It!</button>
            </div>
        </div>
        
        <!-- Add missing game screen -->
        <div id="game-screen" class="screen">
            <!-- Game screen content will be dynamically added here -->
        </div>
    </div>

    <script>
        // =====================================
        // GAME STATE
        // =====================================
        const gameState = {
            // Game progression
            currentLevel: 1,
            maxLevel: 5,
            score: 0,
            progress: 0,
            
            // Show settings
            text: "",
            pattern: "circle",
            droneColor: "#FFFFFF",
            droneCount: 150,
            droneSpeed: 5,
            
            // Advanced parameters
            parameters: {
                // Physics
                gravityEffect: 0,
                windEffect: 0,
                bounceEffect: 5,
                
                // Visual
                trailLength: 40,
                glowIntensity: 5,
                pulseRate: 3,
                
                // Pattern
                patternSize: 5,
                rotationSpeed: 2,
                waveEffect: 5
            },
            
            // Animation state
            animations: {
                stars: [],
                bubbles: [],
                confetti: [],
                timers: []
            },
            
            // Quiz state
            currentQuiz: {
                question: "",
                options: [],
                correctAnswer: "",
                userAnswer: ""
            },
            
            // Settings
            settings: {
                soundEnabled: true,
                soundVolume: 7,
                musicEnabled: true,
                musicVolume: 5,
                tutorialsEnabled: true,
                particlesEnabled: true
            }
        };

        // =====================================
        // ELEMENT REFERENCES
        // =====================================
        let elements; // Declare elements variable to be initialized after DOM is fully loaded
        
        // Function to initialize all element references
        function initElements() {
            elements = {
                screens: {
                    splashScreen: document.getElementById('splash-screen'),
                    selectionScreen: document.getElementById('selection-screen'),
                    parametersScreen: document.getElementById('parameters-screen'),
                    quizScreen: document.getElementById('quiz-screen'),
                    rewardScreen: document.getElementById('reward-screen'),
                    settingsScreen: document.getElementById('settings-screen'),
                    helpScreen: document.getElementById('help-screen'),
                    gameScreen: document.getElementById('game-screen') // Added missing gameScreen reference
                },
                buttons: {
                    startButton: document.getElementById('start-button'),
                    advancedButton: document.getElementById('advanced-button'),
                    startShowButton: document.getElementById('start-show-button'),
                    parametersBackButton: document.getElementById('parameters-back-button'),
                    quizCheckButton: document.getElementById('quiz-check-button'),
                    continueButton: document.getElementById('continue-button'),
                    settingsButton: document.getElementById('settings-button'),
                    helpButton: document.getElementById('help-button'),
                    backButton: document.getElementById('back-button'),
                    settingsCloseButton: document.getElementById('settings-close-button'),
                    helpCloseButton: document.getElementById('help-close-button'),
                    hintButton: document.getElementById('hint-button')
                },
                inputs: {
                    showText: document.getElementById('show-text'),
                    droneCount: document.getElementById('drone-count'),
                    droneSpeed: document.getElementById('drone-speed'),
                    droneCountValue: document.getElementById('drone-count-value'),
                    droneSpeedValue: document.getElementById('drone-speed-value'),
                    
                    // Physics parameters
                    gravityEffect: document.getElementById('gravity-effect'),
                    windEffect: document.getElementById('wind-effect'),
                    bounceEffect: document.getElementById('bounce-effect'),
                    gravityEffectValue: document.getElementById('gravity-effect-value'),
                    windEffectValue: document.getElementById('wind-effect-value'),
                    bounceEffectValue: document.getElementById('bounce-effect-value'),
                    
                    // Visual parameters
                    trailLength: document.getElementById('trail-length'),
                    glowIntensity: document.getElementById('glow-intensity'),
                    pulseRate: document.getElementById('pulse-rate'),
                    trailLengthValue: document.getElementById('trail-length-value'),
                    glowIntensityValue: document.getElementById('glow-intensity-value'),
                    pulseRateValue: document.getElementById('pulse-rate-value'),
                    
                    // Pattern parameters
                    patternSize: document.getElementById('pattern-size'),
                    rotationSpeed: document.getElementById('rotation-speed'),
                    waveEffect: document.getElementById('wave-effect'),
                    patternSizeValue: document.getElementById('pattern-size-value'),
                    rotationSpeedValue: document.getElementById('rotation-speed-value'),
                    waveEffectValue: document.getElementById('wave-effect-value'),
                    
                    // Settings
                    soundToggle: document.getElementById('sound-toggle'),
                    soundVolume: document.getElementById('sound-volume'),
                    musicToggle: document.getElementById('music-toggle'),
                    musicVolume: document.getElementById('music-volume'),
                    tutorialsToggle: document.getElementById('tutorials-toggle'),
                    particlesToggle: document.getElementById('particles-toggle'),
                    soundVolumeValue: document.getElementById('sound-volume-value'),
                    musicVolumeValue: document.getElementById('music-volume-value')
                },
                displays: {
                    patternOptions: document.getElementById('pattern-options'),
                    colorOptions: document.getElementById('color-options'),
                    quizQuestion: document.getElementById('quiz-question'),
                    quizOptions: document.getElementById('quiz-options'),
                    rewardText: document.getElementById('reward-text'),
                    rewardAnimation: document.getElementById('reward-animation'),
                    progressBar: document.getElementById('progress-bar'),
                    scoreDisplay: document.getElementById('score-display'),
                    learningPath: document.getElementById('learning-path'),
                    hintText: document.getElementById('hint-text')
                },
                characters: {
                    professorCharacter: document.getElementById('professor-character'),
                    speechBubble: document.getElementById('speech-bubble')
                },
                canvas: {
                    container: document.getElementById('canvas-container')
                }
            };
        }

        // =====================================
        // DRONE CLASS
        // =====================================
        class Drone {
            constructor(x, y) {
                this.x = x || 0;
                this.y = y || 0;
                this.targetX = x || 0;
                this.targetY = y || 0;
                this.vx = 0;
                this.vy = 0;
                this.speed = gameState.droneSpeed || 5;
                this.color = gameState.droneColor || "#FFFFFF";
                this.radius = 4;
                this.trail = [];
                this.maxTrailLength = gameState.parameters.trailLength || 40;
                this.birthTime = Date.now();
                this.waveOffset = Math.random() * Math.PI * 2;
                this.pulseOffset = Math.random() * Math.PI * 2;
                this.uniqueId = Math.random();
                
                // Add initial position to trail
                this.trail.push({ x: this.x, y: this.y, time: this.birthTime });
            }
            
            update(timestamp) {
                if (isNaN(this.x) || isNaN(this.y) || isNaN(this.targetX) || isNaN(this.targetY)) {
                    console.error("Invalid drone position values:", this);
                    this.x = this.x || 0;
                    this.y = this.y || 0;
                    this.targetX = this.targetX || 0;
                    this.targetY = this.targetY || 0;
                    return;
                }
                
                const now = Date.now();
                const age = (now - this.birthTime) / 1000;
                
                // Calculate distance to target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Apply wave effect
                const waveAmplitude = (gameState.parameters.waveEffect || 5) * 0.5;
                const waveRate = (gameState.parameters.pulseRate || 3) * 0.2;
                const waveX = Math.sin(now / 1000 * waveRate + this.waveOffset) * waveAmplitude;
                const waveY = Math.cos(now / 1000 * waveRate + this.waveOffset) * waveAmplitude;
                
                // Calculate acceleration towards target
                let ax = 0;
                let ay = 0;
                
                if (distance > 1) {
                    const force = 0.2 * this.speed;
                    ax = (dx / distance) * force;
                    ay = (dy / distance) * force;
                }
                
                // Apply physics effects
                
                // Gravity
                ay += (gameState.parameters.gravityEffect || 0) * 0.01;
                
                // Wind
                ax += Math.sin(now / 5000) * (gameState.parameters.windEffect || 0) * 0.01;
                
                // Apply acceleration
                this.vx += ax;
                this.vy += ay;
                
                // Apply damping (air resistance)
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Apply wave effect
                this.vx += waveX * 0.01;
                this.vy += waveY * 0.01;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Apply boundary bounce if enabled
                const bounceEffect = (gameState.parameters.bounceEffect || 5) * 0.1;
                if (bounceEffect > 0) {
                    // Safely get canvas dimensions
                    const canvasWidth = window.innerWidth;
                    const canvasHeight = window.innerHeight;
                    const margin = 50;
                    
                    if (this.x < margin) {
                        this.x = margin;
                        this.vx *= -bounceEffect;
                    } else if (this.x > canvasWidth - margin) {
                        this.x = canvasWidth - margin;
                        this.vx *= -bounceEffect;
                    }
                    
                    if (this.y < margin) {
                        this.y = margin;
                        this.vy *= -bounceEffect;
                    } else if (this.y > canvasHeight - margin) {
                        this.y = canvasHeight - margin;
                        this.vy *= -bounceEffect;
                    }
                }
                
                // Update trail
                this.trail.push({ x: this.x, y: this.y, time: now });
                
                // Remove old trail points
                const maxLength = this.maxTrailLength || 40; // Fallback if undefined
                while (this.trail.length > maxLength) {
                    this.trail.shift();
                }
            }
            
            draw(ctx, timestamp) {
                if (!ctx) {
                    console.error("Canvas context is undefined");
                    return;
                }
                
                const now = Date.now();
                
                // Draw trail with enhanced fade effect
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const point = this.trail[i];
                        const nextPoint = this.trail[i + 1];
                        
                        if (!point || !nextPoint || 
                            isNaN(point.x) || isNaN(point.y) || 
                            isNaN(nextPoint.x) || isNaN(nextPoint.y)) {
                            continue;
                        }
                        
                        // Calculate trail alpha based on age and position
                        const progress = i / (this.trail.length - 1);
                        const age = (now - point.time) / 1000;
                        const alpha = Math.max(0, 1 - progress) * Math.max(0, 1 - age * 0.5);
                        
                        // Calculate pulse effect
                        const pulseRate = (gameState.parameters.pulseRate || 3) * 0.5;
                        const pulse = 0.7 + 0.3 * Math.sin(now / 1000 * pulseRate + this.pulseOffset);
                        
                        // Parse color components
                        let r = 255, g = 255, b = 255;
                        try {
                            if (this.color && this.color.startsWith('#') && this.color.length >= 7) {
                                r = parseInt(this.color.slice(1, 3), 16);
                                g = parseInt(this.color.slice(3, 5), 16);
                                b = parseInt(this.color.slice(5, 7), 16);
                            }
                        } catch (e) {
                            console.error("Error parsing color:", this.color, e);
                        }
                        
                        // Apply pulse to color
                        const pulsedColor = `rgba(${Math.floor(r * pulse)}, ${Math.floor(g * pulse)}, ${Math.floor(b * pulse)}, ${alpha})`;
                        
                        ctx.strokeStyle = pulsedColor;
                        ctx.lineWidth = 2 * (1 - progress);
                        
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(nextPoint.x, nextPoint.y);
                        ctx.stroke();
                    }
                }
                
                // Draw drone with glow effect
                const glowRadius = this.radius * (2 + (gameState.parameters.glowIntensity || 5) * 0.3);
                const pulseRate = (gameState.parameters.pulseRate || 3) * 0.5;
                const pulse = 0.7 + 0.3 * Math.sin(now / 1000 * pulseRate + this.pulseOffset);
                
                // Parse color components with error handling
                let r = 255, g = 255, b = 255;
                try {
                    if (this.color && this.color.startsWith('#') && this.color.length >= 7) {
                        r = parseInt(this.color.slice(1, 3), 16);
                        g = parseInt(this.color.slice(3, 5), 16);
                        b = parseInt(this.color.slice(5, 7), 16);
                    }
                } catch (e) {
                    console.error("Error parsing color:", this.color, e);
                }
                
                // Create gradient for glow
                try {
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, this.radius,
                        this.x, this.y, glowRadius
                    );
                    
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${pulse})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                } catch (e) {
                    console.error("Error creating gradient:", e);
                }
                
                // Draw the drone core
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            setTarget(x, y) {
                this.targetX = x || this.x;
                this.targetY = y || this.y;
            }
        }

        // =====================================
        // PATTERN GENERATOR
        // =====================================
        class PatternGenerator {
            static circle(width, height, count, text = "") {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.3 * (gameState.parameters.patternSize / 5);
                
                if (text && text.length > 0) {
                    // Create text pattern
                    return this.textPattern(width, height, count, text);
                } else {
                    // Create circle pattern
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
            
            static heart(width, height, count, text = "") {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.3 * (gameState.parameters.patternSize / 5);
                
                if (text && text.length > 0) {
                    // Create text pattern
                    return this.textPattern(width, height, count, text);
                } else {
                    // Create heart pattern
                    for (let i = 0; i < count; i++) {
                        const t = (i / count) * Math.PI * 2;
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                        
                        positions.push({
                            x: centerX + x * scale * 0.04,
                            y: centerY - y * scale * 0.04  // Flip y for correct orientation
                        });
                    }
                }
                
                return positions;
            }
            
            static spiral(width, height, count, text = "") {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.3 * (gameState.parameters.patternSize / 5);
                
                if (text && text.length > 0) {
                    // Create text pattern
                    return this.textPattern(width, height, count, text);
                } else {
                    // Create spiral pattern
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * 10 * Math.PI;
                        const radius = (i / count) * scale;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
            
            static star(width, height, count, text = "") {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.3 * (gameState.parameters.patternSize / 5);
                const points = 5; // 5-pointed star
                
                if (text && text.length > 0) {
                    // Create text pattern
                    return this.textPattern(width, height, count, text);
                } else {
                    // Create star pattern
                    for (let i = 0; i < count; i++) {
                        const t = (i / count) * Math.PI * 2;
                        const pointIndex = Math.floor((t / (Math.PI * 2)) * points * 2);
                        const isOuter = pointIndex % 2 === 0;
                        const radius = isOuter ? scale : scale * 0.4;
                        
                        const x = centerX + Math.cos(t) * radius;
                        const y = centerY + Math.sin(t) * radius;
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
            
            static firework(width, height, count, text = "") {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.3 * (gameState.parameters.patternSize / 5);
                
                if (text && text.length > 0) {
                    // Create text pattern
                    return this.textPattern(width, height, count, text);
                } else {
                    // Create firework pattern (radiating lines)
                    const lines = 10;
                    const dronesPerLine = Math.floor(count / lines);
                    
                    for (let line = 0; line < lines; line++) {
                        const angle = (line / lines) * Math.PI * 2;
                        
                        for (let i = 0; i < dronesPerLine; i++) {
                            const distance = (i / dronesPerLine) * scale;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            positions.push({x, y});
                        }
                    }
                    
                    // Add remaining drones in a circle
                    const remaining = count - (lines * dronesPerLine);
                    for (let i = 0; i < remaining; i++) {
                        const angle = (i / remaining) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * (scale * 0.5);
                        const y = centerY + Math.sin(angle) * (scale * 0.5);
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
            
            static zigzag(width, height, count, text = "") {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.3 * (gameState.parameters.patternSize / 5);
                
                if (text && text.length > 0) {
                    // Create text pattern
                    return this.textPattern(width, height, count, text);
                } else {
                    // Create zigzag pattern
                    const cycles = 3;
                    const pointsPerCycle = Math.ceil(count / cycles);
                    
                    for (let i = 0; i < count; i++) {
                        const cycleProgress = (i % pointsPerCycle) / pointsPerCycle;
                        const cycle = Math.floor(i / pointsPerCycle);
                        
                        const x = centerX + (cycleProgress * 2 - 1) * scale;
                        const y = centerY + Math.sin(cycleProgress * Math.PI * 2) * scale * 0.5 - (cycle - cycles / 2) * scale * 0.5;
                        
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
            
            static textPattern(width, height, count, text) {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.05 * (gameState.parameters.patternSize / 5);
                
                // Create an offscreen canvas to render text
                const offscreenCanvas = document.createElement('canvas');
                const context = offscreenCanvas.getContext('2d');
                
                // Set canvas size
                offscreenCanvas.width = width;
                offscreenCanvas.height = height;
                
                // Set text style
                const fontSize = scale * 10;
                context.font = `bold ${fontSize}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Measure text
                const metrics = context.measureText(text);
                const textWidth = metrics.width;
                
                // Draw text
                context.fillText(text, centerX, centerY);
                
                // Sample points from text pixels
                const imageData = context.getImageData(0, 0, width, height);
                const data = imageData.data;
                const threshold = 128;
                
                // Collect all points where text is drawn
                const textPoints = [];
                const sampling = 4; // Sample every few pixels for performance
                
                for (let y = 0; y < height; y += sampling) {
                    for (let x = 0; x < width; x += sampling) {
                        const index = (y * width + x) * 4;
                        const alpha = data[index + 3];
                        
                        if (alpha > threshold) {
                            textPoints.push({x, y});
                        }
                    }
                }
                
                // If not enough text points, create circle as fallback
                if (textPoints.length < count / 2) {
                    return this.circle(width, height, count);
                }
                
                // Sample points evenly from text points
                for (let i = 0; i < count; i++) {
                    const index = Math.floor((i / count) * textPoints.length);
                    if (textPoints[index]) {
                        positions.push(textPoints[index]);
                    } else {
                        // Fallback if index is invalid
                        const angle = (i / count) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * scale * 5;
                        const y = centerY + Math.sin(angle) * scale * 5;
                        positions.push({x, y});
                    }
                }
                
                return positions;
            }
        }

        // =====================================
        // QUIZ GENERATOR
        // =====================================
        class QuizGenerator {
            static generateQuestion(level) {
                const quizTypes = [
                    this.generateCoordinateQuestion,
                    this.generatePatternQuestion,
                    this.generatePhysicsQuestion,
                    this.generateColorQuestion,
                    this.generateMathQuestion
                ];
                
                // Select quiz type based on level
                const quizType = quizTypes[Math.min(level - 1, quizTypes.length - 1)];
                return quizType();
            }
            
            static generateCoordinateQuestion() {
                const questions = [
                    {
                        question: "If a drone is at position (10, 5), which way should it move to reach (5, 5)?",
                        options: ["Left", "Right", "Up", "Down"],
                        answer: "Left"
                    },
                    {
                        question: "In a drone show, which coordinate represents how high the drone flies?",
                        options: ["X", "Y", "Z", "Speed"],
                        answer: "Y"
                    },
                    {
                        question: "If a drone moves from (0, 0) to (10, 10), what direction is it moving?",
                        options: ["Up and Right", "Up and Left", "Down and Right", "Down and Left"],
                        answer: "Up and Right"
                    },
                    {
                        question: "Where is the center of a screen usually located?",
                        options: ["Top left", "Center", "Bottom right", "Top right"],
                        answer: "Center"
                    }
                ];
                
                return questions[Math.floor(Math.random() * questions.length)];
            }
            
            static generatePatternQuestion() {
                const questions = [
                    {
                        question: "What shape has 5 points and is often seen in the sky at night?",
                        options: ["Circle", "Heart", "Star", "Square"],
                        answer: "Star"
                    },
                    {
                        question: "Which pattern makes a swirling shape that gets bigger and bigger?",
                        options: ["Zigzag", "Spiral", "Circle", "Heart"],
                        answer: "Spiral"
                    },
                    {
                        question: "How many sides does a circle have?",
                        options: ["0", "1", "Infinite", "10"],
                        answer: "Infinite"
                    },
                    {
                        question: "What pattern would be best to show fireworks in the sky?",
                        options: ["Circle", "Firework", "Zigzag", "Heart"],
                        answer: "Firework"
                    }
                ];
                
                return questions[Math.floor(Math.random() * questions.length)];
            }
            
            static generatePhysicsQuestion() {
                const questions = [
                    {
                        question: "What pulls objects down toward the ground?",
                        options: ["Wind", "Gravity", "Bounce", "Speed"],
                        answer: "Gravity"
                    },
                    {
                        question: "If a drone moves faster, what happens to its trail?",
                        options: ["Gets shorter", "Gets longer", "Stays the same", "Disappears"],
                        answer: "Gets longer"
                    },
                    {
                        question: "What happens when a drone hits a wall with bounce effect?",
                        options: ["Stops", "Bounces away", "Goes through", "Explodes"],
                        answer: "Bounces away"
                    },
                    {
                        question: "What makes drones move from side to side in the air?",
                        options: ["Gravity", "Wind", "Speed", "Bounce"],
                        answer: "Wind"
                    }
                ];
                
                return questions[Math.floor(Math.random() * questions.length)];
            }
            
            static generateColorQuestion() {
                const questions = [
                    {
                        question: "What colors mix together to make purple?",
                        options: ["Red and Blue", "Red and Green", "Blue and Green", "Yellow and Blue"],
                        answer: "Red and Blue"
                    },
                    {
                        question: "Which color is brightest at night?",
                        options: ["Black", "Purple", "White", "Green"],
                        answer: "White"
                    },
                    {
                        question: "Which set contains all primary colors?",
                        options: ["Red, Yellow, Blue", "Red, Green, Blue", "Cyan, Magenta, Yellow", "Orange, Purple, Green"],
                        answer: "Red, Yellow, Blue"
                    },
                    {
                        question: "If you see a green drone at night, what color is it reflecting?",
                        options: ["Red", "Blue", "Green", "Yellow"],
                        answer: "Green"
                    }
                ];
                
                return questions[Math.floor(Math.random() * questions.length)];
            }
            
            static generateMathQuestion() {
                const questions = [
                    {
                        question: "If there are 10 drones in a circle and 5 more join, how many drones are there?",
                        options: ["10", "15", "5", "20"],
                        answer: "15"
                    },
                    {
                        question: "If you have 20 drones and split them into 4 equal groups, how many drones in each group?",
                        options: ["4", "5", "8", "10"],
                        answer: "5"
                    },
                    {
                        question: "If a drone moves at 5 meters per second, how far does it go in 3 seconds?",
                        options: ["8 meters", "15 meters", "2 meters", "5 meters"],
                        answer: "15 meters"
                    },
                    {
                        question: "If a drone show has 100 drones and 25% of them are red, how many red drones are there?",
                        options: ["25", "50", "75", "100"],
                        answer: "25"
                    }
                ];
                
                return questions[Math.floor(Math.random() * questions.length)];
            }
        }

        // =====================================
        // PROFESSOR CHARACTER
        // =====================================
        class Professor {
            constructor(characterElement, speechBubbleElement) {
                this.characterElement = characterElement;
                this.speechBubbleElement = speechBubbleElement;
                this.messageQueue = [];
                this.messageTimer = null;
                this.isSpeaking = false;
                
                // Create character SVG
                this.drawCharacter();
            }
            
            drawCharacter() {
                const svgHTML = `
                <svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
                    <!-- Body -->
                    <ellipse cx="60" cy="85" rx="25" ry="30" fill="#1E88E5" />
                    
                    <!-- Head -->
                    <circle cx="60" cy="45" r="22" fill="#FFD700" />
                    
                    <!-- Eyes -->
                    <circle cx="52" cy="40" r="4" fill="white" />
                    <circle cx="68" cy="40" r="4" fill="white" />
                    <circle cx="52" cy="40" r="2" fill="black" />
                    <circle cx="68" cy="40" r="2" fill="black" />
                    
                    <!-- Glasses -->
                    <circle cx="52" cy="40" r="6" fill="none" stroke="black" stroke-width="1.5" />
                    <circle cx="68" cy="40" r="6" fill="none" stroke="black" stroke-width="1.5" />
                    <line x1="58" y1="40" x2="62" y2="40" stroke="black" stroke-width="1.5" />
                    <line x1="46" y1="38" x2="42" y2="36" stroke="black" stroke-width="1.5" />
                    <line x1="74" y1="38" x2="78" y2="36" stroke="black" stroke-width="1.5" />
                    
                    <!-- Smile -->
                    <path d="M50,50 Q60,60 70,50" fill="none" stroke="black" stroke-width="1.5" />
                    
                    <!-- Hair -->
                    <path d="M40,35 Q60,15 80,35 Q60,25 40,35" fill="#A0522D" />
                    
                    <!-- Arms -->
                    <line x1="40" y1="75" x2="25" y2="60" stroke="#FFD700" stroke-width="5" stroke-linecap="round" />
                    <line x1="80" y1="75" x2="95" y2="60" stroke="#FFD700" stroke-width="5" stroke-linecap="round" />
                    
                    <!-- Propeller hat -->
                    <rect x="50" y="20" width="20" height="5" fill="#FF5722" />
                    <polygon points="60,5 65,20 55,20" fill="#4CAF50" />
                    <polygon points="60,5 70,15 50,15" fill="#F44336" />
                    <circle cx="60" cy="5" r="2" fill="#FFC107" />
                </svg>
                `;
                
                this.characterElement.innerHTML = svgHTML;
            }
            
            say(message, delay = 0, duration = 5000) {
                // Add message to queue
                this.messageQueue.push({
                    text: message,
                    delay: delay,
                    duration: duration
                });
                
                // Start processing messages if not already speaking
                if (!this.isSpeaking) {
                    this.processNextMessage();
                }
            }
            
            processNextMessage() {
                if (this.messageQueue.length === 0) {
                    this.isSpeaking = false;
                    return;
                }
                
                this.isSpeaking = true;
                const message = this.messageQueue.shift();
                
                // Clear any existing timer
                if (this.messageTimer) {
                    clearTimeout(this.messageTimer);
                }
                
                // Show message after delay
                setTimeout(() => {
                    this.speechBubbleElement.textContent = message.text;
                    this.speechBubbleElement.style.opacity = '1';
                    
                    // Hide message after duration
                    this.messageTimer = setTimeout(() => {
                        this.speechBubbleElement.style.opacity = '0';
                        
                        // Process next message after a short pause
                        setTimeout(() => {
                            this.processNextMessage();
                        }, 500);
                    }, message.duration);
                }, message.delay);
            }
            
            clearMessages() {
                this.messageQueue = [];
                if (this.messageTimer) {
                    clearTimeout(this.messageTimer);
                }
                this.speechBubbleElement.style.opacity = '0';
                this.isSpeaking = false;
            }
        }

        // =====================================
        // AUDIO MANAGER
        // =====================================
        class AudioManager {
            constructor() {
                // Check for AudioContext support
                this.audioContext = null;
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                } catch (e) {
                    console.warn('AudioContext not supported in this browser');
                }
            }
            
            playSound(type) {
                if (!this.audioContext || !gameState.settings.soundEnabled) return;
                
                const volume = gameState.settings.soundVolume / 10;
                
                switch (type) {
                    case 'button':
                        this.playButtonSound(volume);
                        break;
                    case 'select':
                        this.playSelectSound(volume);
                        break;
                    case 'success':
                        this.playSuccessSound(volume);
                        break;
                    case 'error':
                        this.playErrorSound(volume);
                        break;
                    case 'celebration':
                        this.playCelebrationSound(volume);
                        break;
                }
            }
            
            playButtonSound(volume) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }
            
            playSelectSound(volume) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(660, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(volume * 0.5, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            playSuccessSound(volume) {
                if (!this.audioContext) return;
                
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                
                notes.forEach((frequency, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime + index * 0.1);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime + index * 0.1);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.5, this.audioContext.currentTime + index * 0.1 + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + index * 0.1 + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime + index * 0.1);
                    oscillator.stop(this.audioContext.currentTime + index * 0.1 + 0.3);
                });
            }
            
            playErrorSound(volume) {
                if (!this.audioContext) return;
                
                const frequencies = [349.23, 329.63, 311.13]; // F4, E4, D#4/Eb4
                
                frequencies.forEach((frequency, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime + index * 0.15);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime + index * 0.15);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.5, this.audioContext.currentTime + index * 0.15 + 0.01);
                    gainNode.gain.linearRampToValueAtTime(0.001, this.audioContext.currentTime + index * 0.15 + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(this.audioContext.currentTime + index * 0.15);
                    oscillator.stop(this.audioContext.currentTime + index * 0.15 + 0.3);
                });
            }
            
            playCelebrationSound(volume) {
                if (!this.audioContext) return;
                
                // Major scale ascending and then chord
                const notes = [
                    { freq: 523.25, time: 0 },    // C5
                    { freq: 587.33, time: 0.15 }, // D5
                    { freq: 659.25, time: 0.3 },  // E5
                    { freq: 698.46, time: 0.45 }, // F5
                    { freq: 783.99, time: 0.6 },  // G5
                    { freq: 880.00, time: 0.75 }, // A5
                    { freq: 987.77, time: 0.9 },  // B5
                    { freq: 1046.50, time: 1.05 }, // C6
                    // Final chord
                    { freq: 523.25, time: 1.3 }, // C5
                    { freq: 659.25, time: 1.3 }, // E5
                    { freq: 783.99, time: 1.3 }, // G5
                    { freq: 1046.50, time: 1.3 }  // C6
                ];
                
                notes.forEach(note => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, this.audioContext.currentTime + note.time);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime + note.time);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, this.audioContext.currentTime + note.time + 0.01);
                    
                    // Longer sustain for the final chord
                    if (note.time === 1.3) {
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + note.time + 1.0);
                        oscillator.start(this.audioContext.currentTime + note.time);
                        oscillator.stop(this.audioContext.currentTime + note.time + 1.0);
                    } else {
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + note.time + 0.2);
                        oscillator.start(this.audioContext.currentTime + note.time);
                        oscillator.stop(this.audioContext.currentTime + note.time + 0.2);
                    }
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                });
            }
            
            playBackgroundMusic(volume) {
                if (!this.audioContext || !gameState.settings.musicEnabled) return;
                
                if (this.backgroundMusic) {
                    this.stopBackgroundMusic();
                }
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.value = volume * 0.2;
                
                this.backgroundMusic = {
                    oscillators: [],
                    gainNode: gainNode
                };
                
                // Create a simple melody background
                const baseFreq = 261.63; // C4
                const intervals = [0, 4, 7, 12, 7, 4]; // C major chord pattern
                const durations = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0];
                
                intervals.forEach((interval, index) => {
                    setTimeout(() => {
                        if (!this.backgroundMusic) return;
                        
                        const osc = this.audioContext.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = baseFreq * Math.pow(2, interval / 12);
                        
                        const oscGain = this.audioContext.createGain();
                        oscGain.gain.value = 0;
                        oscGain.gain.linearRampToValueAtTime(volume * 0.1, this.audioContext.currentTime + 0.1);
                        oscGain.gain.linearRampToValueAtTime(volume * 0.05, this.audioContext.currentTime + durations[index] - 0.2);
                        oscGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + durations[index]);
                        
                        osc.connect(oscGain);
                        oscGain.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + durations[index]);
                        
                        this.backgroundMusic.oscillators.push({
                            osc: osc,
                            gain: oscGain
                        });
                        
                        // Loop the music if it's the last note
                        if (index === intervals.length - 1) {
                            setTimeout(() => {
                                if (this.backgroundMusic) {
                                    this.playBackgroundMusic(volume);
                                }
                            }, durations[index] * 1000);
                        }
                    }, index * 2000);
                });
            }
            
            stopBackgroundMusic() {
                if (!this.backgroundMusic) return;
                
                this.backgroundMusic.oscillators.forEach(osc => {
                    try {
                        osc.osc.stop();
                    } catch (e) {
                        // Oscillator may already be stopped
                    }
                });
                
                this.backgroundMusic.gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.5);
                this.backgroundMusic = null;
            }
            
            updateVolume() {
                if (this.backgroundMusic) {
                    const volume = gameState.settings.musicEnabled ? gameState.settings.musicVolume / 10 : 0;
                    this.backgroundMusic.gainNode.gain.linearRampToValueAtTime(volume * 0.2, this.audioContext.currentTime + 0.5);
                }
            }
        }

        // =====================================
        // PARTICLE EFFECTS
        // =====================================
        class ParticleEffects {
            static createParticleEffect(type, x, y, count = 30) {
                if (!gameState.settings.particlesEnabled) return;
                
                // Clear any existing particles
                this.clearParticles();
                
                switch (type) {
                    case 'celebration':
                        this.createCelebrationEffect(x, y, count);
                        break;
                    case 'success':
                        this.createSuccessEffect(x, y, count);
                        break;
                    case 'error':
                        this.createErrorEffect(x, y, count);
                        break;
                }
            }
            
            static createCelebrationEffect(x, y, count) {
                // Create stars and confetti
                for (let i = 0; i < count; i++) {
                    const isConfetti = Math.random() < 0.5;
                    
                    if (isConfetti) {
                        this.createConfetti(x, y);
                    } else {
                        this.createStar(x, y);
                    }
                }
                
                // Create some bubbles too
                for (let i = 0; i < count / 2; i++) {
                    this.createBubble(x, y);
                }
            }
            
            static createSuccessEffect(x, y, count) {
                // Create stars
                for (let i = 0; i < count; i++) {
                    this.createStar(x, y);
                }
            }
            
            static createErrorEffect(x, y, count) {
                // Create red particles
                for (let i = 0; i < count; i++) {
                    this.createErrorParticle(x, y);
                }
            }
            
            static createStar(x, y) {
                const container = document.getElementById('game-container');
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random position offset
                const offsetX = (Math.random() - 0.5) * 50;
                const offsetY = (Math.random() - 0.5) * 50;
                const posX = x + offsetX;
                const posY = y + offsetY;
                
                // Random size
                const size = Math.random() * 30 + 10;
                
                // Star SVG
                star.innerHTML = `
                    <svg width="${size}" height="${size}" viewBox="0 0 51 48">
                        <path fill="#FFD700" d="m25,1 6,17h18l-14,11 5,17-15-10-15,10 5-17-14-11h18z"/>
                    </svg>
                `;
                
                star.style.left = `${posX}px`;
                star.style.top = `${posY}px`;
                container.appendChild(star);
                
                // Animation
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;
                
                let opacity = 1;
                let currentPosX = posX;
                let currentPosY = posY;
                
                const animation = setInterval(() => {
                    opacity -= 0.01;
                    currentPosX += dx;
                    currentPosY += dy;
                    
                    star.style.opacity = opacity;
                    star.style.left = `${currentPosX}px`;
                    star.style.top = `${currentPosY}px`;
                    
                    if (opacity <= 0) {
                        clearInterval(animation);
                        if (star.parentNode) {
                            star.parentNode.removeChild(star);
                        }
                    }
                }, 20);
                
                gameState.animations.stars.push(star);
                gameState.animations.timers.push(animation);
            }
            
            static createBubble(x, y) {
                const container = document.getElementById('game-container');
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                
                // Random position offset
                const offsetX = (Math.random() - 0.5) * 100;
                const posX = x + offsetX;
                const posY = y + 50; // Start below the point
                
                // Random size
                const size = Math.random() * 40 + 20;
                
                // Random color
                const colors = ['#FF9A00', '#4b0082', '#4CAF50', '#f44336', '#2196F3'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                bubble.style.backgroundColor = color;
                bubble.style.left = `${posX}px`;
                bubble.style.top = `${posY}px`;
                bubble.style.opacity = '0.7';
                container.appendChild(bubble);
                
                // Animation
                const speed = Math.random() * 3 + 1;
                let currentPosY = posY;
                
                const animation = setInterval(() => {
                    currentPosY -= speed;
                    bubble.style.top = `${currentPosY}px`;
                    
                    if (currentPosY < -size) {
                        clearInterval(animation);
                        if (bubble.parentNode) {
                            bubble.parentNode.removeChild(bubble);
                        }
                    }
                }, 20);
                
                gameState.animations.bubbles.push(bubble);
                gameState.animations.timers.push(animation);
            }
            
            static createConfetti(x, y) {
                const container = document.getElementById('game-container');
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random position offset
                const offsetX = (Math.random() - 0.5) * 50;
                const offsetY = (Math.random() - 0.5) * 50;
                const posX = x + offsetX;
                const posY = y + offsetY;
                
                // Random size
                const width = Math.random() * 10 + 5;
                const height = Math.random() * 10 + 5;
                
                // Random color
                const colors = ['#FF9A00', '#4b0082', '#4CAF50', '#f44336', '#2196F3', '#e91e63', '#9c27b0'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                confetti.style.width = `${width}px`;
                confetti.style.height = `${height}px`;
                confetti.style.backgroundColor = color;
                confetti.style.left = `${posX}px`;
                confetti.style.top = `${posY}px`;
                container.appendChild(confetti);
                
                // Animation
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed + 2; // Add gravity
                let rotation = 0;
                const rotationSpeed = Math.random() * 10 - 5;
                
                let opacity = 1;
                let currentPosX = posX;
                let currentPosY = posY;
                
                const animation = setInterval(() => {
                    opacity -= 0.005;
                    currentPosX += dx;
                    currentPosY += dy;
                    rotation += rotationSpeed;
                    
                    confetti.style.opacity = opacity;
                    confetti.style.left = `${currentPosX}px`;
                    confetti.style.top = `${currentPosY}px`;
                    confetti.style.transform = `rotate(${rotation}deg)`;
                    
                    if (opacity <= 0 || currentPosY > window.innerHeight) {
                        clearInterval(animation);
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }
                }, 20);
                
                gameState.animations.confetti.push(confetti);
                gameState.animations.timers.push(animation);
            }
            
            static createErrorParticle(x, y) {
                const container = document.getElementById('game-container');
                const particle = document.createElement('div');
                particle.className = 'confetti';
                
                // Random position offset
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = (Math.random() - 0.5) * 30;
                const posX = x + offsetX;
                const posY = y + offsetY;
                
                // Random size
                const size = Math.random() * 8 + 3;
                
                // Red color variations
                const redValues = ['#f44336', '#e53935', '#d32f2f', '#c62828', '#b71c1c'];
                const color = redValues[Math.floor(Math.random() * redValues.length)];
                
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.backgroundColor = color;
                particle.style.left = `${posX}px`;
                particle.style.top = `${posY}px`;
                particle.style.borderRadius = '50%';
                container.appendChild(particle);
                
                // Animation
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;
                
                let opacity = 1;
                let currentPosX = posX;
                let currentPosY = posY;
                
                const animation = setInterval(() => {
                    opacity -= 0.02;
                    currentPosX += dx;
                    currentPosY += dy;
                    
                    particle.style.opacity = opacity;
                    particle.style.left = `${currentPosX}px`;
                    particle.style.top = `${currentPosY}px`;
                    
                    if (opacity <= 0) {
                        clearInterval(animation);
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }
                }, 20);
                
                gameState.animations.confetti.push(particle);
                gameState.animations.timers.push(animation);
            }
            
            static clearParticles() {
                // Clear all animation timers
                gameState.animations.timers.forEach(timer => {
                    clearInterval(timer);
                });
                
                // Remove all stars, bubbles, and confetti
                gameState.animations.stars.forEach(star => {
                    if (star.parentNode) {
                        star.parentNode.removeChild(star);
                    }
                });
                
                gameState.animations.bubbles.forEach(bubble => {
                    if (bubble.parentNode) {
                        bubble.parentNode.removeChild(bubble);
                    }
                });
                
                gameState.animations.confetti.forEach(confetti => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                });
                
                // Reset arrays
                gameState.animations.stars = [];
                gameState.animations.bubbles = [];
                gameState.animations.confetti = [];
                gameState.animations.timers = [];
            }
        }

        // =====================================
        // DRONE SHOW MANAGER
        // =====================================
        class DroneShowManager {
            constructor(canvasContainer) {
                this.canvasContainer = canvasContainer;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.drones = [];
                this.isRunning = false;
                this.lastTimestamp = 0;
                this.animationFrameId = null;
                
                // Initialize canvas
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.canvas.style.position = "absolute";
                this.canvas.style.top = "0";
                this.canvas.style.left = "0";
                this.canvas.style.zIndex = "0";
                
                // Add canvas to container
                if (this.canvasContainer) {
                    this.canvasContainer.innerHTML = ''; // Clear container
                    this.canvasContainer.appendChild(this.canvas);
                    console.log("Canvas added to container");
                } else {
                    console.error("Canvas container element not found!");
                }
                
                // Handle window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                console.log("DroneShowManager initialized");
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            createDrones() {
                this.drones = [];
                const count = gameState.droneCount;
                
                for (let i = 0; i < count; i++) {
                    // Start drones at random positions
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    this.drones.push(new Drone(x, y));
                }
                console.log(`Created ${this.drones.length} drones`);
            }
            
            updateDronePositions() {
                const pattern = gameState.pattern;
                const text = gameState.text;
                
                // Get pattern positions
                let positions;
                switch (pattern) {
                    case 'circle':
                        positions = PatternGenerator.circle(this.canvas.width, this.canvas.height, this.drones.length, text);
                        break;
                    case 'heart':
                        positions = PatternGenerator.heart(this.canvas.width, this.canvas.height, this.drones.length, text);
                        break;
                    case 'spiral':
                        positions = PatternGenerator.spiral(this.canvas.width, this.canvas.height, this.drones.length, text);
                        break;
                    case 'star':
                        positions = PatternGenerator.star(this.canvas.width, this.canvas.height, this.drones.length, text);
                        break;
                    case 'firework':
                        positions = PatternGenerator.firework(this.canvas.width, this.canvas.height, this.drones.length, text);
                        break;
                    case 'zigzag':
                        positions = PatternGenerator.zigzag(this.canvas.width, this.canvas.height, this.drones.length, text);
                        break;
                    default:
                        positions = PatternGenerator.circle(this.canvas.width, this.canvas.height, this.drones.length, text);
                }
                
                // Apply pattern rotation
                const rotationSpeed = gameState.parameters.rotationSpeed * 0.005;
                const time = Date.now() / 1000;
                const angle = time * rotationSpeed;
                
                if (rotationSpeed > 0) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    positions.forEach(pos => {
                        // Translate point to origin
                        const x = pos.x - centerX;
                        const y = pos.y - centerY;
                        
                        // Rotate point
                        const rotatedX = x * Math.cos(angle) - y * Math.sin(angle);
                        const rotatedY = x * Math.sin(angle) + y * Math.cos(angle);
                        
                        // Translate point back
                        pos.x = rotatedX + centerX;
                        pos.y = rotatedY + centerY;
                    });
                }
                
                // Update drone targets
                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                    }
                });
            }
            
            update(timestamp) {
                const deltaTime = timestamp - this.lastTimestamp;
                this.lastTimestamp = timestamp;
                
                // Update drone targets
                this.updateDronePositions();
                
                // Update drones
                this.drones.forEach(drone => {
                    drone.update(timestamp);
                });
                
                // Clear canvas with fade effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw drones
                this.drones.forEach(drone => {
                    drone.draw(this.ctx, timestamp);
                });
                
                // Continue animation loop
                if (this.isRunning) {
                    this.animationFrameId = requestAnimationFrame(timestamp => this.update(timestamp));
                }
            }
            
            start() {
                if (!this.isRunning) {
                    console.log("Starting drone show");
                    this.isRunning = true;
                    this.lastTimestamp = performance.now();
                    this.createDrones();
                    this.animationFrameId = requestAnimationFrame(timestamp => this.update(timestamp));
                }
            }
            
            stop() {
                this.isRunning = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                console.log("Drone show stopped");
            }
            
            reset() {
                this.stop();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drones = [];
                console.log("Drone show reset");
            }
        }

        // =====================================
        // INITIALIZATION
        // =====================================

        // Canvas & Context
        let canvas, ctx;
        let droneShowManager;
        let professor;
        let audioManager;

        // Initialize game
        function initGame() {
            // Initialize element references
            initElements();
            
            // Create professor character
            professor = new Professor(
                elements.characters.professorCharacter,
                elements.characters.speechBubble
            );
            
            // Create audio manager
            audioManager = new AudioManager();
            
            // Create drone show manager
            droneShowManager = new DroneShowManager(elements.canvas.container);
            
            // Create learning path segments
            createLearningPath();
            
            // Initialize pattern options
            initPatternOptions();
            
            // Initialize color options
            initColorOptions();
            
            // Initialize input sliders
            initSliders();
            
            // Initialize settings
            initSettings();
            
            // Add event listeners
            addEventListeners();
            
            // Show welcome message
            professor.say("Welcome to Drone Show Explorer! I'm Professor Droney, and I'll be your guide. Click 'Start the Adventure' to begin!", 1000, 8000);
            
            // Start background music
            if (gameState.settings.musicEnabled) {
                audioManager.playBackgroundMusic(gameState.settings.musicVolume / 10);
            }
        }

        // Create learning path
        function createLearningPath() {
            const pathContainer = elements.displays.learningPath;
            pathContainer.innerHTML = '';
            
            // Create segments for each level
            for (let i = 0; i < gameState.maxLevel; i++) {
                const segment = document.createElement('div');
                segment.className = 'path-segment';
                segment.setAttribute('data-level', i + 1);
                pathContainer.appendChild(segment);
            }
            
            // Update path display
            updateLearningPath();
        }

        // Update learning path display
        function updateLearningPath() {
            const segments = elements.displays.learningPath.querySelectorAll('.path-segment');
            
            segments.forEach((segment, index) => {
                const level = index + 1;
                
                if (level < gameState.currentLevel) {
                    segment.className = 'path-segment completed';
                } else if (level === gameState.currentLevel) {
                    segment.className = 'path-segment current';
                } else {
                    segment.className = 'path-segment';
                }
            });
        }

        // Initialize pattern options
        function initPatternOptions() {
            const patternOptions = elements.displays.patternOptions.querySelectorAll('.pattern-option');
            
            patternOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Clear previous selections
                    patternOptions.forEach(opt => opt.classList.remove('selected'));
                    
                    // Select the clicked option
                    option.classList.add('selected');
                    
                    // Store the selected pattern
                    gameState.pattern = option.getAttribute('data-pattern');
                    
                    // Play select sound
                    audioManager.playSound('select');
                });
                
                // Set initial selection
                if (option.getAttribute('data-pattern') === gameState.pattern) {
                    option.classList.add('selected');
                }
            });
        }

        // Initialize color options
        function initColorOptions() {
            const colorOptions = elements.displays.colorOptions.querySelectorAll('.color-option');
            
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Clear previous selections
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    
                    // Select the clicked option
                    option.classList.add('selected');
                    
                    // Store the selected color
                    gameState.droneColor = option.getAttribute('data-color');
                    
                    // Play select sound
                    audioManager.playSound('select');
                });
            });
        }

        // Initialize sliders
        function initSliders() {
            // Main sliders
            elements.inputs.droneCount.addEventListener('input', () => {
                const value = elements.inputs.droneCount.value;
                elements.inputs.droneCountValue.textContent = value;
                gameState.droneCount = parseInt(value);
            });
            
            elements.inputs.droneSpeed.addEventListener('input', () => {
                const value = elements.inputs.droneSpeed.value;
                elements.inputs.droneSpeedValue.textContent = value;
                gameState.droneSpeed = parseInt(value);
            });
            
            // Physics parameters
            elements.inputs.gravityEffect.addEventListener('input', () => {
                const value = elements.inputs.gravityEffect.value;
                elements.inputs.gravityEffectValue.textContent = value;
                gameState.parameters.gravityEffect = parseInt(value);
            });
            
            elements.inputs.windEffect.addEventListener('input', () => {
                const value = elements.inputs.windEffect.value;
                elements.inputs.windEffectValue.textContent = value;
                gameState.parameters.windEffect = parseInt(value);
            });
            
            elements.inputs.bounceEffect.addEventListener('input', () => {
                const value = elements.inputs.bounceEffect.value;
                elements.inputs.bounceEffectValue.textContent = value;
                gameState.parameters.bounceEffect = parseInt(value);
            });
            
            // Visual parameters
            elements.inputs.trailLength.addEventListener('input', () => {
                const value = elements.inputs.trailLength.value;
                elements.inputs.trailLengthValue.textContent = value;
                gameState.parameters.trailLength = parseInt(value);
            });
            
            elements.inputs.glowIntensity.addEventListener('input', () => {
                const value = elements.inputs.glowIntensity.value;
                elements.inputs.glowIntensityValue.textContent = value;
                gameState.parameters.glowIntensity = parseInt(value);
            });
            
            elements.inputs.pulseRate.addEventListener('input', () => {
                const value = elements.inputs.pulseRate.value;
                elements.inputs.pulseRateValue.textContent = value;
                gameState.parameters.pulseRate = parseInt(value);
            });
            
            // Pattern parameters
            elements.inputs.patternSize.addEventListener('input', () => {
                const value = elements.inputs.patternSize.value;
                elements.inputs.patternSizeValue.textContent = value;
                gameState.parameters.patternSize = parseInt(value);
            });
            
            elements.inputs.rotationSpeed.addEventListener('input', () => {
                const value = elements.inputs.rotationSpeed.value;
                elements.inputs.rotationSpeedValue.textContent = value;
                gameState.parameters.rotationSpeed = parseInt(value);
            });
            
            elements.inputs.waveEffect.addEventListener('input', () => {
                const value = elements.inputs.waveEffect.value;
                elements.inputs.waveEffectValue.textContent = value;
                gameState.parameters.waveEffect = parseInt(value);
            });
            
            // Settings sliders
            elements.inputs.soundVolume.addEventListener('input', () => {
                const value = elements.inputs.soundVolume.value;
                elements.inputs.soundVolumeValue.textContent = value;
                gameState.settings.soundVolume = parseInt(value);
            });
            
            elements.inputs.musicVolume.addEventListener('input', () => {
                const value = elements.inputs.musicVolume.value;
                elements.inputs.musicVolumeValue.textContent = value;
                gameState.settings.musicVolume = parseInt(value);
                audioManager.updateVolume();
            });
            
            // Set initial values
            elements.inputs.droneCountValue.textContent = gameState.droneCount;
            elements.inputs.droneSpeedValue.textContent = gameState.droneSpeed;
            elements.inputs.gravityEffectValue.textContent = gameState.parameters.gravityEffect;
            elements.inputs.windEffectValue.textContent = gameState.parameters.windEffect;
            elements.inputs.bounceEffectValue.textContent = gameState.parameters.bounceEffect;
            elements.inputs.trailLengthValue.textContent = gameState.parameters.trailLength;
            elements.inputs.glowIntensityValue.textContent = gameState.parameters.glowIntensity;
            elements.inputs.pulseRateValue.textContent = gameState.parameters.pulseRate;
            elements.inputs.patternSizeValue.textContent = gameState.parameters.patternSize;
            elements.inputs.rotationSpeedValue.textContent = gameState.parameters.rotationSpeed;
            elements.inputs.waveEffectValue.textContent = gameState.parameters.waveEffect;
            elements.inputs.soundVolumeValue.textContent = gameState.settings.soundVolume;
            elements.inputs.musicVolumeValue.textContent = gameState.settings.musicVolume;
        }

        // Initialize settings
        function initSettings() {
            // Toggle settings
            elements.inputs.soundToggle.addEventListener('change', () => {
                gameState.settings.soundEnabled = elements.inputs.soundToggle.checked;
            });
            
            elements.inputs.musicToggle.addEventListener('change', () => {
                gameState.settings.musicEnabled = elements.inputs.musicToggle.checked;
                
                if (gameState.settings.musicEnabled) {
                    audioManager.playBackgroundMusic(gameState.settings.musicVolume / 10);
                } else {
                    audioManager.stopBackgroundMusic();
                }
            });
            
            elements.inputs.tutorialsToggle.addEventListener('change', () => {
                gameState.settings.tutorialsEnabled = elements.inputs.tutorialsToggle.checked;
            });
            
            elements.inputs.particlesToggle.addEventListener('change', () => {
                gameState.settings.particlesEnabled = elements.inputs.particlesToggle.checked;
            });
            
            // Set initial values
            elements.inputs.soundToggle.checked = gameState.settings.soundEnabled;
            elements.inputs.musicToggle.checked = gameState.settings.musicEnabled;
            elements.inputs.tutorialsToggle.checked = gameState.settings.tutorialsEnabled;
            elements.inputs.particlesToggle.checked = gameState.settings.particlesEnabled;
        }

        // =====================================
        // EVENT LISTENERS
        // =====================================
        function addEventListeners() {
            // Start button
            elements.buttons.startButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('selectionScreen');
                
                // Show tutorial for beginners
                if (gameState.settings.tutorialsEnabled) {
                    professor.say("Let's create an amazing drone show! Type some text, choose a pattern, and adjust the settings to design your own show!", 500, 8000);
                }
            });
            
            // Advanced button
            elements.buttons.advancedButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('parametersScreen');
                
                // Show tutorial for advanced parameters
                if (gameState.settings.tutorialsEnabled) {
                    professor.say("These advanced settings let you control the physics and appearance of your drone show. Try adjusting them to see how they affect your drones!", 500, 8000);
                }
            });
            
            // Parameters back button
            elements.buttons.parametersBackButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('selectionScreen');
            });
            
            // Start show button
            elements.buttons.startShowButton.addEventListener('click', () => {
                audioManager.playSound('button');
                
                // Get text from input
                gameState.text = elements.inputs.showText.value.trim();
                
                // Update drone settings
                gameState.droneCount = parseInt(elements.inputs.droneCount.value);
                gameState.droneSpeed = parseInt(elements.inputs.droneSpeed.value);
                
                // Make sure game screen exists
                if (!elements.screens.gameScreen) {
                    console.error("Game screen not found!");
                    return;
                }
                
                // Start the drone show
                showScreen('gameScreen');
                
                // Ensure canvas is properly recreated
                if (!elements.canvas.container) {
                    console.error("Canvas container not found!");
                    return;
                }
                
                // Reset and start the drone show
                console.log("Starting drone show...");
                droneShowManager.reset();
                setTimeout(() => {
                    droneShowManager.start();
                    console.log("Drone show started");
                }, 100);
                
                // Update UI
                updateProgress(0);
                updateScore();
                
                // Show tutorial
                if (gameState.settings.tutorialsEnabled) {
                    professor.say("Your drone show is starting! Watch how the drones form patterns in the air. When you're ready, I'll test your knowledge with a quiz!", 500, 8000);
                }
                
                // Show quiz after delay
                setTimeout(() => {
                    showQuiz();
                }, 15000);
            });
            
            // Quiz check button
            elements.buttons.quizCheckButton.addEventListener('click', () => {
                audioManager.playSound('button');
                checkQuizAnswer();
            });
            
            // Continue button
            elements.buttons.continueButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('selectionScreen');
                droneShowManager.reset();
                
                // Show tutorial
                if (gameState.settings.tutorialsEnabled) {
                    professor.say("Great job! Now you can create another drone show with new patterns and settings!", 500, 5000);
                }
            });
            
            // Settings button
            elements.buttons.settingsButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('settingsScreen');
            });
            
            // Help button
            elements.buttons.helpButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('helpScreen');
            });
            
            // Settings close button
            elements.buttons.settingsCloseButton.addEventListener('click', () => {
                audioManager.playSound('button');
                hideScreen('settingsScreen');
            });
            
            // Help close button
            elements.buttons.helpCloseButton.addEventListener('click', () => {
                audioManager.playSound('button');
                hideScreen('helpScreen');
            });
            
            // Back button
            elements.buttons.backButton.addEventListener('click', () => {
                audioManager.playSound('button');
                showScreen('selectionScreen');
                droneShowManager.reset();
            });
            
            // Hint button
            elements.buttons.hintButton.addEventListener('click', () => {
                audioManager.playSound('button');
                toggleHint();
            });
            
            // Text input events
            elements.inputs.showText.addEventListener('input', () => {
                // Update preview or provide feedback
                if (elements.inputs.showText.value.length > 15) {
                    elements.inputs.showText.value = elements.inputs.showText.value.slice(0, 15);
                }
            });
        }

        // =====================================
        // GAME FUNCTIONS
        // =====================================
        function showScreen(screenName) {
            // Check if screen exists
            if (!elements.screens[screenName]) {
                console.error(`Screen ${screenName} not found`);
                return;
            }
            
            // Hide all screens
            Object.keys(elements.screens).forEach(screen => {
                if (elements.screens[screen]) {
                    elements.screens[screen].classList.remove('visible');
                    elements.screens[screen].classList.add('hidden');
                }
            });
            
            // Show the requested screen
            elements.screens[screenName].classList.remove('hidden');
            elements.screens[screenName].classList.add('visible');
            
            // Show/hide back button based on screen
            if (screenName === 'gameScreen') {
                elements.buttons.backButton.style.display = 'flex';
            } else {
                elements.buttons.backButton.style.display = 'none';
            }
        }

        function hideScreen(screenName) {
            // Check if screen exists
            if (!elements.screens[screenName]) {
                console.error(`Screen ${screenName} not found`);
                return;
            }
            
            elements.screens[screenName].classList.remove('visible');
            elements.screens[screenName].classList.add('hidden');
        }

        function updateProgress(value) {
            if (!elements.displays.progressBar) {
                console.error("Progress bar element not found");
                return;
            }
            
            gameState.progress = value;
            elements.displays.progressBar.style.width = `${value * 100}%`;
        }

        function updateScore() {
            if (!elements.displays.scoreDisplay) {
                console.error("Score display element not found");
                return;
            }
            
            elements.displays.scoreDisplay.textContent = `Score: ${gameState.score}`;
        }

        function toggleHint() {
            if (!elements.displays.hintText) {
                console.error("Hint text element not found");
                return;
            }
            
            const hintText = elements.displays.hintText;
            
            if (hintText.style.opacity === '1') {
                hintText.style.opacity = '0';
            } else {
                hintText.style.opacity = '1';
                
                // Set hint text based on current state
                if (elements.screens.quizScreen && elements.screens.quizScreen.classList.contains('visible')) {
                    hintText.textContent = "Think about what you've learned about drones and patterns!";
                } else if (elements.screens.selectionScreen && elements.screens.selectionScreen.classList.contains('visible')) {
                    hintText.textContent = "Try different patterns and colors to see how they affect your show!";
                } else if (elements.screens.parametersScreen && elements.screens.parametersScreen.classList.contains('visible')) {
                    hintText.textContent = "Experiment with these values to create unique effects!";
                } else {
                    hintText.textContent = "Click on the buttons to explore different features!";
                }
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    hintText.style.opacity = '0';
                }, 5000);
            }
        }

        function showQuiz() {
            // Generate quiz question
            const quiz = QuizGenerator.generateQuestion(gameState.currentLevel);
            gameState.currentQuiz = {
                question: quiz.question,
                options: quiz.options,
                correctAnswer: quiz.answer,
                userAnswer: ""
            };
            
            // Display quiz
            elements.displays.quizQuestion.textContent = quiz.question;
            
            // Create options
            elements.displays.quizOptions.innerHTML = '';
            quiz.options.forEach(option => {
                const optionElement = document.createElement('div');
                optionElement.className = 'quiz-option';
                optionElement.textContent = option;
                optionElement.addEventListener('click', () => {
                    selectQuizOption(optionElement);
                });
                elements.displays.quizOptions.appendChild(optionElement);
            });
            
            // Show quiz screen
            showScreen('quizScreen');
            
            // Show hint
            if (gameState.settings.tutorialsEnabled) {
                professor.say("Time to test your knowledge! Choose the correct answer and click 'Check Answer'.", 500, 5000);
            }
        }

        function selectQuizOption(optionElement) {
            // Clear any previous selections
            const options = elements.displays.quizOptions.querySelectorAll('.quiz-option');
            options.forEach(option => {
                option.classList.remove('selected');
            });
            
            // Select the clicked option
            optionElement.classList.add('selected');
            
            // Store user's answer
            gameState.currentQuiz.userAnswer = optionElement.textContent;
            
            // Play select sound
            audioManager.playSound('select');
        }

        function checkQuizAnswer() {
            if (!gameState.currentQuiz.userAnswer) {
                // No answer selected
                professor.say("Please select an answer first!", 0, 3000);
                return;
            }
            
            // Check if the answer is correct
            if (gameState.currentQuiz.userAnswer === gameState.currentQuiz.correctAnswer) {
                // Correct answer
                audioManager.playSound('success');
                ParticleEffects.createParticleEffect('success', window.innerWidth / 2, window.innerHeight / 2);
                
                // Show celebration message
                professor.say("Excellent! That's correct!", 0, 3000);
                
                // Increment score
                gameState.score++;
                updateScore();
                
                // Progress to next level if appropriate
                if (gameState.currentLevel < gameState.maxLevel) {
                    gameState.currentLevel++;
                    updateLearningPath();
                }
                
                // Show reward screen
                setTimeout(() => {
                    showReward();
                }, 2000);
            } else {
                // Incorrect answer
                audioManager.playSound('error');
                ParticleEffects.createParticleEffect('error', window.innerWidth / 2, window.innerHeight / 2);
                
                // Show hint message
                professor.say(`Not quite. The correct answer is ${gameState.currentQuiz.correctAnswer}.`, 0, 4000);
                
                // Highlight correct answer
                const options = elements.displays.quizOptions.querySelectorAll('.quiz-option');
                options.forEach(option => {
                    if (option.textContent === gameState.currentQuiz.correctAnswer) {
                        option.classList.add('correct');
                    } else if (option.classList.contains('selected')) {
                        option.classList.add('incorrect');
                    }
                });
                
                // Show reward screen after delay
                setTimeout(() => {
                    showReward();
                }, 3000);
            }
        }

        function showReward() {
            // Show reward screen
            showScreen('rewardScreen');
            
            // Set reward text based on score and level
            if (gameState.score >= gameState.currentLevel * 2) {
                elements.displays.rewardText.textContent = "Amazing! You're a Drone Master!";
            } else if (gameState.score >= gameState.currentLevel) {
                elements.displays.rewardText.textContent = "Great job! You're learning quickly!";
            } else {
                elements.displays.rewardText.textContent = "Good effort! Keep practicing to master drone shows!";
            }
            
            // Create reward animation
            createRewardAnimation();
            
            // Play celebration sound
            audioManager.playSound('celebration');
            
            // Create celebration particles
            ParticleEffects.createParticleEffect('celebration', window.innerWidth / 2, window.innerHeight / 2, 50);
        }

        function createRewardAnimation() {
            const container = elements.displays.rewardAnimation;
            
            // Clear container
            container.innerHTML = '';
            
            // Create animation SVG
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute("viewBox", "0 0 200 200");
            
            // Create trophy
            const trophy = document.createElementNS("http://www.w3.org/2000/svg", "g");
            
            // Trophy cup
            const cup = document.createElementNS("http://www.w3.org/2000/svg", "path");
            cup.setAttribute("d", "M70,50 L130,50 Q150,50 150,70 Q150,100 130,100 Q115,110 115,130 L85,130 Q85,110 70,100 Q50,100 50,70 Q50,50 70,50");
            cup.setAttribute("fill", "#FFD700");
            trophy.appendChild(cup);
            
            // Trophy base
            const base1 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            base1.setAttribute("x", "75");
            base1.setAttribute("y", "130");
            base1.setAttribute("width", "50");
            base1.setAttribute("height", "10");
            base1.setAttribute("fill", "#A67C00");
            trophy.appendChild(base1);
            
            const base2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            base2.setAttribute("x", "65");
            base2.setAttribute("y", "140");
            base2.setAttribute("width", "70");
            base2.setAttribute("height", "10");
            base2.setAttribute("fill", "#8D6E00");
            trophy.appendChild(base2);
            
            // Add stars around the trophy
            for (let i = 0; i < 5; i++) {
                const star = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const angle = (i / 5) * Math.PI * 2;
                const centerX = 100 + Math.cos(angle) * 70;
                const centerY = 100 + Math.sin(angle) * 70;
                
                star.setAttribute("d", `M${centerX},${centerY-10} L${centerX+3},${centerY-3} L${centerX+10},${centerY-3} L${centerX+5},${centerY+3} L${centerX+7},${centerY+10} L${centerX},${centerY+5} L${centerX-7},${centerY+10} L${centerX-5},${centerY+3} L${centerX-10},${centerY-3} L${centerX-3},${centerY-3} Z`);
                star.setAttribute("fill", "#FFD700");
                
                // Add star animation
                const animateTransform = document.createElementNS("http://www.w3.org/2000/svg", "animateTransform");
                animateTransform.setAttribute("attributeName", "transform");
                animateTransform.setAttribute("type", "rotate");
                animateTransform.setAttribute("from", `0 ${centerX} ${centerY}`);
                animateTransform.setAttribute("to", `360 ${centerX} ${centerY}`);
                animateTransform.setAttribute("dur", "3s");
                animateTransform.setAttribute("repeatCount", "indefinite");
                
                star.appendChild(animateTransform);
                trophy.appendChild(star);
            }
            
            // Add to SVG
            svg.appendChild(trophy);
            
            // Add animation
            const animateTransform = document.createElementNS("http://www.w3.org/2000/svg", "animateTransform");
            animateTransform.setAttribute("attributeName", "transform");
            animateTransform.setAttribute("type", "scale");
            animateTransform.setAttribute("values", "0.5; 1.2; 1");
            animateTransform.setAttribute("dur", "1.5s");
            animateTransform.setAttribute("begin", "0s");
            animateTransform.setAttribute("fill", "freeze");
            
            trophy.appendChild(animateTransform);
            
            // Add to container
            container.appendChild(svg);
        }

        // =====================================
        // STARTUP
        // =====================================
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
<!-- =====================================
  DEBUGGING CONSOLE 
  =====================================  -->
<script>
    // Enable more detailed console logging
    console.log = (function(originalLog) {
        return function() {
            originalLog.apply(console, ['[Drone Explorer]', ...arguments]);
        };
    })(console.log);
    
    console.error = (function(originalError) {
        return function() {
            originalError.apply(console, ['[Drone Explorer ERROR]', ...arguments]);
        };
    })(console.error);
</script>
</body>
</html>
                    