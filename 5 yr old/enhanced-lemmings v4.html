<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Lemmings Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a2e;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            border-radius: 8px;
            image-rendering: pixelated;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.5));
            display: flex;
            justify-content: space-between;
            z-index: 10;
            border-bottom: 2px solid rgba(255, 204, 0, 0.4);
        }
        
        #abilities {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.5));
            display: flex;
            justify-content: center;
            gap: 12px;
            z-index: 10;
            border-top: 2px solid rgba(255, 204, 0, 0.4);
        }
        
        .ability-btn {
            width: 70px;
            height: 70px;
            border: 2px solid #666;
            border-radius: 8px;
            background: linear-gradient(to bottom, #444, #222);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            font-size: 11px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .ability-btn.selected {
            border-color: #ffcc00;
            background: linear-gradient(to bottom, #555, #333);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.5);
            transform: translateY(-3px);
        }
        
        .ability-btn:hover {
            border-color: #999;
            transform: translateY(-2px);
        }
        
        .ability-btn .count {
            font-size: 14px;
            font-weight: bold;
            color: #ffcc00;
            margin-top: 4px;
        }
        
        .ability-icon {
            font-size: 24px;
            margin-bottom: 4px;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.5));
        }
        
        #start-screen, #level-complete, #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            z-index: 20;
            backdrop-filter: blur(5px);
        }
        
        #level-complete, #game-over {
            display: none;
        }
        
        h1 {
            color: #ffcc00;
            text-shadow: 0 0 15px rgba(255, 204, 0, 0.7), 0 3px 5px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
            font-size: 48px;
            letter-spacing: 3px;
        }
        
        button {
            padding: 12px 24px;
            font-size: 18px;
            background: linear-gradient(to bottom, #ffcc00, #e6b800);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            color: #222;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #ffd633, #ffcc00);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .level-btn {
            margin: 5px;
            padding: 12px 20px;
            background: linear-gradient(to bottom, #555, #333);
            color: white;
            border-radius: 6px;
            border: 1px solid #666;
            font-weight: normal;
        }
        
        .level-btn:hover {
            background: linear-gradient(to bottom, #666, #444);
        }
        
        .level-btn.active {
            background: linear-gradient(to bottom, #ffcc00, #e6b800);
            color: #222;
            border-color: #d4aa00;
        }
        
        #speed-control {
            position: absolute;
            top: 60px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 11;
        }
        
        .speed-btn {
            padding: 8px 12px;
            background: linear-gradient(to bottom, #444, #333);
            border: 1px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .speed-btn:hover {
            background: linear-gradient(to bottom, #555, #444);
        }
        
        .speed-btn.active {
            background: linear-gradient(to bottom, #ffcc00, #e6b800);
            color: #222;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            border-color: #d4aa00;
        }
        
        .hud-number {
            font-weight: bold;
            color: #ffcc00;
        }
        
        /* Stylized progress bars */
        .progress-container {
            position: absolute;
            top: 50px;
            left: 15px;
            width: 180px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 11;
        }
        
        .progress-bar {
            height: 12px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 6px;
            margin-top: 5px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4ade80, #22c55e);
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        
        .progress-label {
            font-size: 12px;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }
        
        /* Particle effects for lemming interactions */
        .particle {
            position: absolute;
            background-color: white;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div>Level: <span id="level-display" class="hud-number">1</span></div>
            <div>Lemmings: <span id="lemmings-saved" class="hud-number">0</span>/<span id="lemmings-target" class="hud-number">0</span>/<span id="lemmings-total" class="hud-number">0</span></div>
            <div>Time: <span id="time-display" class="hud-number">0:00</span></div>
        </div>
        
        <div class="progress-container">
            <div class="progress-label">
                <span>Progress</span>
                <span id="progress-percent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="level-progress" style="width: 0%"></div>
            </div>
            
            <div class="progress-label" style="margin-top: 8px;">
                <span>Saved</span>
                <span id="saved-percent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="saved-progress" style="width: 0%"></div>
            </div>
        </div>
        
        <div id="abilities">
            <div class="ability-btn" data-ability="digger">
                <div class="ability-icon">‚õèÔ∏è</div>
                <div>Digger</div>
                <div class="count" id="digger-count">10</div>
            </div>
            <div class="ability-btn" data-ability="blocker">
                <div class="ability-icon">üõë</div>
                <div>Blocker</div>
                <div class="count" id="blocker-count">5</div>
            </div>
            <div class="ability-btn" data-ability="builder">
                <div class="ability-icon">üß±</div>
                <div>Builder</div>
                <div class="count" id="builder-count">10</div>
            </div>
            <div class="ability-btn" data-ability="basher">
                <div class="ability-icon">üí™</div>
                <div>Basher</div>
                <div class="count" id="basher-count">5</div>
            </div>
            <div class="ability-btn" data-ability="climber">
                <div class="ability-icon">üßó</div>
                <div>Climber</div>
                <div class="count" id="climber-count">5</div>
            </div>
            <div class="ability-btn" data-ability="floater">
                <div class="ability-icon">ü™Ç</div>
                <div>Floater</div>
                <div class="count" id="floater-count">5</div>
            </div>
            <div class="ability-btn" data-ability="bomber">
                <div class="ability-icon">üí£</div>
                <div>Bomber</div>
                <div class="count" id="bomber-count">5</div>
            </div>
        </div>
        
        <div id="speed-control">
            <button class="speed-btn" data-speed="1">1x</button>
            <button class="speed-btn active" data-speed="2">2x</button>
            <button class="speed-btn" data-speed="3">3x</button>
        </div>
        
        <div id="start-screen">
            <h1>LEMMINGS</h1>
            <p>Guide your lemmings to the exit door. Assign them roles to overcome obstacles.</p>
            <p>Save enough lemmings to complete each level!</p>
            <div id="level-select">
                <h2>Select Level</h2>
                <div>
                    <button class="level-btn active" data-level="1">Level 1</button>
                    <button class="level-btn" data-level="2">Level 2</button>
                    <button class="level-btn" data-level="3">Level 3</button>
                </div>
            </div>
            <button id="start-button">START GAME</button>
        </div>
        
        <div id="level-complete">
            <h1>LEVEL COMPLETE!</h1>
            <div id="level-stats">
                <p>Lemmings saved: <span id="saved-count" class="hud-number">0</span>/<span id="required-count" class="hud-number">0</span></p>
                <p>Time: <span id="completion-time" class="hud-number">0:00</span></p>
            </div>
            <button id="next-level-button">NEXT LEVEL</button>
        </div>
        
        <div id="game-over">
            <h1>GAME OVER</h1>
            <p id="game-over-message">You didn't save enough lemmings!</p>
            <button id="retry-button">RETRY LEVEL</button>
            <button id="main-menu-button">MAIN MENU</button>
        </div>
    </div>

    <script>
        // Game variables
        let gameState = "start"; // start, playing, levelComplete, gameOver
        let currentLevel = 1;
        let gameSpeed = .25;
        let world;
        let lemmings = [];
        let tiles = [];
        let entrances = [];
        let exits = [];
        let selectedAbility = null;
        let spawnTimer = 0;
        let spawnInterval = 60; // frames between lemming spawns
        let levelTime = 0;
        let levelTimeLimit = 120; // seconds
        let totalLemmings = 20;
        let lemminsSaved = 0;
        let lemmingsRequired = 10;
        let lemmingsSpawned = 0;
        let abilities = {
            digger: 10,
            blocker: 5,
            builder: 10,
            basher: 5,
            climber: 5,
            floater: 5,
            bomber: 5
        };
        
        let originalAbilities = {...abilities};
        
        // Sprite assets (we'll create them programmatically)
        let spriteAssets = {
            lemmingWalk: [],
            lemmingDig: [],
            lemmingBuild: [],
            lemmingBash: [],
            lemmingClimb: [],
            lemmingFloat: [],
            lemmingBlock: [],
            lemmingFall: [],
            lemmingBomb: [],
            tileSets: {},
            entranceSprite: null,
            exitSprite: null,
            particleSprites: {},
            backgroundLayers: []
        };
        
        // Sprite generation helper functions
        function createSprites() {
            // Create sprite sheets for lemming animations
            createLemmingSprites();
            
            // Create tile sets
            createTileSets();
            
            // Create entrance and exit sprites
            createEntranceExitSprites();
            
            // Create particle effect sprites
            createParticleSprites();
            
            // Create background layers
            createBackgroundLayers();
        }
        
        function createLemmingSprites() {
            // Walking animation (8 frames)
            spriteAssets.lemmingWalk = [];
            for (let i = 0; i < 8; i++) {
                const sprite = createGraphics(16, 20);
                sprite.clear();
                
                // Draw a more detailed lemming silhouette
                sprite.noStroke();
                
                // Hair (blue like original game)
                sprite.fill(0, 100, 200);
                sprite.ellipse(8, 5, 12, 10);
                
                // Body (green like original game)
                sprite.fill(0, 200, 100);
                sprite.rect(4, 8, 8, 10, 2);
                
                // Walking animation
                const legOffset = sin(i * PI/4) * 2;
                sprite.strokeWeight(2);
                sprite.stroke(0, 180, 80);
                sprite.line(6, 18, 5, 20 + legOffset);  // Left leg
                sprite.line(10, 18, 11, 20 - legOffset); // Right leg
                
                // Arms
                sprite.line(4, 10 + sin(i * PI/4), 2, 12 + sin(i * PI/4) * 2); // Left arm
                sprite.line(12, 10 + sin(i * PI/4 + PI), 14, 12 + sin(i * PI/4 + PI) * 2); // Right arm
                
                // Face details
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(10, 5, 3, 3); // Eye
                sprite.fill(0);
                sprite.ellipse(11, 5, 1.5, 1.5); // Pupil
                sprite.ellipse(9, 7, 2, 1.5); // Mouth
                
                spriteAssets.lemmingWalk.push(sprite);
            }
            
            // Digging animation (6 frames)
            spriteAssets.lemmingDig = [];
            for (let i = 0; i < 6; i++) {
                const sprite = createGraphics(16, 20);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(8, 4, 12, 10);
                
                // Body - lower for digging
                sprite.fill(0, 200, 100);
                sprite.rect(4, 8, 8, 10, 2);
                
                // Digging animation
                const digAngle = i * PI/3;
                const armX = 8 + cos(digAngle) * 6;
                const armY = 12 + sin(digAngle) * 4;
                
                // Shovel
                sprite.stroke(150, 100, 50);
                sprite.strokeWeight(2);
                sprite.line(armX, armY, armX + cos(digAngle) * 4, armY + sin(digAngle) * 4);
                
                // Arms
                sprite.stroke(0, 180, 80);
                sprite.line(8, 10, armX, armY);
                
                // Face looking down
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(8, 4, 3, 3); // Eye visible from top
                
                spriteAssets.lemmingDig.push(sprite);
            }
            
            // Building animation (8 frames)
            spriteAssets.lemmingBuild = [];
            for (let i = 0; i < 8; i++) {
                const sprite = createGraphics(20, 20);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(8, 5, 12, 10);
                
                // Body
                sprite.fill(0, 200, 100);
                sprite.rect(4, 8, 8, 10, 2);
                
                // Building animation
                const buildPhase = i % 4;
                if (buildPhase === 0) {
                    // Phase 1: Reach down for brick
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 10, 16, 15);
                    
                    // Brick below
                    sprite.fill(180, 140, 100);
                    sprite.noStroke();
                    sprite.rect(14, 16, 6, 3);
                }
                else if (buildPhase === 1) {
                    // Phase 2: Lifting brick
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 10, 16, 12);
                    
                    // Brick being lifted
                    sprite.fill(180, 140, 100);
                    sprite.noStroke();
                    sprite.rect(14, 10, 6, 3);
                }
                else if (buildPhase === 2) {
                    // Phase 3: Holding brick up
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 9, 16, 8);
                    
                    // Brick above
                    sprite.fill(180, 140, 100);
                    sprite.noStroke();
                    sprite.rect(14, 5, 6, 3);
                }
                else {
                    // Phase 4: Placing brick forward
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 10, 18, 12);
                    
                    // Brick being placed
                    sprite.fill(180, 140, 100);
                    sprite.noStroke();
                    sprite.rect(16, 12, 6, 3);
                }
                
                // Face looking toward building direction
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(10, 5, 3, 3); // Eye
                sprite.fill(0);
                sprite.ellipse(11, 5, 1.5, 1.5); // Pupil
                
                spriteAssets.lemmingBuild.push(sprite);
            }
            
            // Bashing animation (6 frames)
            spriteAssets.lemmingBash = [];
            for (let i = 0; i < 6; i++) {
                const sprite = createGraphics(20, 20);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(8, 5, 12, 10);
                
                // Body - slightly hunched forward
                sprite.fill(0, 200, 100);
                sprite.rect(4, 8, 8, 10, 2);
                
                // Bashing animation
                const bashPhase = i % 3;
                if (bashPhase === 0) {
                    // Wind up
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 10, 8, 8);
                }
                else if (bashPhase === 1) {
                    // Mid swing
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 10, 14, 9);
                    
                    // Show some action lines
                    sprite.stroke(255, 255, 255, 150);
                    sprite.line(14, 9, 16, 9);
                }
                else {
                    // Full extension
                    sprite.stroke(0, 180, 80);
                    sprite.strokeWeight(2);
                    sprite.line(12, 10, 18, 10);
                    
                    // More action lines
                    sprite.stroke(255, 255, 255, 200);
                    sprite.line(18, 8, 20, 7);
                    sprite.line(18, 10, 20, 10);
                    sprite.line(18, 12, 20, 13);
                }
                
                // Face looking determined
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(10, 5, 3, 3); // Eye
                sprite.fill(0);
                sprite.ellipse(11, 5, 1.5, 1.5); // Pupil with angry eyebrow
                sprite.stroke(0);
                sprite.strokeWeight(1);
                sprite.line(9, 3, 12, 4); // Angry eyebrow
                
                spriteAssets.lemmingBash.push(sprite);
            }
            
            // Climbing animation (8 frames)
            spriteAssets.lemmingClimb = [];
            for (let i = 0; i < 8; i++) {
                const sprite = createGraphics(16, 24);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(8, 5, 12, 10);
                
                // Body - vertical orientation
                sprite.fill(0, 200, 100);
                sprite.rect(4, 8, 8, 12, 2);
                
                // Climbing animation - alternating hands and feet
                const climbPhase = i % 4;
                sprite.stroke(0, 180, 80);
                sprite.strokeWeight(2);
                
                if (climbPhase === 0) {
                    // Right arm up, left arm middle
                    sprite.line(12, 10, 14, 6);
                    sprite.line(4, 12, 2, 12);
                    // Right leg bent, left leg extended
                    sprite.line(12, 20, 14, 16);
                    sprite.line(4, 20, 2, 22);
                }
                else if (climbPhase === 1) {
                    // Right arm up, left arm up
                    sprite.line(12, 10, 14, 6);
                    sprite.line(4, 10, 2, 6);
                    // Right leg bent, left leg bent
                    sprite.line(12, 20, 14, 16);
                    sprite.line(4, 20, 2, 16);
                }
                else if (climbPhase === 2) {
                    // Right arm middle, left arm up
                    sprite.line(12, 12, 14, 12);
                    sprite.line(4, 10, 2, 6);
                    // Right leg extended, left leg bent
                    sprite.line(12, 20, 14, 22);
                    sprite.line(4, 20, 2, 16);
                }
                else {
                    // Right arm middle, left arm middle (transitioning)
                    sprite.line(12, 12, 14, 12);
                    sprite.line(4, 12, 2, 12);
                    // Right leg extended, left leg extended (transitioning)
                    sprite.line(12, 20, 14, 22);
                    sprite.line(4, 20, 2, 22);
                }
                
                // Face looking up
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(8, 5, 3, 3); // Eye
                sprite.fill(0);
                sprite.ellipse(8, 4, 1.5, 1.5); // Pupil looking up
                
                spriteAssets.lemmingClimb.push(sprite);
            }
            
            // Floating animation (4 frames)
            spriteAssets.lemmingFloat = [];
            for (let i = 0; i < 4; i++) {
                const sprite = createGraphics(24, 30);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(12, 8, 12, 10);
                
                // Body
                sprite.fill(0, 200, 100);
                sprite.rect(8, 12, 8, 10, 2);
                
                // Arms holding umbrella
                sprite.stroke(0, 180, 80);
                sprite.strokeWeight(2);
                sprite.line(10, 14, 12, 5); // Left arm
                sprite.line(14, 14, 12, 5); // Right arm
                
                // Legs slightly spread
                sprite.line(10, 22, 8, 26 + sin(i * PI/2) * 2);  // Left leg
                sprite.line(14, 22, 16, 26 + sin(i * PI/2 + PI) * 2); // Right leg
                
                // Umbrella
                sprite.fill(255, 50, 50, 220);
                sprite.noStroke();
                sprite.arc(12, 5, 20, 14, PI, TWO_PI);
                
                // Umbrella handle
                sprite.stroke(120);
                sprite.strokeWeight(1.5);
                sprite.line(12, 5, 12, 1);
                
                // Umbrella ribs
                sprite.stroke(150);
                sprite.strokeWeight(0.8);
                for (let j = 0; j < 6; j++) {
                    const angle = PI + j * PI/5;
                    sprite.line(12, 5, 12 + cos(angle) * 10, 5 + sin(angle) * 7);
                }
                
                // Face looking up at umbrella
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(12, 8, 3, 3); // Eye
                sprite.fill(0);
                sprite.ellipse(12, 7, 1.5, 1.5); // Pupil looking up
                
                spriteAssets.lemmingFloat.push(sprite);
            }
            
            // Blocking animation (2 frames - subtle movement)
            spriteAssets.lemmingBlock = [];
            for (let i = 0; i < 2; i++) {
                const sprite = createGraphics(24, 20);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(12, 5, 12, 10);
                
                // Body
                sprite.fill(0, 200, 100);
                sprite.rect(8, 8, 8, 10, 2);
                
                // Arms outstretched
                sprite.stroke(0, 180, 80);
                sprite.strokeWeight(2);
                const armWave = i * 2; // Subtle arm movement
                sprite.line(8, 10, 2, 10 + armWave);  // Left arm
                sprite.line(16, 10, 22, 10 - armWave); // Right arm
                
                // Legs planted firmly
                sprite.line(10, 18, 8, 20);  // Left leg
                sprite.line(14, 18, 16, 20); // Right leg
                
                // "X" mark on chest - classic blocker look
                sprite.stroke(255, 0, 0);
                sprite.strokeWeight(1.5);
                sprite.line(9, 10, 15, 16);
                sprite.line(15, 10, 9, 16);
                
                // Face looking stern
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(10, 5, 3, 3); // Left eye
                sprite.ellipse(14, 5, 3, 3); // Right eye
                sprite.fill(0);
                sprite.ellipse(10, 5, 1.5, 1.5); // Left pupil
                sprite.ellipse(14, 5, 1.5, 1.5); // Right pupil
                
                sprite.stroke(0);
                sprite.strokeWeight(1);
                sprite.line(10, 7, 14, 7); // Straight mouth
                
                spriteAssets.lemmingBlock.push(sprite);
            }
            
            // Falling animation (4 frames)
            spriteAssets.lemmingFall = [];
            for (let i = 0; i < 4; i++) {
                const sprite = createGraphics(16, 20);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(8, 5, 12, 10);
                
                // Body
                sprite.fill(0, 200, 100);
                sprite.rect(4, 8, 8, 10, 2);
                
                // Flailing arms and legs
                sprite.stroke(0, 180, 80);
                sprite.strokeWeight(2);
                
                // Arms flailing
                const armAngle = i * PI/2;
                sprite.line(8, 10, 8 + cos(armAngle) * 6, 10 + sin(armAngle) * 4);  // Left arm
                sprite.line(8, 10, 8 + cos(armAngle + PI) * 6, 10 + sin(armAngle + PI) * 4); // Right arm
                
                // Legs kicking
                const legAngle = i * PI/2 + PI/4;
                sprite.line(6, 18, 6 + cos(legAngle) * 3, 18 + sin(legAngle) * 4);  // Left leg
                sprite.line(10, 18, 10 + cos(legAngle + PI) * 3, 18 + sin(legAngle + PI) * 4); // Right leg
                
                // Face looking panicked
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(8, 5, 4, 4); // Wide eye
                sprite.fill(0);
                sprite.ellipse(8, 5, 2, 2); // Pupil
                sprite.ellipse(8, 8, 3, 2); // Open mouth
                
                spriteAssets.lemmingFall.push(sprite);
            }
            
            // Bombing animation (8 frames with countdown)
            spriteAssets.lemmingBomb = [];
            for (let i = 0; i < 8; i++) {
                const sprite = createGraphics(20, 24);
                sprite.clear();
                
                // Hair
                sprite.fill(0, 100, 200);
                sprite.noStroke();
                sprite.ellipse(10, 5, 12, 10);
                
                // Body
                sprite.fill(0, 200, 100);
                sprite.rect(6, 8, 8, 10, 2);
                
                // Countdown number above head
                if (i % 2 === 0) { // Blink the countdown
                    sprite.fill(255, 0, 0);
                    sprite.ellipse(10, -2, 10, 10);
                    sprite.fill(255);
                    sprite.textSize(8);
                    sprite.textAlign(CENTER, CENTER);
                    sprite.text(ceil(5 - i/2), 10, -2);
                }
                
                // Sweat drops
                if (i % 3 === 0) {
                    sprite.fill(100, 200, 255);
                    sprite.noStroke();
                    sprite.ellipse(16, 6, 3, 4);
                }
                
                // Nervous shaking
                const shakeX = sin(i * PI) * 1;
                const shakeY = cos(i * PI) * 0.5;
                
                // Arms trembling
                sprite.stroke(0, 180, 80);
                sprite.strokeWeight(2);
                sprite.line(6 + shakeX, 10 + shakeY, 4 + shakeX*2, 12 + shakeY*2);  // Left arm
                sprite.line(14 + shakeX, 10 + shakeY, 16 + shakeX*2, 12 + shakeY*2); // Right arm
                
                // Legs trembling
                sprite.line(8 + shakeX, 18 + shakeY, 7 + shakeX*1.5, 20 + shakeY*1.5);  // Left leg
                sprite.line(12 + shakeX, 18 + shakeY, 13 + shakeX*1.5, 20 + shakeY*1.5); // Right leg
                
                // Face looking panicked
                sprite.noStroke();
                sprite.fill(255);
                sprite.ellipse(8, 5, 3, 3); // Left eye
                sprite.ellipse(12, 5, 3, 3); // Right eye
                sprite.fill(0);
                sprite.ellipse(8, 5, 2, 2); // Left pupil
                sprite.ellipse(12, 5, 2, 2); // Right pupil
                
                // Worried mouth
                sprite.noFill();
                sprite.stroke(0);
                sprite.strokeWeight(1);
                sprite.arc(10, 8, 6, 4, 0, PI);
                
                spriteAssets.lemmingBomb.push(sprite);
            }
        }
        
        function createTileSets() {
            // Create ground tile set
            spriteAssets.tileSets.ground = createGraphics(20, 20);
            const groundTile = spriteAssets.tileSets.ground;
            
            // Base fill
            groundTile.fill(120, 80, 40);
            groundTile.noStroke();
            groundTile.rect(0, 0, 20, 20);
            
            // Top edge highlight
            groundTile.fill(140, 95, 50);
            groundTile.rect(0, 0, 20, 4);
            
            // Texture details
            groundTile.stroke(90, 60, 30, 150);
            groundTile.strokeWeight(0.5);
            
            // Grid pattern overlay
            for (let y = 5; y < 20; y += 5) {
                groundTile.line(0, y, 20, y);
            }
            
            for (let x = 5; x < 20; x += 5) {
                groundTile.line(x, 0, x, 20);
            }
            
            // Random rocks and details
            groundTile.noStroke();
            groundTile.fill(90, 65, 35, 200);
            
            // Add some "random" pebbles and details in a consistent pattern
            for (let i = 1; i <= 6; i++) {
                const x = (i * 7) % 19;
                const y = (i * 11) % 19;
                const size = (i % 3) + 2;
                groundTile.ellipse(x, y, size, size);
            }
            
            // Create bridge/stair tile set
            spriteAssets.tileSets.bridge = createGraphics(20, 8);
            const bridgeTile = spriteAssets.tileSets.bridge;
            
            // Base brick
            bridgeTile.fill(180, 140, 100);
            bridgeTile.stroke(140, 100, 60);
            bridgeTile.strokeWeight(1);
            bridgeTile.rect(0, 0, 20, 8, 2);
            
            // Brick details
            bridgeTile.strokeWeight(0.5);
            bridgeTile.line(10, 0, 10, 8); // Vertical divider
            bridgeTile.line(0, 4, 20, 4); // Horizontal divider
            
            // Highlight on top edge
            bridgeTile.stroke(200, 170, 130, 180);
            bridgeTile.line(1, 1, 19, 1);
            
            // Shadow on bottom edge
            bridgeTile.stroke(120, 80, 40, 180);
            bridgeTile.line(1, 7, 19, 7);
        }
        
        function createEntranceExitSprites() {
            // Create entrance sprite
            spriteAssets.entranceSprite = createGraphics(40, 60);
            const entrance = spriteAssets.entranceSprite;
            
            // Metal frame with gradient
            entrance.noStroke();
            for (let y = 0; y < 60; y++) {
                const brightness = map(y, 0, 60, 170, 130);
                entrance.fill(brightness, brightness, brightness + 20);
                entrance.rect(0, y, 40, 1);
            }
            
            // Frame border
            entrance.stroke(100, 100, 120);
            entrance.strokeWeight(3);
            entrance.noFill();
            entrance.rect(0, 0, 40, 60, 8);
            
            // Hatch door
            entrance.fill(70, 70, 90);
            entrance.rect(8, 18, 24, 36, 6);
            
            // Door details
            entrance.stroke(90, 90, 110);
            entrance.strokeWeight(1);
            entrance.line(20, 18, 20, 54); // Center line
            
            // Rivets
            entrance.fill(200, 200, 220);
            entrance.noStroke();
            // Top row
            for (let i = 0; i < 3; i++) {
                entrance.ellipse(10 + i * 10, 6, 4, 4);
            }
            // Bottom row
            for (let i = 0; i < 3; i++) {
                entrance.ellipse(10 + i * 10, 54, 4, 4);
            }
            // Door rivets
            entrance.ellipse(12, 27, 3, 3);
            entrance.ellipse(28, 27, 3, 3);
            entrance.ellipse(12, 45, 3, 3);
            entrance.ellipse(28, 45, 3, 3);
            
            // Door handle
            entrance.fill(220, 220, 240);
            entrance.ellipse(28, 36, 6, 6);
            entrance.fill(120, 120, 140);
            entrance.ellipse(28, 36, 3, 3);
            
            // Warning sign
            entrance.fill(250, 220, 0);
            entrance.stroke(0);
            entrance.strokeWeight(1);
            entrance.triangle(20, 8, 15, 16, 25, 16);
            entrance.fill(0);
            entrance.textSize(8);
            entrance.textAlign(CENTER, CENTER);
            entrance.text("!", 20, 12);
            
            // Create exit sprite
            spriteAssets.exitSprite = createGraphics(60, 80);
            const exit = spriteAssets.exitSprite;
            
            // Base structure with gradient
            exit.noStroke();
            for (let y = 0; y < 80; y++) {
                const greenValue = map(y, 0, 80, 160, 100);
                exit.fill(60, greenValue, 60);
                exit.rect(0, y, 60, 1);
            }
            
            // Outer frame
            exit.stroke(40, 100, 40);
            exit.strokeWeight(3);
            exit.noFill();
            exit.rect(0, 0, 60, 80, 12);
            
            // Door opening (inner)
            exit.fill(20, 40, 20);
            exit.rect(12, 30, 36, 50, 0, 0, 10, 10);
            
            // Door frame
            exit.noFill();
            exit.stroke(100, 180, 100);
            exit.strokeWeight(2);
            exit.rect(12, 30, 36, 50, 0, 0, 8, 8);
            
            // Door steps
            exit.fill(80, 120, 80);
            exit.noStroke();
            exit.rect(12, 75, 36, 5);
            exit.fill(70, 110, 70);
            exit.rect(14, 72, 32, 3);
            
            // EXIT sign
            exit.fill(30, 70, 30);
            exit.rect(10, 10, 40, 15, 4);
            exit.fill(120, 230, 120);
            exit.rect(12, 12, 36, 11, 2);
            exit.fill(10, 50, 10);
            exit.textSize(12);
            exit.textAlign(CENTER, CENTER);
            exit.text("EXIT", 30, 17);
            
            // Light above door
            exit.fill(100, 220, 100);
            exit.ellipse(30, 27, 8, 8);
            
            // Door details
            for (let y = 35; y < 70; y += 10) {
                exit.stroke(40, 80, 40);
                exit.line(15, y, 45, y);
            }
        }
        
        function createParticleSprites() {
            // Explosion particle
            spriteAssets.particleSprites.explosion = createGraphics(10, 10);
            const explosion = spriteAssets.particleSprites.explosion;
            explosion.noStroke();
            explosion.fill(255, 150, 50);
            explosion.ellipse(5, 5, 10, 10);
            
            // Debris particle
            spriteAssets.particleSprites.debris = createGraphics(6, 6);
            const debris = spriteAssets.particleSprites.debris;
            debris.noStroke();
            debris.fill(120, 80, 40);
            debris.rect(0, 0, 6, 6);
            
            // Sparkle particle
            spriteAssets.particleSprites.sparkle = createGraphics(8, 8);
            const sparkle = spriteAssets.particleSprites.sparkle;
            sparkle.noStroke();
            sparkle.fill(255, 255, 180);
            sparkle.beginShape();
            for (let i = 0; i < 5; i++) {
                const angle = TWO_PI / 5 * i;
                const x1 = 4 + cos(angle) * 4;
                const y1 = 4 + sin(angle) * 4;
                sparkle.vertex(x1, y1);
                
                const angleHalf = TWO_PI / 5 * (i + 0.5);
                const x2 = 4 + cos(angleHalf) * 2;
                const y2 = 4 + sin(angleHalf) * 2;
                sparkle.vertex(x2, y2);
            }
            sparkle.endShape(CLOSE);
            
            // Smoke particle
            spriteAssets.particleSprites.smoke = createGraphics(10, 10);
            const smoke = spriteAssets.particleSprites.smoke;
            smoke.noStroke();
            smoke.fill(200, 200, 200, 150);
            smoke.ellipse(5, 5, 8, 8);
            
            // Dig particle
            spriteAssets.particleSprites.dig = createGraphics(6, 6);
            const dig = spriteAssets.particleSprites.dig;
            dig.noStroke();
            dig.fill(140, 100, 60);
            dig.rect(0, 0, 6, 6, 1);
            
            // Build particle
            spriteAssets.particleSprites.build = createGraphics(6, 6);
            const build = spriteAssets.particleSprites.build;
            build.noStroke();
            build.fill(190, 150, 110);
            build.rect(0, 0, 6, 6, 1);
            
            // Bash particle
            spriteAssets.particleSprites.bash = createGraphics(4, 2);
            const bash = spriteAssets.particleSprites.bash;
            bash.noStroke();
            bash.fill(255, 255, 255, 200);
            bash.rect(0, 0, 4, 2, 1);
        }
        
        function createBackgroundLayers() {
            // Sky layer
            spriteAssets.backgroundLayers.push(createGraphics(800, 600));
            const sky = spriteAssets.backgroundLayers[0];
            
            // Create a gradient sky
            for (let y = 0; y < 600; y++) {
                const r = map(y, 0, 600, 100, 50);
                const g = map(y, 0, 600, 150, 80);
                const b = map(y, 0, 600, 255, 150);
                sky.stroke(r, g, b);
                sky.line(0, y, 800, y);
            }
            
            // Add some stars in the upper part
            sky.noStroke();
            sky.fill(255, 255, 255, 120);
            for (let i = 0; i < 100; i++) {
                const x = random(800);
                const y = random(200);
                const size = random(1, 3);
                sky.ellipse(x, y, size, size);
            }
            
            // Mountain layer
            spriteAssets.backgroundLayers.push(createGraphics(800, 600));
            const mountains = spriteAssets.backgroundLayers[1];
            
            // Draw distant mountains
            mountains.noStroke();
            
            // Large far mountains
            mountains.fill(70, 90, 120, 180);
            mountains.beginShape();
            mountains.vertex(0, 300);
            mountains.vertex(100, 200);
            mountains.vertex(200, 250);
            mountains.vertex(300, 160);
            mountains.vertex(400, 220);
            mountains.vertex(500, 180);
            mountains.vertex(600, 240);
            mountains.vertex(700, 190);
            mountains.vertex(800, 220);
            mountains.vertex(800, 300);
            mountains.endShape(CLOSE);
            
            // Medium mountains
            mountains.fill(60, 80, 100, 160);
            mountains.beginShape();
            mountains.vertex(0, 320);
            mountains.vertex(50, 280);
            mountains.vertex(150, 300);
            mountains.vertex(250, 260);
            mountains.vertex(350, 290);
            mountains.vertex(450, 270);
            mountains.vertex(550, 310);
            mountains.vertex(650, 250);
            mountains.vertex(750, 280);
            mountains.vertex(800, 260);
            mountains.vertex(800, 320);
            mountains.endShape(CLOSE);
            
            // Smaller foreground mountains
            mountains.fill(50, 70, 90, 140);
            mountains.beginShape();
            mountains.vertex(0, 350);
            mountains.vertex(80, 320);
            mountains.vertex(160, 340);
            mountains.vertex(240, 310);
            mountains.vertex(320, 330);
            mountains.vertex(400, 300);
            mountains.vertex(480, 340);
            mountains.vertex(560, 310);
            mountains.vertex(640, 330);
            mountains.vertex(720, 300);
            mountains.vertex(800, 320);
            mountains.vertex(800, 350);
            mountains.endShape(CLOSE);
            
            // Clouds layer
            spriteAssets.backgroundLayers.push(createGraphics(800, 600));
            const clouds = spriteAssets.backgroundLayers[2];
            
            // Draw some clouds
            clouds.noStroke();
            clouds.fill(255, 255, 255, 100);
            
            // Create a few cloud clusters
            for (let i = 0; i < 8; i++) {
                const cloudX = i * 120 - 50;
                const cloudY = 100 + random(-50, 50);
                const cloudSize = random(0.8, 1.3);
                
                // Cloud puffs
                clouds.ellipse(cloudX, cloudY, 70 * cloudSize, 50 * cloudSize);
                clouds.ellipse(cloudX + 30, cloudY - 10, 60 * cloudSize, 50 * cloudSize);
                clouds.ellipse(cloudX + 60, cloudY, 70 * cloudSize, 55 * cloudSize);
                clouds.ellipse(cloudX + 30, cloudY + 10, 80 * cloudSize, 45 * cloudSize);
            }
        }
        
        // Level definitions
        const levels = [
            // Level 1
            {
                tileSize: 20,
                gridWidth: 40,
                gridHeight: 30,
                backgroundColor: [100, 150, 255],
                lemmingsTotal: 20,
                lemmingsRequired: 10,
                timeLimit: 120,
                spawnInterval: 60,
                abilities: {
                    digger: 10,
                    blocker: 5,
                    builder: 10,
                    basher: 5,
                    climber: 5,
                    floater: 5,
                    bomber: 5
                },
                entrances: [
                    { x: 5, y: 5 }
                ],
                exits: [
                    { x: 35, y: 25, width: 3, height: 4 }
                ],
                tiles: [
                    // Ground platforms
                    { x: 0, y: 12, width: 10, height: 18, type: "ground" },
                    { x: 12, y: 15, width: 15, height: 15, type: "ground" },
                    { x: 30, y: 25, width: 10, height: 5, type: "ground" },
                    // Small obstacles
                    { x: 10, y: 11, width: 2, height: 1, type: "ground" },
                ]
            },
            // Level 2
            {
                tileSize: 20,
                gridWidth: 40,
                gridHeight: 30,
                backgroundColor: [80, 130, 200],
                lemmingsTotal: 25,
                lemmingsRequired: 15,
                timeLimit: 180,
                spawnInterval: 45,
                abilities: {
                    digger: 8,
                    blocker: 4,
                    builder: 12,
                    basher: 8,
                    climber: 6,
                    floater: 6,
                    bomber: 5
                },
                entrances: [
                    { x: 2, y: 5 }
                ],
                exits: [
                    { x: 35, y: 5, width: 3, height: 4 }
                ],
                tiles: [
                    // Starting platform
                    { x: 0, y: 10, width: 5, height: 20, type: "ground" },
                    // Middle sections
                    { x: 6, y: 15, width: 12, height: 15, type: "ground" },
                    { x: 20, y: 12, width: 8, height: 18, type: "ground" },
                    // End platform
                    { x: 32, y: 9, width: 8, height: 21, type: "ground" },
                    // Obstacles
                    { x: 6, y: 14, width: 2, height: 1, type: "ground" },
                    { x: 28, y: 11, width: 4, height: 1, type: "ground" },
                ]
            },
            // Level 3
            {
                tileSize: 20,
                gridWidth: 40,
                gridHeight: 30,
                backgroundColor: [60, 100, 180],
                lemmingsTotal: 30,
                lemmingsRequired: 20,
                timeLimit: 240,
                spawnInterval: 40,
                abilities: {
                    digger: 12,
                    blocker: 6,
                    builder: 15,
                    basher: 10,
                    climber: 8,
                    floater: 8,
                    bomber: 8
                },
                entrances: [
                    { x: 20, y: 2 }
                ],
                exits: [
                    { x: 5, y: 25, width: 3, height: 4 }
                ],
                tiles: [
                    // Top platform
                    { x: 15, y: 5, width: 10, height: 2, type: "ground" },
                    // Middle structures
                    { x: 5, y: 10, width: 10, height: 2, type: "ground" },
                    { x: 25, y: 12, width: 10, height: 2, type: "ground" },
                    { x: 10, y: 18, width: 20, height: 2, type: "ground" },
                    // Bottom platform
                    { x: 0, y: 25, width: 15, height: 5, type: "ground" },
                    { x: 25, y: 22, width: 15, height: 8, type: "ground" },
                    // Obstacles
                    { x: 15, y: 17, width: 1, height: 1, type: "ground" },
                    { x: 25, y: 17, width: 1, height: 1, type: "ground" },
                ]
            }
        ];
        
        // Particle systems for various effects
        let explosionParticles = [];
        let debrisParticles = [];
        let sparkleParticles = [];
        let smokeParticles = [];
        let digParticles = [];
        let buildParticles = [];
        let bashParticles = [];
        
        // P5.js functions
        function setup() {
            const canvas = createCanvas(800, 600);
            canvas.parent('game-container');
            frameRate(60);
            textAlign(CENTER, CENTER);
            imageMode(CENTER);
            
            // Create all game sprites
            createSprites();
            
            // Initialize event listeners
            initEventListeners();
            
            // Load the first level
            loadLevel(currentLevel);
        }
        
        function draw() {
            // Draw background layers
            for (let i = 0; i < spriteAssets.backgroundLayers.length; i++) {
                image(spriteAssets.backgroundLayers[i], width/2, height/2, width, height);
            }
            
            if (gameState === "playing") {
                updateGame();
                drawWorld();
                drawLemmings();
                drawParticles(); // Draw all particle effects
                updateHUD();
            }
        }
        
        // Game initialization functions
        function initEventListeners() {
            // Ability selection
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const ability = btn.getAttribute('data-ability');
                    if (abilities[ability] > 0) {
                        document.querySelectorAll('.ability-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        selectedAbility = ability;
                    } else {
                        // Add shake animation if no abilities left
                        btn.classList.add('shake');
                        setTimeout(() => {
                            btn.classList.remove('shake');
                        }, 500);
                    }
                });
            });
            
            // Speed control
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameSpeed = parseInt(btn.getAttribute('data-speed'));
                });
            });
            
            // Level selection
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const level = parseInt(btn.getAttribute('data-level'));
                    currentLevel = level;
                    document.getElementById('level-display').textContent = level;
                });
            });
            
            // Start button
            document.getElementById('start-button').addEventListener('click', () => {
                gameState = "playing";
                document.getElementById('start-screen').style.display = 'none';
                loadLevel(currentLevel);
            });
            
            // Next level button
            document.getElementById('next-level-button').addEventListener('click', () => {
                gameState = "playing";
                document.getElementById('level-complete').style.display = 'none';
                currentLevel++;
                if (currentLevel > levels.length) {
                    currentLevel = 1;
                }
                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (parseInt(btn.getAttribute('data-level')) === currentLevel) {
                        btn.classList.add('active');
                    }
                });
                loadLevel(currentLevel);
            });
            
            // Retry button
            document.getElementById('retry-button').addEventListener('click', () => {
                gameState = "playing";
                document.getElementById('game-over').style.display = 'none';
                loadLevel(currentLevel);
            });
            
            // Main menu button
            document.getElementById('main-menu-button').addEventListener('click', () => {
                gameState = "start";
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
            });
        }
        
        function loadLevel(levelIndex) {
            const levelData = levels[levelIndex - 1];
            
            // Reset game variables
            lemmings = [];
            tiles = [];
            entrances = [];
            exits = [];
            lemmingsSpawned = 0;
            lemminsSaved = 0;
            levelTime = 0;
            spawnTimer = 0;
            
            // Reset particle systems
            explosionParticles = [];
            debrisParticles = [];
            sparkleParticles = [];
            smokeParticles = [];
            digParticles = [];
            buildParticles = [];
            bashParticles = [];
            
            // Set level parameters
            world = {
                tileSize: levelData.tileSize,
                gridWidth: levelData.gridWidth,
                gridHeight: levelData.gridHeight,
                width: levelData.gridWidth * levelData.tileSize,
                height: levelData.gridHeight * levelData.tileSize,
                backgroundColor: levelData.backgroundColor
            };
            
            totalLemmings = levelData.lemmingsTotal;
            lemmingsRequired = levelData.lemmingsRequired;
            levelTimeLimit = levelData.timeLimit;
            spawnInterval = levelData.spawnInterval;
            
            // Copy abilities
            abilities = {...levelData.abilities};
            originalAbilities = {...abilities};
            
            // Update ability counts in UI
            for (const ability in abilities) {
                document.getElementById(`${ability}-count`).textContent = abilities[ability];
            }
            
            // Create level tiles
            levelData.tiles.forEach(tileData => {
                for (let y = 0; y < tileData.height; y++) {
                    for (let x = 0; x < tileData.width; x++) {
                        tiles.push({
                            x: (tileData.x + x) * world.tileSize,
                            y: (tileData.y + y) * world.tileSize,
                            width: world.tileSize,
                            height: world.tileSize,
                            type: tileData.type
                        });
                    }
                }
            });
            
            // Create entrances and exits
            levelData.entrances.forEach(entranceData => {
                entrances.push({
                    x: entranceData.x * world.tileSize,
                    y: entranceData.y * world.tileSize,
                    width: world.tileSize * 2,
                    height: world.tileSize * 3
                });
            });
            
            levelData.exits.forEach(exitData => {
                exits.push({
                    x: exitData.x * world.tileSize,
                    y: exitData.y * world.tileSize,
                    width: exitData.width * world.tileSize,
                    height: exitData.height * world.tileSize
                });
            });
            
            // Update HUD
            document.getElementById('level-display').textContent = currentLevel;
            document.getElementById('lemmings-total').textContent = totalLemmings;
            document.getElementById('lemmings-target').textContent = lemmingsRequired;
            document.getElementById('lemmings-saved').textContent = lemminsSaved;
            
            // Reset ability selection
            selectedAbility = null;
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
        
        // Game update functions
        function updateGame() {
            // Update level time
            if (frameCount % 60 === 0) {
                levelTime++;
                if (levelTime >= levelTimeLimit) {
                    checkLevelCompletion();
                }
            }
            
            // Spawn new lemmings
            spawnTimer++;
            if (lemmingsSpawned < totalLemmings && spawnTimer >= spawnInterval / gameSpeed) {
                spawnLemming();
                spawnTimer = 0;
            }
            
            // Update lemmings
            for (let i = lemmings.length - 1; i >= 0; i--) {
                for (let j = 0; j < gameSpeed; j++) {
                    updateLemming(lemmings[i]);
                    
                    // Check if lemming reached exit
                    if (lemmings[i].reachedExit) {
                        // Add exit sparkle effect
                        for (let k = 0; k < 15; k++) {
                            sparkleParticles.push({
                                x: lemmings[i].x + lemmings[i].width/2,
                                y: lemmings[i].y + lemmings[i].height/2,
                                vx: random(-2, 2),
                                vy: random(-4, -1),
                                size: random(3, 6),
                                color: color(255, 255, random(150, 255)),
                                life: random(20, 40),
                                rotation: random(0, TWO_PI)
                            });
                        }
                        
                        lemminsSaved++;
                        lemmings.splice(i, 1);
                        break;
                    }
                    
                    // Check if lemming died
                    if (lemmings[i].isDead) {
                        // Add small poof of smoke for death
                        for (let k = 0; k < 12; k++) {
                            smokeParticles.push({
                                x: lemmings[i].x + lemmings[i].width/2,
                                y: lemmings[i].y + lemmings[i].height/2,
                                vx: random(-1, 1),
                                vy: random(-2, -0.5),
                                size: random(4, 10),
                                color: color(200, 200, 200),
                                life: random(30, 60),
                                alpha: 255
                            });
                        }
                        
                        lemmings.splice(i, 1);
                        break;
                    }
                }
            }
            
            // Update all particle systems
            updateParticles();
            
            // Check for level completion
            if (lemmingsSpawned >= totalLemmings && lemmings.length === 0) {
                checkLevelCompletion();
            }
            
            // Update progress bars
            updateProgressBars();
        }
        
        function updateProgressBars() {
            // Update level progress
            let levelProgress = 0;
            if (totalLemmings > 0) {
                levelProgress = (lemmingsSpawned / totalLemmings) * 100;
            }
            document.getElementById('level-progress').style.width = levelProgress + '%';
            document.getElementById('progress-percent').textContent = Math.floor(levelProgress) + '%';
            
            // Update saved progress
            let savedProgress = 0;
            if (lemmingsRequired > 0) {
                savedProgress = (lemminsSaved / lemmingsRequired) * 100;
                savedProgress = Math.min(savedProgress, 100); // Cap at 100%
            }
            document.getElementById('saved-progress').style.width = savedProgress + '%';
            document.getElementById('saved-percent').textContent = Math.floor(savedProgress) + '%';
            
            // Change color based on progress
            const progressFill = document.getElementById('saved-progress');
            if (savedProgress < 30) {
                progressFill.style.background = 'linear-gradient(to right, #ef4444, #f87171)';
            } else if (savedProgress < 70) {
                progressFill.style.background = 'linear-gradient(to right, #f59e0b, #fbbf24)';
            } else {
                progressFill.style.background = 'linear-gradient(to right, #4ade80, #22c55e)';
            }
        }
        
        function spawnLemming() {
            if (entrances.length === 0) return;
            
            const entrance = entrances[0];
            const lemming = {
                x: entrance.x + entrance.width / 4,
                y: entrance.y + entrance.height,
                width: world.tileSize * 0.8,
                height: world.tileSize * 1,
                speed: 1.5, // Base movement speed
                direction: 1, // 1 = right, -1 = left
                isWalking: true,
                isFalling: true,
                isDigging: false,
                isBlocking: false,
                isBuilding: false,
                isBashing: false,
                isClimbing: false,
                isFloating: false,
                isBombing: false,
                hasClimberAbility: false,
                hasFloaterAbility: false,
                buildCounter: 0,
                buildLimit: 12,
                buildDirection: 0, // Track building direction for reliable stairs
                bashCounter: 0,
                bashLimit: 10, // Number of bashing actions
                digCounter: 0, // Track number of dig actions
                bombTimer: 0,
                bombLimit: 3 * 60, // 3 seconds in frames
                animationFrame: 0,
                animationSpeed: 0.25, // Controls animation speed
                reachedExit: false,
                isDead: false,
                // Visual variety
                colorTint: [
                    random(0.8, 1.2), // Hair tint multiplier
                    random(0.8, 1.2), // Body tint multiplier
                    random(0.9, 1.1)  // Size multiplier
                ]
            };
            
            lemmings.push(lemming);
            lemmingsSpawned++;
            
            // Create spawning sparkle effect
            for (let i = 0; i < 8; i++) {
                sparkleParticles.push({
                    x: lemming.x + lemming.width/2,
                    y: lemming.y + lemming.height/2,
                    vx: random(-2, 2),
                    vy: random(-3, -1),
                    size: random(3, 5),
                    color: color(200, 255, 255),
                    life: random(15, 30),
                    rotation: random(0, TWO_PI)
                });
            }
        }
        



        function explode(lemming) {
            // Create explosion effect
            const explosionRadius = world.tileSize * 3;
            const lemmingCenter = {
                x: lemming.x + lemming.width / 2,
                y: lemming.y + lemming.height / 2
            };
            
            // Create explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = random(0, TWO_PI);
                const distance = random(0, explosionRadius);
                const speed = random(2, 6);
                
                explosionParticles.push({
                    x: lemmingCenter.x,
                    y: lemmingCenter.y,
                    vx: cos(angle) * speed,
                    vy: sin(angle) * speed,
                    radius: random(3, 8),
                    color: color(255, random(100, 255), 0, 255),
                    life: random(20, 40)
                });
            }
            
            // Remove tiles in explosion radius
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                const tileCenter = {
                    x: tile.x + tile.width / 2,
                    y: tile.y + tile.height / 2
                };
                
                const distance = dist(lemmingCenter.x, lemmingCenter.y, tileCenter.x, tileCenter.y);
                
                if (distance < explosionRadius) {
                    // Create debris particles for destroyed tiles
                    for (let j = 0; j < 5; j++) {
                        const debrisAngle = random(0, TWO_PI);
                        debrisParticles.push({
                            x: tileCenter.x,
                            y: tileCenter.y,
                            vx: cos(debrisAngle) * random(2, 5),
                            vy: sin(debrisAngle) * random(2, 5) - 3, // Initial upward velocity
                            size: random(3, 8),
                            color: tile.type === "ground" ? color(120, 80, 40) : color(180, 140, 100),
                            gravity: 0.3,
                            life: random(30, 60)
                        });
                    }
                    
                    tiles.splice(i, 1);
                }
            }
            
            // Add smoke cloud
            for (let i = 0; i < 20; i++) {
                const angle = random(0, TWO_PI);
                const distance = random(0, explosionRadius * 0.8);
                
                smokeParticles.push({
                    x: lemmingCenter.x + cos(angle) * distance,
                    y: lemmingCenter.y + sin(angle) * distance,
                    vx: cos(angle) * random(0.3, 1),
                    vy: sin(angle) * random(0.3, 1) - 1, // Slight upward drift
                    size: random(8, 15),
                    color: color(220, 220, 220),
                    life: random(40, 80),
                    alpha: 200
                });
            }
            
            // Check for other lemmings caught in explosion
            for (let i = lemmings.length - 1; i >= 0; i--) {
                const otherLemming = lemmings[i];
                // Skip the exploding lemming
                if (otherLemming === lemming) continue;
                
                const otherCenter = {
                    x: otherLemming.x + otherLemming.width / 2,
                    y: otherLemming.y + otherLemming.height / 2
                };
                
                const distance = dist(lemmingCenter.x, lemmingCenter.y, otherCenter.x, otherCenter.y);
                
                if (distance < explosionRadius * 0.7) {
                    // This lemming is caught in the explosion
                    otherLemming.isDead = true;
                }
            }
        }
        
        function updateParticles() {
            // Update explosion particles
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95; // Slow down over time
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    explosionParticles.splice(i, 1);
                }
            }
            
            // Update debris particles
            for (let i = debrisParticles.length - 1; i >= 0; i--) {
                const debris = debrisParticles[i];
                
                debris.x += debris.vx;
                debris.y += debris.vy;
                debris.vy += debris.gravity; // Apply gravity
                debris.vx *= 0.98; // Air resistance
                debris.life--;
                
                // Bounce off ground
                for (let j = 0; j < tiles.length; j++) {
                    const tile = tiles[j];
                    if (
                        debris.x >= tile.x && 
                        debris.x <= tile.x + tile.width && 
                        debris.y + debris.size >= tile.y && 
                        debris.y + debris.size <= tile.y + 5
                    ) {
                        debris.y = tile.y - debris.size;
                        debris.vy = -debris.vy * 0.5; // Bounce with energy loss
                        break;
                    }
                }
                
                if (debris.life <= 0) {
                    debrisParticles.splice(i, 1);
                }
            }
            
            // Update sparkle particles
            for (let i = sparkleParticles.length - 1; i >= 0; i--) {
                const sparkle = sparkleParticles[i];
                
                sparkle.x += sparkle.vx;
                sparkle.y += sparkle.vy;
                sparkle.rotation += 0.1; // Rotate sparkles
                sparkle.life--;
                
                if (sparkle.life <= 0) {
                    sparkleParticles.splice(i, 1);
                }
            }
            
            // Update smoke particles
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const smoke = smokeParticles[i];
                
                smoke.x += smoke.vx;
                smoke.y += smoke.vy;
                smoke.size += 0.2; // Expand smoke
                smoke.alpha = map(smoke.life, 0, 60, 0, smoke.alpha); // Fade out
                smoke.life--;
                
                if (smoke.life <= 0) {
                    smokeParticles.splice(i, 1);
                }
            }
            
            // Update dig particles
            for (let i = digParticles.length - 1; i >= 0; i--) {
                const particle = digParticles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // Gravity
                particle.life--;
                
                if (particle.life <= 0) {
                    digParticles.splice(i, 1);
                }
            }
            
            // Update build particles
            for (let i = buildParticles.length - 1; i >= 0; i--) {
                const particle = buildParticles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                if (particle.life <= 0) {
                    buildParticles.splice(i, 1);
                }
            }
            
            // Update bash particles
            for (let i = bashParticles.length - 1; i >= 0; i--) {
                const particle = bashParticles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.9; // Slow down
                particle.life--;
                
                if (particle.life <= 0) {
                    bashParticles.splice(i, 1);
                }
            }
        }
 
        






        // Mouse interaction
        function mousePressed() {
            if (gameState !== "playing" || !selectedAbility) return;
            
            // Find the clicked lemming
            let clickedLemming = null;
            let smallestDistance = Infinity;
            
            // Find the closest lemming to the click point
            for (let i = 0; i < lemmings.length; i++) {
                const lemming = lemmings[i];
                const lemmingCenterX = lemming.x + lemming.width / 2;
                const lemmingCenterY = lemming.y + lemming.height / 2;
                
                const distance = dist(mouseX, mouseY, lemmingCenterX, lemmingCenterY);
                
                // Check if click is within an expanded hitbox
                if (
                    distance < smallestDistance &&
                    mouseX >= lemming.x - 5 && 
                    mouseX <= lemming.x + lemming.width + 5 && 
                    mouseY >= lemming.y - 5 && 
                    mouseY <= lemming.y + lemming.height + 5
                ) {
                    clickedLemming = lemming;
                    smallestDistance = distance;
                }
            }
            
            if (clickedLemming) {
                // Apply selected ability and create feedback effect
                if (applyAbility(clickedLemming, selectedAbility)) {
                    // Success feedback - create indicators around the lemming
                    for (let i = 0; i < 8; i++) {
                        const angle = i * PI / 4;
                        sparkleParticles.push({
                            x: clickedLemming.x + clickedLemming.width/2 + cos(angle) * 15,
                            y: clickedLemming.y + clickedLemming.height/2 + sin(angle) * 15,
                            vx: cos(angle) * 0.5,
                            vy: sin(angle) * 0.5,
                            size: 4,
                            color: getAbilityColor(selectedAbility),
                            life: 20,
                            rotation: angle
                        });
                    }
                }
            }
        }
        
        function getAbilityColor(ability) {
            switch (ability) {
                case "digger": return color(140, 100, 60);
                case "blocker": return color(255, 70, 70);
                case "builder": return color(180, 140, 100);
                case "basher": return color(255, 180, 70);
                case "climber": return color(70, 180, 70);
                case "floater": return color(100, 200, 255);
                case "bomber": return color(255, 100, 100);
                default: return color(255, 255, 255);
            }
        }
        
// 1. Fix blockers not blocking other lemmings
// Add this function after the isNextToWall function
function checkBlockerCollision(lemming) {
    for (let i = 0; i < lemmings.length; i++) {
        const blocker = lemmings[i];
        
        // Skip if not a blocker or self
        if (!blocker.isBlocking || lemming === blocker) continue;
        
        // Check if the lemming is close to the blocker
        const distanceX = Math.abs((lemming.x + lemming.width/2) - (blocker.x + blocker.width/2));
        
        // Check if they're at similar heights
        if (Math.abs((lemming.y + lemming.height) - (blocker.y + blocker.height)) < 10) {
            // If approaching the blocker in its blocking range
            if (distanceX < blocker.width && 
               ((lemming.direction > 0 && lemming.x < blocker.x) || 
                (lemming.direction < 0 && lemming.x > blocker.x))) {
                return true;
            }
        }
    }
    return false;
}

// 2. Fix lemmings falling off edges
// Modify the isTileInFront function
function isTileInFront(lemming) {
    // More accurate edge detection
    const checkX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
    const footY = lemming.y + lemming.height;
    const checkDistance = lemming.width * 0.5; // Increased check distance
    
    // Check screen boundaries
    if ((lemming.direction > 0 && checkX + checkDistance >= world.width) ||
        (lemming.direction < 0 && checkX - checkDistance <= 0)) {
        // Hit screen edge, turn around
        lemming.direction *= -1;
        return true;
    }
    
    // First check for same-level tiles
    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        
        if (lemming.direction > 0) {
            // Check right edge
            if (
                checkX + checkDistance >= tile.x && 
                checkX <= tile.x + tile.width && 
                footY >= tile.y - 4 && // Increased tolerance
                footY <= tile.y + 4
            ) {
                return true;
            }
        } else {
            // Check left edge
            if (
                checkX - checkDistance <= tile.x + tile.width && 
                checkX >= tile.x && 
                footY >= tile.y - 4 && 
                footY <= tile.y + 4
            ) {
                return true;
            }
        }
    }
    
    // 3. Fix stair climbing - improve detection of stairs
    const maxStepUp = 12; // Increased maximum height for stair climbing
    const maxStepDown = 8; // Allow stepping down a bit
    
    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        
        if (lemming.direction > 0) {
            // Check right edge for stairs
            if (
                checkX + checkDistance >= tile.x && 
                checkX <= tile.x + tile.width && 
                footY > tile.y - maxStepUp && 
                footY < tile.y + maxStepDown
            ) {
                // This is a stair - smoothly adjust the lemming's height
                lemming.y = tile.y - lemming.height;
                return true;
            }
        } else {
            // Check left edge for stairs
            if (
                checkX - checkDistance <= tile.x + tile.width && 
                checkX >= tile.x && 
                footY > tile.y - maxStepUp && 
                footY < tile.y + maxStepDown
            ) {
                // This is a stair - smoothly adjust the lemming's height
                lemming.y = tile.y - lemming.height;
                return true;
            }
        }
    }
    
    return false;
}

// 4. Fix the updateLemming function to use blocker collision and improve behaviors
function updateLemming(lemming) {
    // Advance animation frame
    lemming.animationFrame += lemming.animationSpeed * gameSpeed;
    
    // Bomb countdown
    if (lemming.isBombing) {
        lemming.bombTimer++;
        if (lemming.bombTimer >= lemming.bombLimit) {
            // Create explosion
            explode(lemming);
            lemming.isDead = true;
            return;
        }
    }
    
    // Check if lemming reached the exit
    exits.forEach(exit => {
        // More accurate hitbox for the exit door
        if (
            lemming.x + lemming.width/2 >= exit.x + exit.width * 0.2 && 
            lemming.x + lemming.width/2 <= exit.x + exit.width * 0.8 && 
            lemming.y >= exit.y + exit.height * 0.3 && 
            lemming.y <= exit.y + exit.height * 0.9
        ) {
            lemming.reachedExit = true;
        }
    });
    
    // Check if lemming fell off the world
    if (lemming.y > world.height) {
        lemming.isDead = true;
        return;
    }
    
    // Default to falling
    lemming.isFalling = true;
    
    // Check collision with tiles below with improved handling of uneven terrain
    let foundGround = false;
    let highestGroundY = Infinity;

    tiles.forEach(tile => {
        // If lemming is above the tile
        if (
            lemming.x + lemming.width * 0.3 < tile.x + tile.width && 
            lemming.x + lemming.width * 0.7 > tile.x
        ) {
            // Check for ground at various distances below
            const distanceToTile = tile.y - (lemming.y + lemming.height);
            
            if (distanceToTile >= 0 && distanceToTile <= 5) {
                // This is ground below us
                foundGround = true;
                
                // Keep track of the highest ground (smallest distance)
                if (tile.y < highestGroundY) {
                    highestGroundY = tile.y;
                }
            }
        }
    });

    if (foundGround) {
        lemming.isFalling = false;
        lemming.y = highestGroundY - lemming.height;
        
        // Reset falling-related states when landing
        if (lemming.isFloating) {
            lemming.isFloating = false;
            if (lemming.hasFloaterAbility) {
                lemming.isWalking = true;
            }
        }
        
        // Ensure walking is enabled when on ground
        if (!lemming.isDigging && !lemming.isBuilding && !lemming.isBashing && 
            !lemming.isBlocking && !lemming.isClimbing) {
            lemming.isWalking = true;
        }
    } else {
        // No ground found - we're falling
        if (lemming.isClimbing && isNextToWall(lemming)) {
            // Climb up the wall
            lemming.y -= 1 * gameSpeed;
        } else if (lemming.isFloating) {
            lemming.y += 1 * gameSpeed * 0.5; // Float slowly
        } else {
            lemming.y += 4 * gameSpeed; // Fall normally
            
            // If lemming has floater but not using it yet
            if (lemming.hasFloaterAbility && !lemming.isFloating && lemming.isFalling) {
                // Check if falling far enough to use floater
                let willFallFar = true;
                // Check for ground beneath
                for (let checkY = lemming.y + lemming.height; checkY < lemming.y + lemming.height + 60; checkY += 5) {
                    for (let i = 0; i < tiles.length; i++) {
                        const tile = tiles[i];
                        if (
                            lemming.x + lemming.width * 0.5 > tile.x && 
                            lemming.x + lemming.width * 0.5 < tile.x + tile.width && 
                            checkY >= tile.y && 
                            checkY <= tile.y + tile.height
                        ) {
                            willFallFar = false;
                            break;
                        }
                    }
                    if (!willFallFar) break;
                }
                
                if (willFallFar) {
                    lemming.isFloating = true;
                }
            }
        }
        return;
    }

    // 5. Fix digger to use 15 degrees instead of 45 degrees
    if (lemming.isDigging) {
        // Create dig particles
        if (frameCount % 5 === 0) {
            for (let i = 0; i < 3; i++) {
                digParticles.push({
                    x: lemming.x + lemming.width/2 + random(-5, 5) + (lemming.direction * 3),
                    y: lemming.y + lemming.height,
                    vx: random(-1, 1) + (lemming.direction * 1),
                    vy: random(-2, 0),
                    size: random(3, 5),
                    color: color(140, 100, 60),
                    life: random(15, 30)
                });
            }
        }                
        
        // Dig through tiles below at a consistent rate for 15-degree angle
        lemming.digCounter++;
        if (lemming.digCounter >= 8) {
            lemming.digCounter = 0;
            
            // Find tiles under the lemming in a more focused area
            let tilesRemoved = 0;
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                // Adjust detection area to be ahead in the lemming's direction for 15-degree digging
                const offsetX = lemming.direction * 1.5; // Less offset for 15-degree angle
                if (
                    lemming.x + lemming.width * 0.3 + offsetX < tile.x + tile.width && 
                    lemming.x + lemming.width * 0.7 + offsetX > tile.x && 
                    lemming.y + lemming.height <= tile.y && 
                    lemming.y + lemming.height + 5 >= tile.y
                ) {
                    // Remove tile and create debris particles
                    for (let j = 0; j < 4; j++) {
                        debrisParticles.push({
                            x: tile.x + tile.width/2,
                            y: tile.y + tile.height/2,
                            vx: random(-2, 2) + (lemming.direction * 1),
                            vy: random(-4, -1),
                            size: random(3, 6),
                            color: color(120, 80, 40),
                            gravity: 0.2,
                            life: random(20, 40)
                        });
                    }
                    
                    tiles.splice(i, 1);
                    tilesRemoved++;
                    
                    // Lower the lemming slightly and move horizontally less for 15-degree angle
                    lemming.y += 3;
                    lemming.x += lemming.direction * 0.8; // Reduced horizontal movement for 15-degree angle
                }
            }
            
            // If no tiles were removed, stop digging
            if (tilesRemoved === 0) {
                lemming.isDigging = false;
                lemming.isWalking = true;
            }
        }
        return;
    }

    // Handle building - no changes needed
    if (lemming.isBuilding) {
        // Create build particles occasionally
        if (frameCount % 8 === 0) {
            buildParticles.push({
                x: lemming.x + (lemming.direction > 0 ? lemming.width : 0),
                y: lemming.y + lemming.height * 0.6,
                vx: lemming.direction * random(0.5, 1.5),
                vy: random(-1, -0.2),
                size: random(3, 5),
                color: color(180, 140, 100),
                life: random(15, 30)
            });
        }
        
        if (lemming.buildCounter < lemming.buildLimit) {
            // On the first build, set the build direction
            if (lemming.buildCounter === 0) {
                lemming.buildDirection = lemming.direction;
            }
            
            // Every few frames, add a new brick
            if (frameCount % 10 === 0) {
                // Add a new stair piece in the building direction
                const newTile = {
                    x: lemming.x + (lemming.buildDirection * (lemming.buildCounter+1) * 4),
                    y: lemming.y + lemming.height - (lemming.buildCounter+1) * 2,
                    width: world.tileSize * 0.6,
                    height: world.tileSize * 0.4,
                    type: "bridge"
                };
                
                tiles.push(newTile);
                
                // Move lemming up and forward to follow the stair pattern
                lemming.x += lemming.buildDirection * 4;
                lemming.y -= 2;
                
                lemming.buildCounter++;
            }
        } else {
            lemming.isBuilding = false;
            lemming.isWalking = true;
            lemming.buildCounter = 0;
            lemming.buildDirection = 0;
        }
        return;
    }
    
    // 6. Fix basher - improve bashing detection and effectiveness
    if (lemming.isBashing) {
        // Create bash particles
        if (frameCount % 3 === 0) { // Increased frequency
            for (let i = 0; i < 3; i++) { // More particles
                bashParticles.push({
                    x: lemming.x + (lemming.direction > 0 ? lemming.width : 0),
                    y: lemming.y + lemming.height * 0.5 + random(-8, 8),
                    vx: lemming.direction * random(2, 4),
                    vy: random(-1, 1),
                    size: random(3, 5),
                    color: color(255, 255, 255),
                    life: random(10, 20)
                });
            }
        }
        
        // Improved check for walls to bash through
        let didBash = false;
        for (let i = tiles.length - 1; i >= 0; i--) {
            const tile = tiles[i];
            
            // More aggressive wall detection for bashing
            const lemmingFront = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const lemmingFrontTest = lemmingFront + lemming.direction * 10; // Longer detection distance
            
            if (
                ((lemming.direction > 0 && 
                 lemmingFront <= tile.x + 5 && // Allow some overlap
                 lemmingFrontTest >= tile.x) ||
                (lemming.direction < 0 && 
                 lemmingFront >= tile.x + tile.width - 5 && // Allow some overlap
                 lemmingFrontTest <= tile.x + tile.width)) &&
                lemming.y + lemming.height * 0.1 < tile.y + tile.height &&
                lemming.y + lemming.height * 0.9 > tile.y
            ) {
                // Remove the wall tile with more particles
                for (let j = 0; j < 8; j++) {
                    debrisParticles.push({
                        x: tile.x + (lemming.direction > 0 ? 0 : tile.width),
                        y: tile.y + random(0, tile.height),
                        vx: lemming.direction * random(2, 5),
                        vy: random(-3, 3),
                        size: random(3, 7),
                        color: color(120, 80, 40),
                        gravity: 0.2,
                        life: random(20, 40)
                    });
                }
                
                // Remove the tile
                tiles.splice(i, 1);
                didBash = true;
                
                // Move forward more aggressively
                lemming.x += lemming.direction * 3;
                break;
            }
        }
        
        // If no bashing occurred, increment the counter and move forward slightly
        if (!didBash) {
            lemming.bashCounter++;
            
            // Move forward slowly while bashing
            lemming.x += lemming.direction * 1.5;
            
            // If we've been bashing for a while with no results, stop
            if (lemming.bashCounter >= lemming.bashLimit) {
                lemming.isBashing = false;
                lemming.isWalking = true;
                lemming.bashCounter = 0;
            }
        } else {
            // Reset the counter when we successfully bash
            lemming.bashCounter = 0;
        }
        
        return;
    }
    
    // Handle walking - check for blockers
    if (lemming.isWalking) {
        // Check for blockers before moving
        if (checkBlockerCollision(lemming)) {
            lemming.direction *= -1; // Turn around
        } else {
            // Move in current direction
            lemming.x += lemming.direction * lemming.speed * gameSpeed;
            
            // Check for walls
            if (isWallInFront(lemming)) {
                if (lemming.hasClimberAbility) {
                    lemming.isClimbing = true;
                    lemming.isWalking = false;
                } else {
                    lemming.direction *= -1; // Turn around
                }
            }
            
            // Check for edges - more precise
            if (!isTileInFront(lemming)) {
                // Check for gap size - may be able to walk over small gaps
                let gapSize = checkGapSize(lemming);
                
                if (gapSize <= 4) {
                    // Small enough gap to walk over
                    lemming.x += lemming.direction * gapSize * world.tileSize;
                } else {
                    // Too big - start falling
                    lemming.isWalking = false;
                    lemming.isFalling = true;
                }
            }
        }
    }
}

// 7. Allow multiple taskings by modifying applyAbility
function applyAbility(lemming, ability) {
    if (abilities[ability] <= 0) return false;
    
    // REMOVED: Prevent applying abilities to blockers and bombers
    // We'll allow most transitions between abilities
    
    let abilityApplied = false;
    
    switch (ability) {
        case "digger":
            // Allow digger even if falling
            lemming.isDigging = true;
            // Reset incompatible states but preserve permanent abilities
            lemming.isWalking = false;
            lemming.isBuilding = false;
            lemming.isBashing = false;
            lemming.isClimbing = false;
            // The blocker status can be overridden now
            lemming.isBlocking = false;
            lemming.digCounter = 0;
            abilityApplied = true;
            break;
            
        case "blocker":
            if (!lemming.isFalling) {
                lemming.isBlocking = true;
                // Reset incompatible states
                lemming.isWalking = false;
                lemming.isDigging = false;
                lemming.isBuilding = false;
                lemming.isBashing = false;
                lemming.isClimbing = false;
                // Allow bomber to remain active if already set
                abilityApplied = true;
            }
            break;
            
        case "builder":
            if (!lemming.isFalling) {
                lemming.isBuilding = true;
                // Reset incompatible states
                lemming.isWalking = false;
                lemming.isDigging = false;
                lemming.isBashing = false;
                lemming.isClimbing = false;
                lemming.isBlocking = false;
                lemming.buildCounter = 0;
                abilityApplied = true;
            }
            break;
            
        case "basher":
            if (!lemming.isFalling) {
                // More permissive wall detection for bashers
                let hasWall = false;
                // Check more aggressively for any potential wall
                const lemmingFront = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
                const lemmingFrontTest = lemmingFront + lemming.direction * 15;
                
                for (let i = 0; i < tiles.length; i++) {
                    const tile = tiles[i];
                    if (
                        ((lemming.direction > 0 && 
                          lemmingFront <= tile.x + 10 && 
                          lemmingFrontTest >= tile.x) ||
                         (lemming.direction < 0 && 
                          lemmingFront >= tile.x + tile.width - 10 && 
                          lemmingFrontTest <= tile.x + tile.width)) &&
                        lemming.y + lemming.height * 0.1 < tile.y + tile.height &&
                        lemming.y + lemming.height * 0.9 > tile.y
                    ) {
                        hasWall = true;
                        break;
                    }
                }
                
                if (hasWall) {
                    lemming.isBashing = true;
                    // Reset incompatible states
                    lemming.isWalking = false;
                    lemming.isDigging = false;
                    lemming.isBuilding = false;
                    lemming.isClimbing = false;
                    lemming.isBlocking = false;
                    lemming.bashCounter = 0;
                    abilityApplied = true;
                }
            }
            break;
            
        case "climber":
            // Always allow climber ability
            lemming.hasClimberAbility = true;
            
            // Immediately start climbing if next to a wall
            if (isWallInFront(lemming) && !lemming.isFalling) {
                lemming.isClimbing = true;
                lemming.isWalking = false;
            }
            
            abilityApplied = true;
            break;
            
        case "floater":
            // Always allow floater ability
            lemming.hasFloaterAbility = true;
            
            // Immediately start floating if falling
            if (lemming.isFalling) {
                lemming.isFloating = true;
            }
            
            abilityApplied = true;
            break;
            
        case "bomber":
            // Always allow bomber ability, regardless of other states
            lemming.isBombing = true;
            lemming.bombTimer = 0;
            abilityApplied = true;
            break;
    }
    
    if (abilityApplied) {
        // Decrement ability count
        abilities[ability]--;
        
        // Update ability count in UI
        document.getElementById(`${ability}-count`).textContent = abilities[ability];
        
        // If used all of this ability, deselect it
        if (abilities[ability] <= 0) {
            selectedAbility = null;
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
    }
    
    return abilityApplied;
}        
        // Helper functions
        function isWallInFront(lemming) {
            // Check slightly ahead for walls
            const checkDistance = 5;
            const checkX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const checkY = lemming.y + lemming.height / 2;
            
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                
                // Different check based on direction
                if (lemming.direction > 0) {
                    // Moving right - check for wall to the right
                    if (
                        checkX <= tile.x && 
                        checkX + checkDistance >= tile.x && 
                        checkY >= tile.y && 
                        checkY <= tile.y + tile.height
                    ) {
                        return true;
                    }
                } else {
                    // Moving left - check for wall to the left
                    if (
                        checkX >= tile.x + tile.width && 
                        checkX - checkDistance <= tile.x + tile.width && 
                        checkY >= tile.y && 
                        checkY <= tile.y + tile.height
                    ) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function isNextToWall(lemming) {
            // More precise wall detection for climbing
            const wallDistance = 3;
            
            // Check left wall
            if (lemming.direction < 0) {
                const leftX = lemming.x - wallDistance;
                const checkY = lemming.y + lemming.height / 2;
                
                for (let i = 0; i < tiles.length; i++) {
                    const tile = tiles[i];
                    if (
                        leftX <= tile.x + tile.width && 
                        leftX >= tile.x && 
                        checkY >= tile.y && 
                        checkY <= tile.y + tile.height
                    ) {
                        return true;
                    }
                }
            }
            // Check right wall
            else {
                const rightX = lemming.x + lemming.width + wallDistance;
                const checkY = lemming.y + lemming.height / 2;
                
                for (let i = 0; i < tiles.length; i++) {
                    const tile = tiles[i];
                    if (
                        rightX >= tile.x && 
                        rightX <= tile.x + tile.width && 
                        checkY >= tile.y && 
                        checkY <= tile.y + tile.height
                    ) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
// The issue is in the updateLemming function. There's an illegal return statement at line 2177.
// The problem is that there are sections of code that were meant to replace parts of the updateLemming function
// but were incorrectly placed outside of it. Here's the fix:

function updateLemming(lemming) {
    // Advance animation frame
    lemming.animationFrame += lemming.animationSpeed * gameSpeed;
    
    // Bomb countdown
    if (lemming.isBombing) {
        lemming.bombTimer++;
        if (lemming.bombTimer >= lemming.bombLimit) {
            // Create explosion
            explode(lemming);
            lemming.isDead = true;
            return;
        }
    }
    
    // Check if lemming reached the exit
    exits.forEach(exit => {
        // More accurate hitbox for the exit door
        if (
            lemming.x + lemming.width/2 >= exit.x + exit.width * 0.2 && 
            lemming.x + lemming.width/2 <= exit.x + exit.width * 0.8 && 
            lemming.y >= exit.y + exit.height * 0.3 && 
            lemming.y <= exit.y + exit.height * 0.9
        ) {
            lemming.reachedExit = true;
        }
    });
    
    // Check if lemming fell off the world
    if (lemming.y > world.height) {
        lemming.isDead = true;
        return;
    }
    
    // Default to falling
    lemming.isFalling = true;
    
    // Check collision with tiles below with improved handling of uneven terrain
    let foundGround = false;
    let highestGroundY = Infinity;

    tiles.forEach(tile => {
        // If lemming is above the tile
        if (
            lemming.x + lemming.width * 0.3 < tile.x + tile.width && 
            lemming.x + lemming.width * 0.7 > tile.x
        ) {
            // Check for ground at various distances below
            const distanceToTile = tile.y - (lemming.y + lemming.height);
            
            if (distanceToTile >= 0 && distanceToTile <= 5) {
                // This is ground below us
                foundGround = true;
                
                // Keep track of the highest ground (smallest distance)
                if (tile.y < highestGroundY) {
                    highestGroundY = tile.y;
                }
            }
        }
    });

    if (foundGround) {
        lemming.isFalling = false;
        lemming.y = highestGroundY - lemming.height;
        
        // Reset falling-related states when landing
        if (lemming.isFloating) {
            lemming.isFloating = false;
            if (lemming.hasFloaterAbility) {
                lemming.isWalking = true;
            }
        }
        
        // Ensure walking is enabled when on ground
        if (!lemming.isDigging && !lemming.isBuilding && !lemming.isBashing && 
            !lemming.isBlocking && !lemming.isClimbing) {
            lemming.isWalking = true;
        }
    } else {
        // No ground found - we're falling
        if (lemming.isClimbing && isNextToWall(lemming)) {
            // Climb up the wall
            lemming.y -= 1 * gameSpeed;
        } else if (lemming.isFloating) {
            lemming.y += 1 * gameSpeed * 0.5; // Float slowly
        } else {
            lemming.y += 4 * gameSpeed; // Fall normally
            
            // If lemming has floater but not using it yet
            if (lemming.hasFloaterAbility && !lemming.isFloating && lemming.isFalling) {
                // Check if falling far enough to use floater
                let willFallFar = true;
                // Check for ground beneath
                for (let checkY = lemming.y + lemming.height; checkY < lemming.y + lemming.height + 60; checkY += 5) {
                    for (let i = 0; i < tiles.length; i++) {
                        const tile = tiles[i];
                        if (
                            lemming.x + lemming.width * 0.5 > tile.x && 
                            lemming.x + lemming.width * 0.5 < tile.x + tile.width && 
                            checkY >= tile.y && 
                            checkY <= tile.y + tile.height
                        ) {
                            willFallFar = false;
                            break;
                        }
                    }
                    if (!willFallFar) break;
                }
                
                if (willFallFar) {
                    lemming.isFloating = true;
                }
            }
        }
        return;
    }

    // Handle digging - IMPROVED
    if (lemming.isDigging) {
        // Create dig particles
        if (frameCount % 5 === 0) {
            for (let i = 0; i < 3; i++) {
                digParticles.push({
                    x: lemming.x + lemming.width/2 + random(-5, 5) + (lemming.direction * 3),
                    y: lemming.y + lemming.height,
                    vx: random(-1, 1) + (lemming.direction * 1),
                    vy: random(-2, 0),
                    size: random(3, 5),
                    color: color(140, 100, 60),
                    life: random(15, 30)
                });
            }
        }                
        
        // Dig through tiles below at a consistent rate for 45-degree angle
        lemming.digCounter++;
        if (lemming.digCounter >= 8) {
            lemming.digCounter = 0;
            
            // Find tiles under the lemming in a more focused area, but slightly ahead in direction
            let tilesRemoved = 0;
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                // Adjust detection area to be ahead in the lemming's direction for 45-degree digging
                const offsetX = lemming.direction * 5; // Offset in the direction the lemming is facing
                if (
                    lemming.x + lemming.width * 0.3 + offsetX < tile.x + tile.width && 
                    lemming.x + lemming.width * 0.7 + offsetX > tile.x && 
                    lemming.y + lemming.height <= tile.y && 
                    lemming.y + lemming.height + 5 >= tile.y
                ) {
                    // Remove tile and create debris particles
                    for (let j = 0; j < 4; j++) {
                        debrisParticles.push({
                            x: tile.x + tile.width/2,
                            y: tile.y + tile.height/2,
                            vx: random(-2, 2) + (lemming.direction * 1),
                            vy: random(-4, -1),
                            size: random(3, 6),
                            color: color(120, 80, 40),
                            gravity: 0.2,
                            life: random(20, 40)
                        });
                    }
                    
                    tiles.splice(i, 1);
                    tilesRemoved++;
                    
                    // Lower the lemming slightly as they dig and move horizontally
                    lemming.y += 2;
                    lemming.x += lemming.direction * 2; // Move horizontally for 45-degree angle
                }
            }
            
            // If no tiles were removed, stop digging
            if (tilesRemoved === 0) {
                lemming.isDigging = false;
                lemming.isWalking = true;
            }
        }
        return;
    }

    // Handle building - IMPROVED
    if (lemming.isBuilding) {
        // Create build particles occasionally
        if (frameCount % 8 === 0) {
            buildParticles.push({
                x: lemming.x + (lemming.direction > 0 ? lemming.width : 0),
                y: lemming.y + lemming.height * 0.6,
                vx: lemming.direction * random(0.5, 1.5),
                vy: random(-1, -0.2),
                size: random(3, 5),
                color: color(180, 140, 100),
                life: random(15, 30)
            });
        }
        
        if (lemming.buildCounter < lemming.buildLimit) {
            // On the first build, set the build direction
            if (lemming.buildCounter === 0) {
                lemming.buildDirection = lemming.direction;
            }
            
            // Every few frames, add a new brick
            if (frameCount % 10 === 0) {
                // Add a new stair piece in the building direction
                const newTile = {
                    x: lemming.x + (lemming.buildDirection * (lemming.buildCounter+1) * 4),
                    y: lemming.y + lemming.height - (lemming.buildCounter+1) * 2,
                    width: world.tileSize * 0.6,
                    height: world.tileSize * 0.4,
                    type: "bridge"
                };
                
                tiles.push(newTile);
                
                // Move lemming up and forward to follow the stair pattern
                lemming.x += lemming.buildDirection * 4;
                lemming.y -= 2;
                
                lemming.buildCounter++;
            }
        } else {
            lemming.isBuilding = false;
            lemming.isWalking = true;
            lemming.buildCounter = 0;
            lemming.buildDirection = 0;
        }
        return;
    }
    
    // Handle bashing - IMPROVED
    if (lemming.isBashing) {
        // Create bash particles
        if (frameCount % 4 === 0) {
            for (let i = 0; i < 2; i++) {
                bashParticles.push({
                    x: lemming.x + (lemming.direction > 0 ? lemming.width : 0),
                    y: lemming.y + lemming.height * 0.5 + random(-5, 5),
                    vx: lemming.direction * random(1, 3),
                    vy: random(-0.5, 0.5),
                    size: random(2, 4),
                    color: color(255, 255, 255),
                    life: random(10, 20)
                });
            }
        }
        
        // Check if there's a wall to bash through
        let didBash = false;
        for (let i = tiles.length - 1; i >= 0; i--) {
            const tile = tiles[i];
            
            // Check if tile is in front of lemming at bashing height
            const lemmingFront = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const lemmingFrontTest = lemmingFront + lemming.direction * 5;
            
            if (
                lemmingFront * lemming.direction <= (tile.x + (lemming.direction > 0 ? 0 : tile.width)) * lemming.direction &&
                lemmingFrontTest * lemming.direction >= (tile.x + (lemming.direction > 0 ? 0 : tile.width)) * lemming.direction &&
                lemming.y + lemming.height * 0.3 < tile.y + tile.height &&
                lemming.y + lemming.height * 0.8 > tile.y
            ) {
                // Remove the wall tile with particles
                for (let j = 0; j < 6; j++) {
                    debrisParticles.push({
                        x: tile.x + (lemming.direction > 0 ? 0 : tile.width),
                        y: tile.y + random(0, tile.height),
                        vx: lemming.direction * random(1, 3),
                        vy: random(-2, 2),
                        size: random(3, 6),
                        color: color(120, 80, 40),
                        gravity: 0.2,
                        life: random(20, 40)
                    });
                }
                
                // Remove the tile
                tiles.splice(i, 1);
                didBash = true;
                
                // Move forward a little
                lemming.x += lemming.direction * 2;
                break;
            }
        }
        
        // If no bashing occurred, increment the counter
        if (!didBash) {
            lemming.bashCounter++;
            
            // Move forward slowly while bashing
            lemming.x += lemming.direction * 1;
            
            // If we've been bashing for a while with no results, stop
            if (lemming.bashCounter >= lemming.bashLimit) {
                lemming.isBashing = false;
                lemming.isWalking = true;
                lemming.bashCounter = 0;
            }
        } else {
            // Reset the counter when we successfully bash
            lemming.bashCounter = 0;
        }
        
        return;
    }
    
    // Handle walking
    if (lemming.isWalking) {
        // Move in current direction
        lemming.x += lemming.direction * lemming.speed * gameSpeed;
        
        // Check for walls
        if (isWallInFront(lemming)) {
            if (lemming.hasClimberAbility) {
                lemming.isClimbing = true;
                lemming.isWalking = false;
            } else {
                lemming.direction *= -1; // Turn around
            }
        }
        
        // Check for edges - more precise
        if (!isTileInFront(lemming)) {
            // Check for gap size - may be able to walk over small gaps
            let gapSize = checkGapSize(lemming);
            
            if (gapSize <= 4) {
                // Small enough gap to walk over
                lemming.x += lemming.direction * gapSize * world.tileSize;
            } else {
                // Too big - start falling
                lemming.isWalking = false;
                lemming.isFalling = true;
            }
        }
    }
}

// Fix for the isTileInFront function
function isTileInFront(lemming) {
    // More accurate edge detection
    const checkX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
    const footY = lemming.y + lemming.height;
    const checkDistance = lemming.width * 0.25; // Check just a bit ahead
    
    // First check for same-level tiles
    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        
        if (lemming.direction > 0) {
            // Check right edge
            if (
                checkX + checkDistance >= tile.x && 
                checkX <= tile.x + tile.width && 
                footY >= tile.y - 2 && 
                footY <= tile.y + 2
            ) {
                return true;
            }
        } else {
            // Check left edge
            if (
                checkX - checkDistance <= tile.x + tile.width && 
                checkX >= tile.x && 
                footY >= tile.y - 2 && 
                footY <= tile.y + 2
            ) {
                return true;
            }
        }
    }
        
    // Also check for stairs - tiles that are slightly higher
    const maxStepUp = 8; // Maximum height a lemming can step up
    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        
        if (lemming.direction > 0) {
            // Check right edge for stairs
            if (
                checkX + checkDistance >= tile.x && 
                checkX <= tile.x + tile.width && 
                footY > tile.y - maxStepUp && 
                footY < tile.y
            ) {
                // This is a step up - move the lemming up
                lemming.y = tile.y - lemming.height;
                return true;
            }
        } else {
            // Check left edge for stairs
            if (
                checkX - checkDistance <= tile.x + tile.width && 
                checkX >= tile.x && 
                footY > tile.y - maxStepUp && 
                footY < tile.y
            ) {
                // This is a step up - move the lemming up
                lemming.y = tile.y - lemming.height;
                return true;
            }
        }
    }
    
    return false;
}
    
        function checkGapSize(lemming) {
            // Check how wide the gap is in front of the lemming
            let gapSize = 0;
            let currentX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const footY = lemming.y + lemming.height;
            const maxCheck = 5; // Maximum tiles to check ahead
            
            // Check up to maxCheck tiles ahead
            for (let i = 1; i <= maxCheck; i++) {
                const checkX = currentX + (lemming.direction * i * world.tileSize);
                let foundGround = false;
                
                // Check for ground at this position
                for (let j = 0; j < tiles.length; j++) {
                    const tile = tiles[j];
                    
                    if (
                        checkX >= tile.x && 
                        checkX <= tile.x + tile.width && 
                        footY >= tile.y - 2 && 
                        footY <= tile.y + 2
                    ) {
                        foundGround = true;
                        break;
                    }
                }
                
                if (foundGround) {
                    gapSize = i - 1; // Gap size is one less than where we found ground
                    break;
                }
                
                // If we reached the end of our check range, gap is at least maxCheck
                if (i === maxCheck) {
                    gapSize = maxCheck;
                }
            }
            
            return gapSize;
        }
        
        // Drawing functions
        function drawWorld() {
            // Draw tiles with refined appearance
            push();
            imageMode(CORNER);
            
            // First pass: Draw all ground tiles
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                
                if (tile.type === "ground") {
                    image(spriteAssets.tileSets.ground, tile.x, tile.y, tile.width, tile.height);
                }
            }
            
            // Second pass: Draw all bridge pieces (so they appear on top)
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                
                if (tile.type === "bridge") {
                    image(spriteAssets.tileSets.bridge, tile.x, tile.y, tile.width, tile.height);
                }
            }
            
            // Draw entrances
            entrances.forEach(entrance => {
                image(spriteAssets.entranceSprite, entrance.x, entrance.y, entrance.width, entrance.height);
            });
            
            // Draw exits - with subtle pulsing effect
            exits.forEach(exit => {
                // Create a subtle glow effect
                const pulseAmount = sin(frameCount * 0.05) * 10;
                noStroke();
                fill(100, 255, 100, 40 + pulseAmount);
                ellipse(exit.x + exit.width/2, exit.y + exit.height/2, exit.width + pulseAmount, exit.height + pulseAmount);
                
                // Draw exit sprite
                image(spriteAssets.exitSprite, exit.x, exit.y, exit.width, exit.height);
            });
            
            pop();
        }
        
        function drawLemmings() {
            lemmings.forEach(lemming => {
                push();
                imageMode(CENTER);
                
                // Handle flipping based on direction
                const flip = lemming.direction < 0;
                if (flip) {
                    scale(-1, 1);
                    translate(-lemming.x * 2 - lemming.width, 0);
                }
                
                // Draw shadow beneath lemming for depth
                noStroke();
                fill(0, 0, 0, 40);
                ellipse(
                    lemming.x + lemming.width/2,
                    lemming.y + lemming.height + 2,
                    lemming.width * 0.8,
                    4
                );
                
                // Get animation frame index accounting for lemming's animation counter
                let frameIndex = 0;
                let spriteToUse = null;
                
                // Select appropriate animation based on lemming state
                if (lemming.isBlocking) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingBlock.length;
                    spriteToUse = spriteAssets.lemmingBlock[frameIndex];
                } 
                else if (lemming.isDigging) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingDig.length;
                    spriteToUse = spriteAssets.lemmingDig[frameIndex];
                }
                else if (lemming.isBuilding) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingBuild.length;
                    spriteToUse = spriteAssets.lemmingBuild[frameIndex];
                }
                else if (lemming.isBashing) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingBash.length;
                    spriteToUse = spriteAssets.lemmingBash[frameIndex];
                }
                else if (lemming.isClimbing) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingClimb.length;
                    spriteToUse = spriteAssets.lemmingClimb[frameIndex];
                }
                else if (lemming.isFloating) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingFloat.length;
                    spriteToUse = spriteAssets.lemmingFloat[frameIndex];
                }
                else if (lemming.isFalling) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingFall.length;
                    spriteToUse = spriteAssets.lemmingFall[frameIndex];
                }
                else if (lemming.isBombing) {
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingBomb.length;
                    spriteToUse = spriteAssets.lemmingBomb[frameIndex];
                }
                else {
                    // Default to walking animation
                    frameIndex = Math.floor(lemming.animationFrame) % spriteAssets.lemmingWalk.length;
                    spriteToUse = spriteAssets.lemmingWalk[frameIndex];
                }
                
                // Draw the lemming sprite
                if (spriteToUse) {
                    // Apply color tint to make lemmings slightly different
                    tint(
                        255 * lemming.colorTint[0], 
                        255 * lemming.colorTint[1], 
                        255 * lemming.colorTint[2]
                    );
                    
                    image(
                        spriteToUse,
                        lemming.x + lemming.width/2,
                        lemming.y + lemming.height/2,
                        spriteToUse.width * lemming.colorTint[2], // Apply size tint
                        spriteToUse.height * lemming.colorTint[2]
                    );
                    
                    // Reset tint
                    noTint();
                }
                
                // Draw special ability indicators
                if (lemming.hasClimberAbility && !lemming.isClimbing) {
                    noStroke();
                    fill(40, 160, 40, 180);
                    rect(lemming.x, lemming.y - 8, 5, 3);
                }
                
                if (lemming.hasFloaterAbility && !lemming.isFloating) {
                    noStroke();
                    fill(180, 30, 30, 180);
                    rect(lemming.x + lemming.width - 5, lemming.y - 8, 5, 3);
                }
                
                // Draw bombing countdown if applicable
                if (lemming.isBombing) {
                    const bombProgress = lemming.bombTimer / lemming.bombLimit;
                    
                    // Countdown visualization
                    if (frameCount % 15 < 8) {
                        fill(255, 0, 0, 200);
                        noStroke();
                        ellipse(lemming.x + lemming.width/2, lemming.y - 10, 15, 15);
                        
                        // Countdown numbers
                        fill(255);
                        textSize(10);
                        textAlign(CENTER, CENTER);
                        const countdown = Math.ceil((lemming.bombLimit - lemming.bombTimer) / 60);
                        text(countdown, lemming.x + lemming.width/2, lemming.y - 10);
                    }
                    
                    // Progress bar
                    noStroke();
                    fill(80, 80, 80, 200);
                    rect(lemming.x - 2, lemming.y - 4, lemming.width + 4, 3, 2);
                    
                    fill(255, 50, 50);
                    rect(lemming.x - 1, lemming.y - 3, (lemming.width + 2) * bombProgress, 1, 1);
                }
                
                pop();
            });
        }
        
        function drawParticles() {
            push();
            imageMode(CENTER);
            noStroke();
            
            // Draw explosion particles
            for (let i = 0; i < explosionParticles.length; i++) {
                const p = explosionParticles[i];
                const alpha = map(p.life, 0, 40, 0, 255);
                
                fill(red(p.color), green(p.color), blue(p.color), alpha);
                ellipse(p.x, p.y, p.radius * 2);
                
                // Add white center for more dramatic effect
                fill(255, 255, 200, alpha);
                ellipse(p.x, p.y, p.radius);
            }
            
            // Draw debris particles
            for (let i = 0; i < debrisParticles.length; i++) {
                const p = debrisParticles[i];
                const alpha = map(p.life, 0, 60, 0, 255);
                
                fill(red(p.color), green(p.color), blue(p.color), alpha);
                rect(p.x, p.y, p.size, p.size);
            }
            
            // Draw dig particles
            for (let i = 0; i < digParticles.length; i++) {
                const p = digParticles[i];
                const alpha = map(p.life, 0, 30, 0, 255);
                
                fill(red(p.color), green(p.color), blue(p.color), alpha);
                rect(p.x, p.y, p.size, p.size, 1);
            }
            
            // Draw build particles
            for (let i = 0; i < buildParticles.length; i++) {
                const p = buildParticles[i];
                const alpha = map(p.life, 0, 30, 0, 255);
                
                fill(red(p.color), green(p.color), blue(p.color), alpha);
                rect(p.x, p.y, p.size, p.size, 1);
            }
            
            // Draw bash particles
            for (let i = 0; i < bashParticles.length; i++) {
                const p = bashParticles[i];
                const alpha = map(p.life, 0, 20, 0, 255);
                
                fill(red(p.color), green(p.color), blue(p.color), alpha);
                rect(p.x, p.y, p.size, p.size/2, 1);
            }
            
            // Draw sparkle particles with rotation
            for (let i = 0; i < sparkleParticles.length; i++) {
                const p = sparkleParticles[i];
                const alpha = map(p.life, 0, 30, 0, 255);
                
                push();
                translate(p.x, p.y);
                rotate(p.rotation + frameCount * 0.1);
                
                fill(red(p.color), green(p.color), blue(p.color), alpha);
                
                // Star shape
                beginShape();
                for (let j = 0; j < 5; j++) {
                    const angle = TWO_PI / 5 * j;
                    const x1 = cos(angle) * p.size;
                    const y1 = sin(angle) * p.size;
                    vertex(x1, y1);
                    
                    const angleHalf = TWO_PI / 5 * (j + 0.5);
                    const x2 = cos(angleHalf) * (p.size / 2);
                    const y2 = sin(angleHalf) * (p.size / 2);
                    vertex(x2, y2);
                }
                endShape(CLOSE);
                pop();
            }
            
            // Draw smoke particles
            for (let i = 0; i < smokeParticles.length; i++) {
                const p = smokeParticles[i];
                
                fill(red(p.color), green(p.color), blue(p.color), p.alpha * (p.life / 80));
                ellipse(p.x, p.y, p.size);
            }
            
            pop();
        }
        
        function updateHUD() {
            // Update numerical displays
            document.getElementById('lemmings-saved').textContent = lemminsSaved;
            document.getElementById('time-display').textContent = formatTime(levelTime);
            
            // Update progress bars
            updateProgressBars();
        }
        
        function checkLevelCompletion() {
            if (lemminsSaved >= lemmingsRequired) {
                // Level completed
                gameState = "levelComplete";
                
                // Update level complete screen
                document.getElementById('saved-count').textContent = lemminsSaved;
                document.getElementById('required-count').textContent = lemmingsRequired;
                document.getElementById('completion-time').textContent = formatTime(levelTime);
                
                document.getElementById('level-complete').style.display = 'flex';
            } else {
                // Game over
                gameState = "gameOver";
                
                // Update game over screen
                document.getElementById('game-over-message').textContent = 
                    `You saved ${lemminsSaved} out of ${totalLemmings} lemmings, but needed ${lemmingsRequired}!`;
                
                document.getElementById('game-over').style.display = 'flex';
            }
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }





    </script>
</body>
</html>
