<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Musical Waterfall - Interactive Piano Learning Game</title>
  <style>
    :root {
      --primary-color: #4b0082;
      --secondary-color: #FF6D00;
      --tertiary-color: #2196F3;
      --background-color: #f0f8ff;
      --white-key-color: #ffffff;
      --black-key-color: #222222;
      --highlight-color: #FFEB3B;
      --correct-color: #4CAF50;
      --incorrect-color: #FF5252;
      --key-border-radius: 6px;
      --falling-note-speed: 2.5s;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
      background-color: var(--background-color);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transition: background-color 0.5s;
    }

    header {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 10px;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 10;
    }

    h1 {
      font-size: 28px;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .container {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 165px);
      position: relative;
      overflow: hidden;
    }

    .game-area {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: linear-gradient(180deg, #e0f7fa 0%, #bbdefb 100%);
    }

    .staff-container {
      height: 150px;
      background-color: white;
      margin: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    #staff {
      width: 100%;
      height: 100%;
    }

    .waterfall {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .piano-container {
      position: relative;
      height: 180px;
      margin: 10px;
      display: flex;
      justify-content: center;
    }

    .piano {
      position: relative;
      height: 100%;
      display: flex;
      border-radius: var(--key-border-radius);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }

    .key {
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s ease;
    }

    .white-key {
      width: 40px;
      height: 180px;
      background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
      border: 1px solid #ddd;
      border-radius: 0 0 var(--key-border-radius) var(--key-border-radius);
      z-index: 1;
      box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
    }

    .black-key {
      position: absolute;
      width: 24px;
      height: 110px;
      background: linear-gradient(to bottom, #333333 0%, #111111 100%);
      border-radius: 0 0 var(--key-border-radius) var(--key-border-radius);
      z-index: 2;
      top: 0;
      box-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
    }

    .key-label {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 12px;
      color: #555;
      font-weight: bold;
    }

    .black-key .key-label {
      color: white;
      bottom: 5px;
      font-size: 10px;
    }

    .white-key.active {
      background: linear-gradient(to bottom, #e3f2fd 0%, #bbdefb 100%);
      transform: translateY(2px);
      box-shadow: inset 0 -5px 10px rgba(0, 0, 0, 0.1);
    }

    .black-key.active {
      background: linear-gradient(to bottom, #444 0%, #222 100%);
      transform: translateY(2px);
    }

    .white-key.highlighted {
      background-color: var(--highlight-color);
      animation: pulse 2s infinite;
    }

    .black-key.highlighted {
      background: linear-gradient(to bottom, #FFD600 0%, #FFC107 100%);
      animation: pulse 2s infinite;
    }

    .white-key.correct {
      background: linear-gradient(to bottom, var(--correct-color) 0%, #2E7D32 100%);
    }

    .black-key.correct {
      background: linear-gradient(to bottom, #2E7D32 0%, #1B5E20 100%);
    }

    .white-key.incorrect {
      background: linear-gradient(to bottom, var(--incorrect-color) 0%, #C62828 100%);
    }

    .black-key.incorrect {
      background: linear-gradient(to bottom, #C62828 0%, #B71C1C 100%);
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.7);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(255, 235, 59, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0);
      }
    }

    .falling-note {
      position: absolute;
      width: 36px;
      height: 50px;
      border-radius: 8px;
      z-index: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
      transition: opacity 0.3s, transform 0.3s;
      animation-timing-function: cubic-bezier(0.4, 0, 1, 1);
      animation-fill-mode: forwards;
      opacity: 0.9;
      backdrop-filter: blur(2px);
      text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .falling-note span {
      position: relative;
      z-index: 2;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
    }
    
    .falling-note::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: inherit;
      filter: blur(4px);
      opacity: 0.7;
      z-index: 1;
      border-radius: inherit;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
      z-index: 10;
    }

    button {
      padding: 8px 15px;
      border: none;
      border-radius: 50px;
      background: linear-gradient(145deg, var(--primary-color), var(--secondary-color));
      color: white;
      font-family: inherit;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.2s;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
      filter: brightness(1.1);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      filter: brightness(0.95);
    }

    select {
      padding: 8px 15px;
      border: 1px solid #ddd;
      border-radius: 50px;
      background-color: white;
      font-family: inherit;
      font-size: 14px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .progress-container {
      width: 100%;
      background-color: rgba(255, 255, 255, 0.3);
      height: 10px;
      border-radius: 5px;
      margin: 5px 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      border-radius: 5px;
      width: 0%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      transition: width 0.3s;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
    }

    /* Character styles */
    .character {
      position: absolute;
      width: 100px;
      height: 100px;
      z-index: 5;
      transition: all 0.5s ease;
      filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.2));
    }

    #maestro {
      bottom: 190px;
      left: 10px;
    }

    #melody {
      bottom: 190px;
      right: 10px;
    }

    .speech-bubble {
      position: absolute;
      background-color: white;
      border-radius: 10px;
      padding: 10px;
      max-width: 200px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: opacity 0.3s, transform 0.3s;
      z-index: 10;
      border: 2px solid var(--primary-color);
    }
    
    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 20px;
      border-width: 10px 10px 0;
      border-style: solid;
      border-color: white transparent transparent;
    }
    
    .speech-bubble::before {
      content: '';
      position: absolute;
      bottom: -12px;
      left: 18px;
      border-width: 12px 12px 0;
      border-style: solid;
      border-color: var(--primary-color) transparent transparent;
      z-index: -1;
    }

    #maestro-bubble {
      left: 90px;
      bottom: 250px;
    }

    #melody-bubble {
      right: 90px;
      bottom: 250px;
    }
    
    #melody-bubble::after {
      left: auto;
      right: 20px;
    }
    
    #melody-bubble::before {
      left: auto;
      right: 18px;
    }

    /* Particle effects */
    .particle {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      background-image: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      mix-blend-mode: screen;
    }

    /* Settings panel */
    .settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      z-index: 20;
      display: none;
      width: 80%;
      max-width: 500px;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .settings-panel h2 {
      margin-bottom: 15px;
      color: var(--primary-color);
      text-align: center;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .settings-group {
      margin-bottom: 15px;
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .settings-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: var(--primary-color);
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #555;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .close-button:hover {
      transform: rotate(90deg);
      color: var(--primary-color);
    }

    /* Background animation */
    .background-animation {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.2;
      pointer-events: none;
      background: linear-gradient(45deg, 
        rgba(75, 0, 130, 0.1) 0%, 
        rgba(255, 109, 0, 0.1) 50%, 
        rgba(33, 150, 243, 0.1) 100%);
      background-size: 200% 200%;
      animation: gradientBG 15s ease infinite;
    }
    
    @keyframes gradientBG {
      0% { background-position: 0% 50% }
      50% { background-position: 100% 50% }
      100% { background-position: 0% 50% }
    }

    /* Score display */
    .score-display {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 16px;
      font-weight: bold;
      color: var(--primary-color);
      z-index: 10;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(5px);
    }

    /* Star rating */
    .star-rating {
      display: flex;
      justify-content: center;
      margin-top: 5px;
    }

    .star {
      color: #ccc;
      font-size: 24px;
      transition: color 0.3s;
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.1));
    }

    .star.filled {
      color: #FFD700;
      animation: starPulse 0.5s ease-in-out;
    }
    
    @keyframes starPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    /* Modal for quiz and rewards */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      backdrop-filter: blur(5px);
    }

    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      transform: scale(0.8) translateY(20px);
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      border: 3px solid var(--secondary-color);
    }

    .modal.active {
      opacity: 1;
      visibility: visible;
    }

    .modal.active .modal-content {
      transform: scale(1) translateY(0);
    }

    .quiz-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin-top: 20px;
    }

    .quiz-option {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      background-color: #f9f9f9;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .quiz-option:hover {
      background-color: #f0f0f0;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .quiz-option.selected {
      border-color: var(--primary-color);
      background-color: rgba(75, 0, 130, 0.1);
    }

    .quiz-option.correct {
      border-color: var(--correct-color);
      background-color: rgba(76, 175, 80, 0.2);
    }

    .quiz-option.incorrect {
      border-color: var(--incorrect-color);
      background-color: rgba(255, 82, 82, 0.2);
    }

    /* Trophy animation */
    .trophy {
      width: 120px;
      height: 120px;
      margin: 20px auto;
      position: relative;
      filter: drop-shadow(0 5px 15px rgba(255, 215, 0, 0.6));
      transform-origin: center bottom;
    }
    
    .float-animation {
      animation: float 3s ease-in-out infinite, glow 2s ease-in-out infinite alternate;
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6)); }
      to { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.9)); }
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .white-key {
        width: 30px;
      }
      
      .black-key {
        width: 18px;
      }
      
      .falling-note {
        width: 28px;
      }
      
      .controls {
        flex-wrap: wrap;
      }
      
      .character {
        width: 70px;
        height: 70px;
      }
    }

    /* Note colors with gradients for 3D effect */
    .note-C { 
      background: linear-gradient(135deg, #FF6347, #FF4500);
    }
    .note-D { 
      background: linear-gradient(135deg, #FFA500, #FF8C00);
    }
    .note-E { 
      background: linear-gradient(135deg, #FFFF00, #FFD700);
    }
    .note-F { 
      background: linear-gradient(135deg, #32CD32, #228B22);
    }
    .note-G { 
      background: linear-gradient(135deg, #1E90FF, #0000CD);
    }
    .note-A { 
      background: linear-gradient(135deg, #9370DB, #6A5ACD);
    }
    .note-B { 
      background: linear-gradient(135deg, #FF69B4, #C71585);
    }
    
    /* Additional classes for animations */
    @keyframes fall {
      from { 
        top: -50px; 
        transform: translateX(0) rotate(0deg);
        opacity: 0.9;
      }
      10% {
        opacity: 1;
      }
      to { 
        top: calc(100% - 50px); 
        transform: translateX(var(--random-x, 0)) rotate(var(--random-rotate, 0deg));
        opacity: 0.7;
      }
    }
    
    @keyframes sparkle {
      0% { opacity: 0; transform: scale(0) rotate(0deg); }
      50% { opacity: 1; transform: scale(1) rotate(180deg); }
      100% { opacity: 0; transform: scale(0) rotate(360deg); }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(-2deg); }
      50% { transform: translateY(-20px) rotate(2deg); }
    }
    
    .float-animation {
      animation: float 3s ease-in-out infinite;
    }
    
    .sparkle {
      position: absolute;
      width: 40px;
      height: 40px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='%23FFD700' d='M12 1l3.22 6.52 7.2 1.04-5.21 5.08 1.23 7.18L12 17.77 5.56 20.82l1.23-7.18-5.21-5.08 7.2-1.04L12 1z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      pointer-events: none;
      z-index: 100;
      animation: sparkle 0.6s ease-in-out;
      filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.8));
    }
    
    /* Learning path */
    .learning-path {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 5px 0;
    }
    
    .path-segment {
      width: 20px;
      height: 10px;
      margin: 0 2px;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      transition: all 0.3s;
    }
    
    .path-segment.completed {
      background-color: var(--correct-color);
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
    }
    
    .path-segment.current {
      background-color: var(--highlight-color);
      box-shadow: 0 0 8px rgba(255, 235, 59, 0.8);
      animation: pulse 2s infinite;
    }
  </style>
</head>
<body>
  <header>
    <h1>Musical Waterfall</h1>
    <div class="progress-container">
      <div id="progress-bar" class="progress-bar"></div>
    </div>
    <div class="learning-path" id="learning-path"></div>
  </header>

  <div class="container">
    <div class="score-display">
      Score: <span id="score">0</span>
      <div class="star-rating">
        <span class="star" id="star1">★</span>
        <span class="star" id="star2">★</span>
        <span class="star" id="star3">★</span>
      </div>
    </div>

    <div class="staff-container">
      <canvas id="staff"></canvas>
    </div>

    <div class="game-area">
      <div class="waterfall" id="waterfall"></div>
      
      <div class="character" id="maestro">
        <svg viewBox="0 0 100 100" width="100" height="100">
          <!-- Maestro body -->
          <ellipse cx="50" cy="70" rx="30" ry="30" fill="#1E88E5"/>
          <!-- Maestro head -->
          <circle cx="50" cy="30" r="20" fill="#FFD700"/>
          <!-- Eyes -->
          <circle cx="42" cy="25" r="4" fill="white"/>
          <circle cx="58" cy="25" r="4" fill="white"/>
          <circle cx="42" cy="25" r="2" fill="black"/>
          <circle cx="58" cy="25" r="2" fill="black"/>
          <!-- Smile -->
          <path d="M40,35 Q50,45 60,35" stroke="black" stroke-width="2" fill="transparent"/>
          <!-- Beard -->
          <path d="M40,40 Q50,50 60,40 Q50,45 40,40" fill="#A0522D"/>
          <!-- Hair -->
          <path d="M30,20 Q50,0 70,20 Q50,10 30,20" fill="#A0522D"/>
          <!-- Glasses -->
          <circle cx="42" cy="25" r="6" stroke="black" stroke-width="1.5" fill="transparent"/>
          <circle cx="58" cy="25" r="6" stroke="black" stroke-width="1.5" fill="transparent"/>
          <line x1="48" y1="25" x2="52" y2="25" stroke="black" stroke-width="1.5"/>
          <!-- Arms -->
          <line x1="30" y1="60" x2="15" y2="50" stroke="#FFD700" stroke-width="5" stroke-linecap="round"/>
          <line x1="70" y1="60" x2="85" y2="50" stroke="#FFD700" stroke-width="5" stroke-linecap="round"/>
          <!-- Legs -->
          <line x1="40" y1="95" x2="35" y2="110" stroke="#1E88E5" stroke-width="8" stroke-linecap="round"/>
          <line x1="60" y1="95" x2="65" y2="110" stroke="#1E88E5" stroke-width="8" stroke-linecap="round"/>
        </svg>
      </div>
      
      <div class="speech-bubble" id="maestro-bubble">Let's learn to play music!</div>
      
      <div class="character" id="melody">
        <svg viewBox="0 0 100 100" width="100" height="100">
          <!-- Melody body -->
          <ellipse cx="50" cy="70" rx="25" ry="30" fill="#FF6D00"/>
          <!-- Melody head -->
          <circle cx="50" cy="30" r="20" fill="#FFEB3B"/>
          <!-- Eyes -->
          <circle cx="42" cy="25" r="4" fill="white"/>
          <circle cx="58" cy="25" r="4" fill="white"/>
          <circle cx="42" cy="25" r="2" fill="black"/>
          <circle cx="58" cy="25" r="2" fill="black"/>
          <!-- Smile -->
          <path d="M40,35 Q50,45 60,35" stroke="black" stroke-width="2" fill="transparent"/>
          <!-- Arms -->
          <line x1="30" y1="60" x2="15" y2="70" stroke="#FFEB3B" stroke-width="5" stroke-linecap="round"/>
          <line x1="70" y1="60" x2="85" y2="70" stroke="#FFEB3B" stroke-width="5" stroke-linecap="round"/>
          <!-- Legs -->
          <line x1="40" y1="95" x2="35" y2="110" stroke="#FF6D00" stroke-width="8" stroke-linecap="round"/>
          <line x1="60" y1="95" x2="65" y2="110" stroke="#FF6D00" stroke-width="8" stroke-linecap="round"/>
          <!-- Fraction symbol -->
          <line x1="40" y1="15" x2="60" y2="15" stroke="black" stroke-width="2"/>
          <text x="50" y="12" text-anchor="middle" font-size="10">1</text>
          <text x="50" y="25" text-anchor="middle" font-size="10">2</text>
        </svg>
      </div>
      
      <div class="speech-bubble" id="melody-bubble">Play the notes as they fall!</div>
    </div>

    <div class="piano-container">
      <div class="piano" id="piano">
        <!-- Piano keys will be added by JavaScript -->
      </div>
    </div>
  </div>

  <div class="controls">
    <button id="start-btn">Start</button>
    <button id="reset-btn">Reset</button>
    <select id="song-select">
      <option value="mary">Mary Had a Little Lamb</option>
      <option value="twinkle">Twinkle Twinkle Little Star</option>
      <option value="happy">Happy Birthday</option>
      <option value="jingle">Jingle Bells</option>
      <option value="row">Row, Row, Row Your Boat</option>
      <option value="itsy">Itsy Bitsy Spider</option>
      <option value="baby">Baby Shark</option>
      <option value="wheels">Wheels on the Bus</option>
      <option value="letitgo">Let It Go (Simplified)</option>
    </select>
    <button id="toggle-highlight">Highlight Keys</button>
    <button id="settings-btn">Settings</button>
  </div>

  <div class="settings-panel" id="settings-panel">
    <button class="close-button" id="close-settings">&times;</button>
    <h2>Game Settings</h2>
    
    <div class="settings-group">
      <label for="note-speed">Note Speed</label>
      <input type="range" id="note-speed" min="1" max="5" step="0.5" value="2.5">
      <div class="settings-row">
        <span>Slow</span>
        <span>Fast</span>
      </div>
    </div>
    
    <div class="settings-group">
      <label for="volume">Volume</label>
      <input type="range" id="volume" min="0" max="1" step="0.1" value="0.7">
      <div class="settings-row">
        <span>Off</span>
        <span>Max</span>
      </div>
    </div>
    
    <div class="settings-group">
      <label>Visual Effects</label>
      <div class="settings-row">
        <span>Particles</span>
        <input type="checkbox" id="particles-toggle" checked>
      </div>
      <div class="settings-row">
        <span>Animations</span>
        <input type="checkbox" id="animations-toggle" checked>
      </div>
    </div>
    
    <div class="settings-group">
      <label for="difficulty">Difficulty Level</label>
      <select id="difficulty">
        <option value="easy">Easy - Learn the Basics</option>
        <option value="medium">Medium - Growing Skills</option>
        <option value="hard">Hard - Piano Master</option>
      </select>
    </div>
    
    <button id="save-settings">Save Settings</button>
  </div>

  <div class="modal" id="quiz-modal">
    <div class="modal-content">
      <h2>Music Theory Quiz</h2>
      <p id="quiz-question"></p>
      <div class="quiz-options" id="quiz-options"></div>
      <button id="check-answer" style="margin-top: 20px;">Check Answer</button>
    </div>
  </div>

  <div class="modal" id="reward-modal">
    <div class="modal-content">
      <h2>Congratulations!</h2>
      <p id="reward-text">You're becoming a piano master!</p>
      <div class="trophy" id="trophy">
        <!-- Trophy SVG -->
        <svg viewBox="0 0 100 100" width="100" height="100">
          <!-- Cup -->
          <path d="M30,10 L70,10 Q90,10 90,30 Q90,60 70,60 Q55,70 55,90 L45,90 Q45,70 30,60 Q10,60 10,30 Q10,10 30,10 Z" fill="#FFD700"/>
          <!-- Base -->
          <rect x="25" y="90" width="50" height="10" fill="#A67C00"/>
          <rect x="15" y="100" width="70" height="10" fill="#8D6E00"/>
          <!-- Music Symbol -->
          <line x1="35" y1="30" x2="65" y2="30" stroke="#4b0082" stroke-width="3"/>
          <text x="50" y="25" text-anchor="middle" font-size="20" fill="#4b0082">1</text>
          <text x="50" y="45" text-anchor="middle" font-size="20" fill="#4b0082">2</text>
        </svg>
      </div>
      <div id="reward-animation"></div>
      <button id="continue-btn">Continue</button>
    </div>
  </div>

  <script>
    // Game state
    const gameState = {
      currentSong: 'mary',
      currentNoteIndex: 0,
      score: 0,
      streak: 0,
      maxStreak: 0,
      totalNotes: 0,
      correctNotes: 0,
      isPlaying: false,
      highlightEnabled: true,
      settings: {
        noteSpeed: 2.5,
        volume: 0.7,
        particles: true,
        animations: true,
        difficulty: 'easy'
      },
      userAnswer: null,
      fallingNotes: [],
      timers: [],
      animations: {
        particles: [],
        timers: []
      }
    };

    // DOM Elements
    const elements = {
      piano: document.getElementById('piano'),
      waterfall: document.getElementById('waterfall'),
      staff: document.getElementById('staff'),
      staffCtx: document.getElementById('staff').getContext('2d'),
      progressBar: document.getElementById('progress-bar'),
      scoreDisplay: document.getElementById('score'),
      learningPath: document.getElementById('learning-path'),
      startBtn: document.getElementById('start-btn'),
      resetBtn: document.getElementById('reset-btn'),
      songSelect: document.getElementById('song-select'),
      toggleHighlightBtn: document.getElementById('toggle-highlight'),
      settingsBtn: document.getElementById('settings-btn'),
      closeSettingsBtn: document.getElementById('close-settings'),
      settingsPanel: document.getElementById('settings-panel'),
      noteSpeedSlider: document.getElementById('note-speed'),
      volumeSlider: document.getElementById('volume'),
      particlesToggle: document.getElementById('particles-toggle'),
      animationsToggle: document.getElementById('animations-toggle'),
      difficultySelect: document.getElementById('difficulty'),
      saveSettingsBtn: document.getElementById('save-settings'),
      stars: [
        document.getElementById('star1'),
        document.getElementById('star2'),
        document.getElementById('star3')
      ],
      maestro: document.getElementById('maestro'),
      maestroBubble: document.getElementById('maestro-bubble'),
      melody: document.getElementById('melody'),
      melodyBubble: document.getElementById('melody-bubble'),
      quizModal: document.getElementById('quiz-modal'),
      quizQuestion: document.getElementById('quiz-question'),
      quizOptions: document.getElementById('quiz-options'),
      checkAnswerBtn: document.getElementById('check-answer'),
      rewardModal: document.getElementById('reward-modal'),
      rewardText: document.getElementById('reward-text'),
      rewardAnimation: document.getElementById('reward-animation'),
      continueBtn: document.getElementById('continue-btn'),
      trophy: document.getElementById('trophy')
    };

    // Piano configuration
    const whiteKeys = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5'];
    const blackKeys = ['C#4', 'D#4', 'F#4', 'G#4', 'A#4', 'C#5', 'D#5', 'F#5', 'G#5', 'A#5'];
    const keyboardMapping = {
      'z': 'C4', 's': 'C#4', 'x': 'D4', 'd': 'D#4', 'c': 'E4', 'v': 'F4',
      'g': 'F#4', 'b': 'G4', 'h': 'G#4', 'n': 'A4', 'j': 'A#4', 'm': 'B4',
      ',': 'C5', 'l': 'C#5', '.': 'D5', ';': 'D#5', '/': 'E5'
    };

    // Note colors (used for the falling notes)
    const noteColors = {
      'C': '#FF6347',  // Tomato
      'D': '#FFA500',  // Orange
      'E': '#FFFF00',  // Yellow
      'F': '#32CD32',  // Lime Green
      'G': '#1E90FF',  // Dodger Blue
      'A': '#9370DB',  // Medium Purple
      'B': '#FF69B4',  // Hot Pink
    };

    // Duration mapping
    const durationMapping = {
      1: 'quarter',
      2: 'half',
      4: 'whole',
      0.5: 'eighth',
      0.25: 'sixteenth'
    };

    // Song library
    const songLibrary = {
      'mary': [
        ['E4', 1], ['D4', 1], ['C4', 1], ['D4', 1],
        ['E4', 1], ['E4', 1], ['E4', 2],
        ['D4', 1], ['D4', 1], ['D4', 2],
        ['E4', 1], ['G4', 1], ['G4', 2],
        ['E4', 1], ['D4', 1], ['C4', 1], ['D4', 1],
        ['E4', 1], ['E4', 1], ['E4', 1], ['E4', 1],
        ['D4', 1], ['D4', 1], ['E4', 1], ['D4', 1], ['C4', 4]
      ],
      'twinkle': [
        ['C4', 1], ['C4', 1], ['G4', 1], ['G4', 1],
        ['A4', 1], ['A4', 1], ['G4', 2],
        ['F4', 1], ['F4', 1], ['E4', 1], ['E4', 1],
        ['D4', 1], ['D4', 1], ['C4', 2],
        ['G4', 1], ['G4', 1], ['F4', 1], ['F4', 1],
        ['E4', 1], ['E4', 1], ['D4', 2],
        ['G4', 1], ['G4', 1], ['F4', 1], ['F4', 1],
        ['E4', 1], ['E4', 1], ['D4', 2],
        ['C4', 1], ['C4', 1], ['G4', 1], ['G4', 1],
        ['A4', 1], ['A4', 1], ['G4', 2],
        ['F4', 1], ['F4', 1], ['E4', 1], ['E4', 1],
        ['D4', 1], ['D4', 1], ['C4', 2]
      ],
      'happy': [
        ['C4', 0.5], ['C4', 0.5], ['D4', 1], ['C4', 1], ['F4', 1], ['E4', 2],
        ['C4', 0.5], ['C4', 0.5], ['D4', 1], ['C4', 1], ['G4', 1], ['F4', 2],
        ['C4', 0.5], ['C4', 0.5], ['C5', 1], ['A4', 1], ['F4', 1], ['E4', 1], ['D4', 1],
        ['A#4', 0.5], ['A#4', 0.5], ['A4', 1], ['F4', 1], ['G4', 1], ['F4', 2]
      ],
      'jingle': [
        ['E4', 1], ['E4', 1], ['E4', 2],
        ['E4', 1], ['E4', 1], ['E4', 2],
        ['E4', 1], ['G4', 1], ['C4', 1], ['D4', 1],
        ['E4', 4],
        ['F4', 1], ['F4', 1], ['F4', 1], ['F4', 1],
        ['F4', 1], ['E4', 1], ['E4', 1], ['E4', 1],
        ['E4', 1], ['D4', 1], ['D4', 1], ['E4', 1],
        ['D4', 2], ['G4', 2]
      ],
      'row': [
        ['C4', 1], ['D4', 1], ['E4', 2],
        ['E4', 1], ['F4', 1], ['G4', 2],
        ['G4', 0.5], ['A4', 0.5], ['G4', 0.5], ['F4', 0.5], ['E4', 2],
        ['C4', 1], ['G4', 1], ['C5', 2]
      ],
      'itsy': [
        ['C4', 1], ['D4', 1], ['E4', 1], ['G4', 1],
        ['E4', 1], ['G4', 1], ['A4', 2],
        ['A4', 1], ['G4', 1], ['E4', 1], ['G4', 1],
        ['E4', 1], ['G4', 1], ['A4', 2],
        ['A4', 1], ['G4', 1], ['E4', 1], ['G4', 1],
        ['E4', 1], ['G4', 1], ['A4', 2],
        ['A4', 1], ['G4', 1], ['E4', 1], ['G4', 1],
        ['E4', 1], ['G4', 1], ['A4', 2],
      ],
      'baby': [
        ['D4', 1], ['E4', 1], ['G4', 2], // Ba-by
        ['D4', 1], ['E4', 1], ['G4', 2], // Shark
        ['D4', 1], ['E4', 1], ['G4', 1], ['G4', 1], // doo doo
        ['G4', 1], ['G4', 1], ['G4', 2], // doo doo doo
        ['D4', 1], ['E4', 1], ['G4', 2], // Ba-by
        ['D4', 1], ['E4', 1], ['G4', 2], // Shark
      ],
      'wheels': [
        ['C4', 1], ['C4', 1], ['C4', 1], ['C4', 1], // The wheels on the bus
        ['E4', 1], ['F4', 1], ['G4', 2], // Go round and round
        ['G4', 1], ['A4', 1], ['G4', 1], ['F4', 1], // Round and round
        ['E4', 4], // Round and round
        ['C4', 1], ['C4', 1], ['C4', 1], ['C4', 1], // The wheels on the bus
        ['E4', 1], ['F4', 1], ['G4', 2], // Go round and round
        ['C4', 4], // All through the town
      ],
      'letitgo': [
        ['G4', 1], ['E4', 1], ['F4', 1], ['G4', 2], // Let it go
        ['G4', 1], ['E4', 1], ['F4', 1], ['G4', 2], // Let it go
        ['C4', 1], ['C4', 1], ['D4', 1], ['E4', 1], // Can't hold it back
        ['E4', 1], ['D4', 1], ['E4', 1], ['F4', 2], // Anymore
      ]
    };

    // Music Theory Quiz Questions
    const quizQuestions = [
      {
        question: "What is the name of this note?",
        options: ["C", "D", "E", "F"],
        correctAnswer: "C",
        note: "C4"
      },
      {
        question: "How many beats does a quarter note get?",
        options: ["1", "2", "3", "4"],
        correctAnswer: "1"
      },
      {
        question: "Which of these notes is higher in pitch?",
        options: ["C4", "G4", "E4", "A3"],
        correctAnswer: "G4"
      },
      {
        question: "What does this symbol mean?",
        options: ["Play louder", "Play softer", "Hold the note longer", "Play faster"],
        correctAnswer: "Hold the note longer",
        symbol: "fermata"
      },
      {
        question: "Which of these is NOT a note name?",
        options: ["A", "H", "E", "G"],
        correctAnswer: "H"
      }
    ];

    // Web Audio API setup
    let audioContext;
    let masterGainNode;
    let reverbNode;
    let pianoSamples = {};
    let loadingSamples = false;

    function initAudio() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      masterGainNode = audioContext.createGain();
      masterGainNode.gain.value = gameState.settings.volume;
      
      // Create reverb
      reverbNode = audioContext.createConvolver();
      createReverb(2, 0.8).then(buffer => {
        reverbNode.buffer = buffer;
      });
      
      // Reverb mix (dry/wet)
      const reverbMix = audioContext.createGain();
      reverbMix.gain.value = 0.3; // 30% wet
      
      masterGainNode.connect(audioContext.destination); // Dry signal
      masterGainNode.connect(reverbNode);             // To reverb
      reverbNode.connect(reverbMix);                  // Wet signal
      reverbMix.connect(audioContext.destination);    // Wet to output
    }

    // Initialize audio on user interaction
    document.addEventListener('click', function initAudioOnFirstClick() {
      if (!audioContext) {
        initAudio();
        document.removeEventListener('click', initAudioOnFirstClick);
      }
    }, { once: true });
    
    // Create synthetic reverb impulse
    async function createReverb(duration, decay) {
      const sampleRate = audioContext.sampleRate;
      const length = sampleRate * duration;
      const impulse = audioContext.createBuffer(2, length, sampleRate);
      
      const leftChannel = impulse.getChannelData(0);
      const rightChannel = impulse.getChannelData(1);
      
      for (let i = 0; i < length; i++) {
        const n = i / length;
        // Exponential decay with slight randomness for natural sound
        const amplitude = Math.pow(1 - n, decay) * (1 - n * 0.4);
        
        // Slight stereo effect with phase difference
        leftChannel[i] = (Math.random() * 2 - 1) * amplitude;
        rightChannel[i] = (Math.random() * 2 - 1) * amplitude;
      }
      
      return impulse;
    }

    // Function to play a note with better piano-like sound
    function playNote(note, duration = 0.5) {
      if (!audioContext) initAudio();
      
      // Get the frequency of the note
      const noteFreq = getNoteFrequency(note);
      
      // Complex synthesis for rich piano-like sound
      // Create multiple oscillators for harmonic richness
      const fundamental = audioContext.createOscillator();
      const octave = audioContext.createOscillator();
      const fifth = audioContext.createOscillator();
      
      fundamental.type = 'triangle'; // Warm base tone
      octave.type = 'sine';         // Pure octave
      fifth.type = 'sine';          // Perfect fifth for harmonic richness
      
      fundamental.frequency.setValueAtTime(noteFreq, audioContext.currentTime);
      octave.frequency.setValueAtTime(noteFreq * 2, audioContext.currentTime);
      fifth.frequency.setValueAtTime(noteFreq * 1.5, audioContext.currentTime);
      
      // Volume envelope for natural piano attack and decay
      const envelope = audioContext.createGain();
      const now = audioContext.currentTime;
      
      // Fast but smooth attack (not instant - more natural)
      envelope.gain.setValueAtTime(0, now);
      envelope.gain.linearRampToValueAtTime(gameState.settings.volume, now + 0.02);
      
      // Initial decay to sustain level
      envelope.gain.linearRampToValueAtTime(gameState.settings.volume * 0.7, now + 0.1);
      
      // Long gradual decay to zero
      envelope.gain.exponentialRampToValueAtTime(0.001, now + duration);
      
      // Create individual gains for balance
      const fundamentalGain = audioContext.createGain();
      const octaveGain = audioContext.createGain();
      const fifthGain = audioContext.createGain();
      
      fundamentalGain.gain.value = 1.0;    // Full volume for fundamental
      octaveGain.gain.value = 0.4;         // Quieter octave
      fifthGain.gain.value = 0.2;          // Even quieter fifth
      
      // Connect all oscillators to their gains
      fundamental.connect(fundamentalGain);
      octave.connect(octaveGain);
      fifth.connect(fifthGain);
      
      // Connect to envelope
      fundamentalGain.connect(envelope);
      octaveGain.connect(envelope);
      fifthGain.connect(envelope);
      
      // Connect envelope to master gain
      envelope.connect(masterGainNode);
      
      // Play the note
      fundamental.start(now);
      octave.start(now);
      fifth.start(now);
      
      fundamental.stop(now + duration);
      octave.stop(now + duration);
      fifth.stop(now + duration);
      
      // Add subtle noise at attack for realistic piano hammer sound
      addPianoHammerNoise(noteFreq);
      
      return {
        oscillators: [fundamental, octave, fifth],
        envelope: envelope
      };
    }
    
    // Add realistic piano hammer noise at note attack
    function addPianoHammerNoise(frequency) {
      const noise = audioContext.createBufferSource();
      const noiseLength = 0.08; // Very short
      const sampleRate = audioContext.sampleRate;
      const buffer = audioContext.createBuffer(1, sampleRate * noiseLength, sampleRate);
      const data = buffer.getChannelData(0);
      
      // Generate filtered noise with frequency-dependent characteristics
      const freq = frequency / 100;
      for (let i = 0; i < buffer.length; i++) {
        // Exponential decay
        const t = i / buffer.length;
        const envelope = Math.pow(1 - t, 8); // Sharp decay
        
        // Filtered noise (higher frequencies for higher notes)
        const noise = Math.random() * 2 - 1;
        data[i] = noise * envelope * Math.min(0.2, 0.8 - (freq * 0.002));
      }
      
      const noiseGain = audioContext.createGain();
      noiseGain.gain.value = 0.2; // Subtle
      
      noise.buffer = buffer;
      noise.connect(noiseGain);
      noiseGain.connect(masterGainNode);
      
      noise.start();
      noise.stop(audioContext.currentTime + noiseLength);
    }

    // Function to get the frequency of a note
    function getNoteFrequency(note) {
      const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const noteName = note.slice(0, -1);
      const octave = parseInt(note.slice(-1));
      
      // Find the index of the note in the notes array
      const noteIndex = notes.indexOf(noteName);
      
      // Calculate the frequency using the formula: f = 440 * 2^((n-69)/12)
      // where n is the MIDI note number (A4 = 69)
      const midiNote = (octave + 1) * 12 + noteIndex;
      const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
      
      return frequency;
    }

    // Sound effect functions
    function playButtonSound() {
      if (!audioContext) initAudio();
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
      
      gainNode.gain.setValueAtTime(gameState.settings.volume * 0.5, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
      
      oscillator.connect(gainNode);
      gainNode.connect(masterGainNode);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.3);
    }

    function playSuccessSound() {
      if (!audioContext) initAudio();
      
      const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
      
      notes.forEach((frequency, index) => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.1);
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.1);
        gainNode.gain.linearRampToValueAtTime(gameState.settings.volume * 0.5, audioContext.currentTime + index * 0.1 + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + index * 0.1 + 0.3);
        
        oscillator.connect(gainNode);
        gainNode.connect(masterGainNode);
        
        oscillator.start(audioContext.currentTime + index * 0.1);
        oscillator.stop(audioContext.currentTime + index * 0.1 + 0.3);
      });
    }

    function playErrorSound() {
      if (!audioContext) initAudio();
      
      const frequencies = [349.23, 329.63, 311.13]; // F4, E4, D#4
      
      frequencies.forEach((frequency, index) => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.15);
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.15);
        gainNode.gain.linearRampToValueAtTime(gameState.settings.volume * 0.5, audioContext.currentTime + index * 0.15 + 0.01);
        gainNode.gain.linearRampToValueAtTime(0.001, audioContext.currentTime + index * 0.15 + 0.3);
        
        oscillator.connect(gainNode);
        gainNode.connect(masterGainNode);
        
        oscillator.start(audioContext.currentTime + index * 0.15);
        oscillator.stop(audioContext.currentTime + index * 0.15 + 0.3);
      });
    }

    function playCelebrationSound() {
      if (!audioContext) initAudio();
      
      // Major scale ascending and then chord
      const notes = [
        { freq: 523.25, time: 0 },    // C5
        { freq: 587.33, time: 0.15 }, // D5
        { freq: 659.25, time: 0.3 },  // E5
        { freq: 698.46, time: 0.45 }, // F5
        { freq: 783.99, time: 0.6 },  // G5
        { freq: 880.00, time: 0.75 }, // A5
        { freq: 987.77, time: 0.9 },  // B5
        { freq: 1046.50, time: 1.05 }, // C6
        // Final chord
        { freq: 523.25, time: 1.3 }, // C5
        { freq: 659.25, time: 1.3 }, // E5
        { freq: 783.99, time: 1.3 }, // G5
        { freq: 1046.50, time: 1.3 }  // C6
      ];
      
      notes.forEach(note => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime + note.time);
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime + note.time);
        gainNode.gain.linearRampToValueAtTime(gameState.settings.volume * 0.3, audioContext.currentTime + note.time + 0.01);
        
        // Longer sustain for the final chord
        if (note.time === 1.3) {
          gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + note.time + 1.0);
          oscillator.start(audioContext.currentTime + note.time);
          oscillator.stop(audioContext.currentTime + note.time + 1.0);
        } else {
          gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + note.time + 0.2);
          oscillator.start(audioContext.currentTime + note.time);
          oscillator.stop(audioContext.currentTime + note.time + 0.2);
        }
        
        oscillator.connect(gainNode);
        gainNode.connect(masterGainNode);
      });
    }

    // Function to initialize the piano
    function initializePiano() {
      // Clear any existing keys
      elements.piano.innerHTML = '';
      
      // Create white keys
      whiteKeys.forEach((note, index) => {
        const key = document.createElement('div');
        key.className = 'key white-key';
        key.dataset.note = note;
        
        // Add subtle 3D effect with inner shadow
        key.style.boxShadow = 'inset 0 -5px 10px rgba(0, 0, 0, 0.1), 0 2px 3px rgba(0, 0, 0, 0.2)';
        
        const label = document.createElement('div');
        label.className = 'key-label';
        label.textContent = note;
        
        key.appendChild(label);
        key.addEventListener('mousedown', () => handleNotePress(note));
        key.addEventListener('mouseup', () => handleNoteRelease(note));
        key.addEventListener('mouseleave', () => handleNoteRelease(note));
        key.addEventListener('touchstart', (e) => { e.preventDefault(); handleNotePress(note); });
        key.addEventListener('touchend', (e) => { e.preventDefault(); handleNoteRelease(note); });
        
        elements.piano.appendChild(key);
      });
      
      // Create black keys
      blackKeys.forEach((note) => {
        const key = document.createElement('div');
        key.className = 'key black-key';
        key.dataset.note = note;
        
        // Add subtle 3D effect with gradient and shadow
        key.style.boxShadow = 'inset 0 -3px 6px rgba(255, 255, 255, 0.1), 0 3px 6px rgba(0, 0, 0, 0.3)';
        
        const label = document.createElement('div');
        label.className = 'key-label';
        label.textContent = note;
        
        key.appendChild(label);
        key.addEventListener('mousedown', () => handleNotePress(note));
        key.addEventListener('mouseup', () => handleNoteRelease(note));
        key.addEventListener('mouseleave', () => handleNoteRelease(note));
        key.addEventListener('touchstart', (e) => { e.preventDefault(); handleNotePress(note); });
        key.addEventListener('touchend', (e) => { e.preventDefault(); handleNoteRelease(note); });
        
        // Position black keys - these calculations ensure they sit properly between white keys
        const noteName = note.slice(0, -1); // e.g., "C#" from "C#4"
        const octave = note.slice(-1); // e.g., "4" from "C#4"
        
        // Base positions for each black key type relative to the start of a white key
        let offset;
        const whiteKeyWidth = 40; // Width of white keys in pixels
        
        switch(noteName) {
          case 'C#':
            // C# sits between C and D
            offset = whiteKeys.indexOf('C' + octave) * whiteKeyWidth + whiteKeyWidth * 0.7;
            break;
          case 'D#':
            // D# sits between D and E
            offset = whiteKeys.indexOf('D' + octave) * whiteKeyWidth + whiteKeyWidth * 0.7;
            break;
          case 'F#':
            // F# sits between F and G
            offset = whiteKeys.indexOf('F' + octave) * whiteKeyWidth + whiteKeyWidth * 0.7;
            break;
          case 'G#':
            // G# sits between G and A
            offset = whiteKeys.indexOf('G' + octave) * whiteKeyWidth + whiteKeyWidth * 0.7;
            break;
          case 'A#':
            // A# sits between A and B
            offset = whiteKeys.indexOf('A' + octave) * whiteKeyWidth + whiteKeyWidth * 0.7;
            break;
        }
        
        // Position the black key
        key.style.left = offset + 'px';
        
        // Smooth border edges
        key.style.borderRadius = '0 0 4px 4px';
        
        elements.piano.appendChild(key);
      });
    }

    // Handle note press
    function handleNotePress(note) {
      const key = document.querySelector(`.key[data-note="${note}"]`);
      if (key) {
        key.classList.add('active');
      }
      
      // Play the note
      playNote(note);
      
      // Check if the note is correct
      checkNote(note);
    }

    // Handle note release
    function handleNoteRelease(note) {
      const key = document.querySelector(`.key[data-note="${note}"]`);
      if (key) {
        key.classList.remove('active');
        key.classList.remove('incorrect');
      }
    }

    // Function to check if the played note is correct
    function checkNote(note) {
      if (!gameState.isPlaying) return;
      
      const currentNote = getCurrentNote();
      
      if (note === currentNote) {
        // Correct note
        const key = document.querySelector(`.key[data-note="${note}"]`);
        if (key) {
          key.classList.add('correct');
          setTimeout(() => {
            key.classList.remove('correct');
          }, 300);
        }
        
        // Play success sound
        playSuccessSound();
        
        // Create particle effect
        if (gameState.settings.particles) {
          createParticleEffect(note);
        }
        
        // Increment score
        gameState.score += 10 * (gameState.streak + 1);
        elements.scoreDisplay.textContent = gameState.score;
        
        // Increment streak
        gameState.streak++;
        if (gameState.streak > gameState.maxStreak) {
          gameState.maxStreak = gameState.streak;
        }
        
        // Update star rating
        updateStarRating();
        
        // Increment correct notes count
        gameState.correctNotes++;
        
        // If we've reached a multiple of 10 correct notes, show a quiz
        if (gameState.correctNotes % 10 === 0 && gameState.correctNotes > 0) {
          setTimeout(() => showQuiz(), 500);
        }
        
        // Move to next note
        gameState.currentNoteIndex++;
        
        // Check if song is complete
        if (gameState.currentNoteIndex >= songLibrary[gameState.currentSong].length) {
          // Song complete
          endSong();
        } else {
          // Update progress
          updateProgress();
          
          // Draw the next note
          drawStaffAndNote();
          
          // Show character reaction
          showCharacterReaction(true);
          
          // Create next falling note
          createFallingNote();
        }
      } else {
        // Incorrect note
        const key = document.querySelector(`.key[data-note="${note}"]`);
        if (key) {
          key.classList.add('incorrect');
          setTimeout(() => {
            key.classList.remove('incorrect');
          }, 300);
        }
        
        // Play error sound
        playErrorSound();
        
        // Reset streak
        gameState.streak = 0;
        
        // Show character reaction
        showCharacterReaction(false);
      }
    }

    // Function to get the current note
    function getCurrentNote() {
      return songLibrary[gameState.currentSong][gameState.currentNoteIndex][0];
    }

    // Function to get the current note's duration
    function getCurrentNoteDuration() {
      return songLibrary[gameState.currentSong][gameState.currentNoteIndex][1];
    }

    // Function to draw the musical staff and note
    function drawStaffAndNote() {
      const canvas = elements.staff;
      const ctx = elements.staffCtx;
      const width = canvas.width = canvas.parentElement.clientWidth;
      const height = canvas.height = canvas.parentElement.clientHeight;
      
      // Clear the canvas
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);
      
      // Draw the five staff lines
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      
      for (let i = 0; i < 5; i++) {
        const y = i * height / 8 + height / 4;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // Draw treble clef
      ctx.font = '80px serif';
      ctx.fillStyle = 'black';
      ctx.fillText('𝄞', 20, 75);
      
      // Draw the current note
      const currentNote = getCurrentNote();
      const currentDuration = getCurrentNoteDuration();
      
      // Note positions mapped to staff lines and spaces
      const notePositions = {
        'C4': 150, 'D4': 142, 'E4': 134, 'F4': 126, 'G4': 118, 'A4': 110, 'B4': 102,
        'C5': 94, 'D5': 86, 'E5': 78, 'F5': 70, 'G5': 62
      };
      
      // Check if the note exists in our position mapping
      if (notePositions[currentNote] !== undefined) {
        const xPos = width / 2;
        const yPos = notePositions[currentNote];
        
        // Draw ledger lines if needed
        if (currentNote === 'C4') {
          ctx.beginPath();
          ctx.moveTo(xPos - 15, yPos);
          ctx.lineTo(xPos + 15, yPos);
          ctx.stroke();
        }
        
        // Draw the note based on duration
        ctx.fillStyle = 'black';
        
        // Draw note head
        ctx.beginPath();
        ctx.ellipse(xPos, yPos, 10, 6, 0, 0, Math.PI * 2);
        
        if (currentDuration === 4) {
          // Whole note - unfilled
          ctx.stroke();
        } else {
          // All other notes - filled
          ctx.fill();
          
          // Draw stem for notes shorter than whole notes
          if (currentDuration <= 2) {
            ctx.beginPath();
            ctx.moveTo(xPos + 8, yPos);
            ctx.lineTo(xPos + 8, yPos - 40);
            ctx.stroke();
            
            // Add flags for eighth notes and shorter
            if (currentDuration <= 0.5) {
              ctx.beginPath();
              ctx.moveTo(xPos + 8, yPos - 40);
              ctx.lineTo(xPos + 18, yPos - 30);
              ctx.stroke();
              
              // Add a second flag for sixteenth notes
              if (currentDuration <= 0.25) {
                ctx.beginPath();
                ctx.moveTo(xPos + 8, yPos - 30);
                ctx.lineTo(xPos + 18, yPos - 20);
                ctx.stroke();
              }
            }
          }
        }
        
        // Draw note name if "Show Hints" is enabled
        if (gameState.highlightEnabled) {
          ctx.font = '14px Arial';
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillText(currentNote, xPos - 15, yPos - 15);
        }
      }
    }

    // Function to create a falling note
    function createFallingNote() {
      const currentNote = getCurrentNote();
      const currentDuration = getCurrentNoteDuration();
      
      // Only create falling notes for visible keys
      if (!document.querySelector(`.key[data-note="${currentNote}"]`)) {
        return;
      }
      
      // Find the key's position
      const key = document.querySelector(`.key[data-note="${currentNote}"]`);
      const keyRect = key.getBoundingClientRect();
      const waterfallRect = elements.waterfall.getBoundingClientRect();
      
      // Get key type (white or black)
      const isBlackKey = currentNote.includes('#');
      
      // Calculate the x position (centered on the key)
      // Need to adjust for black keys to ensure proper alignment
      let xPos;
      if (isBlackKey) {
        // Center on the black key
        xPos = keyRect.left - waterfallRect.left + (keyRect.width / 2) - 18;
      } else {
        // Center on the white key
        xPos = keyRect.left - waterfallRect.left + (keyRect.width / 2) - 18;
      }
      
      // Create the falling note element
      const fallingNote = document.createElement('div');
      fallingNote.className = 'falling-note';
      fallingNote.style.left = xPos + 'px';
      fallingNote.style.top = '-50px';
      fallingNote.style.animationName = 'fall';
      fallingNote.style.animationDuration = gameState.settings.noteSpeed + 's';
      
      // Set width based on key type
      fallingNote.style.width = isBlackKey ? '24px' : '36px';
      
      // Set the note color based on its name (C, D, E, etc.)
      const noteName = currentNote.charAt(0);
      fallingNote.classList.add('note-' + noteName);
      
      // Add glow effect for better visibility
      fallingNote.style.boxShadow = `0 0 10px ${getComputedStyle(fallingNote).backgroundColor}`;
      
      // Add the note name with stylish text
      fallingNote.innerHTML = `<span>${currentNote}</span>`;
      
      // Add to the waterfall
      elements.waterfall.appendChild(fallingNote);
      
      // Add to the falling notes array
      gameState.fallingNotes.push(fallingNote);
      
      // Remove the note after animation
      const animationTimeout = setTimeout(() => {
        if (fallingNote.parentNode) {
          // Add fade-out effect
          fallingNote.style.opacity = '0';
          fallingNote.style.transform = 'scale(0.8)';
          
          // Remove after fade transition
          setTimeout(() => {
            if (fallingNote.parentNode) {
              fallingNote.parentNode.removeChild(fallingNote);
            }
            
            // Remove from array
            const index = gameState.fallingNotes.indexOf(fallingNote);
            if (index !== -1) {
              gameState.fallingNotes.splice(index, 1);
            }
          }, 300);
        }
      }, gameState.settings.noteSpeed * 1000);
      
      gameState.timers.push(animationTimeout);
    }

    // Function to show a character reaction
    function showCharacterReaction(correct) {
      const character = Math.random() > 0.5 ? elements.maestro : elements.melody;
      const bubble = character === elements.maestro ? elements.maestroBubble : elements.melodyBubble;
      
      // Set the message
      if (correct) {
        const messages = [
          "Great job!",
          "Perfect!",
          "You're a natural!",
          "Excellent!",
          "Keep it up!",
          "Wonderful playing!",
          "Music to my ears!"
        ];
        bubble.textContent = messages[Math.floor(Math.random() * messages.length)];
      } else {
        const messages = [
          "Try again!",
          "Almost there!",
          "Not quite!",
          "You can do it!",
          "Focus on the highlighted key!",
          "Listen carefully!"
        ];
        bubble.textContent = messages[Math.floor(Math.random() * messages.length)];
      }
      
      // Show the bubble
      bubble.style.opacity = '1';
      
      // Add a little bounce animation to the character
      character.style.transform = 'translateY(-10px)';
      setTimeout(() => {
        character.style.transform = 'translateY(0)';
      }, 300);
      
      // Hide the bubble after a delay
      setTimeout(() => {
        bubble.style.opacity = '0';
      }, 2000);
    }

    // Function to create particle effect
    function createParticleEffect(note) {
      if (!gameState.settings.particles) return;
      
      const key = document.querySelector(`.key[data-note="${note}"]`);
      if (!key) return;
      
      const keyRect = key.getBoundingClientRect();
      
      // Create multiple particles
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Random position within the key
        const xPos = keyRect.left + Math.random() * keyRect.width;
        const yPos = keyRect.top + Math.random() * (keyRect.height / 2);
        
        // Random color based on note
        const noteName = note.charAt(0);
        const baseColor = noteColors[noteName] || '#FFD700';
        
        // Create a gradient with slight variations
        const hue = parseInt(baseColor.slice(1), 16);
        const hueVariation = Math.floor(Math.random() * 40) - 20;
        const adjustedColor = `hsl(${hue + hueVariation}, 100%, 70%)`;
        
        // Size and shape variation
        const size = Math.random() * 15 + 8;
        const isRound = Math.random() > 0.3;
        
        particle.style.left = xPos + 'px';
        particle.style.top = yPos + 'px';
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.backgroundColor = adjustedColor;
        particle.style.boxShadow = `0 0 ${size/2}px ${baseColor}`;
        
        if (!isRound) {
          const sides = Math.floor(Math.random() * 3) + 3; // 3 to 5 sides
          const rotation = Math.random() * 360;
          particle.style.borderRadius = sides === 3 ? '50% 50% 0 50%' : 
                                         sides === 4 ? '50% 0 50% 50%' : '50%';
          particle.style.transform = `rotate(${rotation}deg)`;
        }
        
        // Add to the document
        document.body.appendChild(particle);
        
        // Modern animation approach for smoother motion
        const keyframes = [
          { 
            opacity: 1, 
            transform: `translate(0, 0) scale(1) rotate(0deg)`,
            filter: 'blur(0px)'
          },
          { 
            opacity: 0.8, 
            transform: `translate(${(Math.random() - 0.5) * 100}px, ${-30 - Math.random() * 50}px) scale(0.7) rotate(${Math.random() * 180}deg)`,
            filter: 'blur(2px)'
          },
          { 
            opacity: 0, 
            transform: `translate(${(Math.random() - 0.5) * 150}px, ${-60 - Math.random() * 80}px) scale(0.2) rotate(${Math.random() * 360}deg)`,
            filter: 'blur(4px)'
          },
        ];
        
        const timing = {
          duration: 600 + Math.random() * 600,
          easing: 'cubic-bezier(0.2, 0.9, 0.3, 1)',
          fill: 'forwards'
        };
        
        const animation = particle.animate(keyframes, timing);
        
        animation.onfinish = () => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        };
        
        // Add to animations
        gameState.animations.particles.push(particle);
      }
    }

    // Function to update the progress bar
    function updateProgress() {
      const progress = (gameState.currentNoteIndex / songLibrary[gameState.currentSong].length) * 100;
      elements.progressBar.style.width = progress + '%';
      updateLearningPath();
    }

    // Function to update the learning path
    function updateLearningPath() {
      // Clear existing segments
      elements.learningPath.innerHTML = '';
      
      // Get total segments (max 20 for visual clarity)
      const totalSegments = Math.min(20, songLibrary[gameState.currentSong].length);
      
      // Calculate how many notes each segment represents
      const notesPerSegment = Math.ceil(songLibrary[gameState.currentSong].length / totalSegments);
      
      // Create segments
      for (let i = 0; i < totalSegments; i++) {
        const segment = document.createElement('div');
        segment.className = 'path-segment';
        
        // Determine if segment is completed or current
        const segmentStartNote = i * notesPerSegment;
        const segmentEndNote = Math.min((i + 1) * notesPerSegment - 1, songLibrary[gameState.currentSong].length - 1);
        
        if (gameState.currentNoteIndex > segmentEndNote) {
          segment.classList.add('completed');
        } else if (gameState.currentNoteIndex >= segmentStartNote && gameState.currentNoteIndex <= segmentEndNote) {
          segment.classList.add('current');
        }
        
        elements.learningPath.appendChild(segment);
      }
    }

    // Function to update star rating
    function updateStarRating() {
      // Calculate star rating based on score and song length
      const totalPossibleScore = songLibrary[gameState.currentSong].length * 10;
      const percentage = Math.min(gameState.score / totalPossibleScore, 1);
      
      // Reset all stars
      elements.stars.forEach(star => {
        star.classList.remove('filled');
      });
      
      // Fill stars based on percentage
      if (percentage >= 0.33) {
        elements.stars[0].classList.add('filled');
      }
      
      if (percentage >= 0.66) {
        elements.stars[1].classList.add('filled');
      }
      
      if (percentage >= 0.9) {
        elements.stars[2].classList.add('filled');
      }
    }

    // Function to show a quiz
    function showQuiz() {
      if (!gameState.isPlaying) return;
      
      // Pause the game
      gameState.isPlaying = false;
      
      // Get a random quiz question
      const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
      
      // Set up the quiz modal
      elements.quizQuestion.textContent = quiz.question;
      elements.quizOptions.innerHTML = '';
      
      // Add options
      quiz.options.forEach(option => {
        const optionElement = document.createElement('div');
        optionElement.className = 'quiz-option';
        optionElement.textContent = option;
        optionElement.addEventListener('click', () => {
          // Clear previous selections
          document.querySelectorAll('.quiz-option').forEach(opt => {
            opt.classList.remove('selected');
          });
          
          // Select this option
          optionElement.classList.add('selected');
          
          // Store the answer
          gameState.userAnswer = option;
        });
        
        elements.quizOptions.appendChild(optionElement);
      });
      
      // Show the modal
      elements.quizModal.classList.add('active');
      
      // Set up the check answer button
      elements.checkAnswerBtn.onclick = () => {
        if (!gameState.userAnswer) {
          return; // No answer selected
        }
        
        // Check the answer
        if (gameState.userAnswer === quiz.correctAnswer) {
          // Correct answer
          document.querySelectorAll('.quiz-option').forEach(opt => {
            if (opt.textContent === quiz.correctAnswer) {
              opt.classList.add('correct');
            }
          });
          
          // Add bonus points
          gameState.score += 50;
          elements.scoreDisplay.textContent = gameState.score;
          
          // Play success sound
          playSuccessSound();
          
          // Close modal after delay
          setTimeout(() => {
            elements.quizModal.classList.remove('active');
            gameState.userAnswer = null;
            
            // Resume the game
            gameState.isPlaying = true;
          }, 1500);
        } else {
          // Incorrect answer
          document.querySelectorAll('.quiz-option').forEach(opt => {
            if (opt.textContent === gameState.userAnswer) {
              opt.classList.add('incorrect');
            }
            if (opt.textContent === quiz.correctAnswer) {
              opt.classList.add('correct');
            }
          });
          
          // Play error sound
          playErrorSound();
          
          // Close modal after delay
          setTimeout(() => {
            elements.quizModal.classList.remove('active');
            gameState.userAnswer = null;
            
            // Resume the game
            gameState.isPlaying = true;
          }, 2000);
        }
      };
    }

    // Function to end the song and show rewards
    function endSong() {
      // Stop the game
      gameState.isPlaying = false;
      
      // Clear all falling notes
      gameState.fallingNotes.forEach(note => {
        if (note.parentNode) {
          note.parentNode.removeChild(note);
        }
      });
      gameState.fallingNotes = [];
      
      // Clear all timers
      gameState.timers.forEach(timer => {
        clearTimeout(timer);
      });
      gameState.timers = [];
      
      // Calculate final score and rating
      const totalNotes = songLibrary[gameState.currentSong].length;
      const percentage = gameState.correctNotes / totalNotes;
      
      // Set reward text based on performance
      if (percentage >= 0.9) {
        elements.rewardText.textContent = "Amazing! You're a Musical Maestro!";
      } else if (percentage >= 0.7) {
        elements.rewardText.textContent = "Great job! You're getting really good with music!";
      } else {
        elements.rewardText.textContent = "Good effort! Keep practicing to master the piano!";
      }
      
      // Show the reward modal
      elements.rewardModal.classList.add('active');
      
      // Add animation to the trophy
      elements.trophy.classList.add('float-animation');
      
      // Create celebration effects
      if (gameState.settings.particles) {
        createRewardAnimation();
      }
      
      // Play celebration sound
      playCelebrationSound();
      
      // Set up continue button
      elements.continueBtn.onclick = () => {
        elements.rewardModal.classList.remove('active');
        elements.trophy.classList.remove('float-animation');
        resetGame();
      };
    }

    // Function to create reward animation
    function createRewardAnimation() {
      // Clear any existing animations
      elements.rewardAnimation.innerHTML = '';
      
      // Create animated effects
      createConfetti();
      createGlowingStars();
      createMusicNotes();
      
      // Make the trophy pulse and rotate
      elements.trophy.classList.add('float-animation');
      elements.trophy.style.animation = 'float 3s ease-in-out infinite, glow 2s ease-in-out infinite alternate';
    }
    
    // Create confetti for celebration
    function createConfetti() {
      const colors = ['#FF6347', '#FFA500', '#FFFF00', '#32CD32', '#1E90FF', '#9370DB', '#FF69B4'];
      
      for (let i = 0; i < 100; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.style.position = 'absolute';
          confetti.style.width = (Math.random() * 10 + 5) + 'px';
          confetti.style.height = (Math.random() * 10 + 5) + 'px';
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.opacity = '0.8';
          confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : (Math.random() > 0.5 ? '0' : '5px');
          confetti.style.zIndex = '10';
          
          // Random starting position (top of container)
          const x = Math.random() * elements.rewardAnimation.clientWidth;
          confetti.style.left = x + 'px';
          confetti.style.top = '-10px';
          
          elements.rewardAnimation.appendChild(confetti);
          
          // Animation
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 2 + 1;
          const rotationSpeed = Math.random() * 10 - 5;
          const duration = Math.random() * 3000 + 2000;
          
          const keyframes = [
            {
              top: '-10px',
              transform: 'rotate(0deg)',
              opacity: 0.8
            },
            {
              top: (elements.rewardAnimation.clientHeight * 0.3) + 'px',
              transform: `rotate(${rotationSpeed * duration/1000 * 0.3}deg)`,
              opacity: 1
            },
            {
              top: (elements.rewardAnimation.clientHeight * 0.7) + 'px',
              left: (x + Math.cos(angle) * 100) + 'px',
              transform: `rotate(${rotationSpeed * duration/1000 * 0.7}deg)`,
              opacity: 0.7
            },
            {
              top: elements.rewardAnimation.clientHeight + 'px',
              left: (x + Math.cos(angle) * 200) + 'px',
              transform: `rotate(${rotationSpeed * duration/1000}deg)`,
              opacity: 0
            }
          ];
          
          const timing = {
            duration: duration,
            easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
            fill: 'forwards'
          };
          
          const animation = confetti.animate(keyframes, timing);
          
          animation.onfinish = () => {
            if (confetti.parentNode) {
              confetti.parentNode.removeChild(confetti);
            }
          };
        }, i * 20); // Stagger the confetti
      }
    }
    
    // Create glowing stars
    function createGlowingStars() {
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          const star = document.createElement('div');
          star.className = 'sparkle';
          
          // Random position
          const x = Math.random() * elements.rewardAnimation.clientWidth;
          const y = Math.random() * elements.rewardAnimation.clientHeight * 0.8;
          
          star.style.left = x + 'px';
          star.style.top = y + 'px';
          star.style.width = (Math.random() * 30 + 20) + 'px';
          star.style.height = (Math.random() * 30 + 20) + 'px';
          star.style.filter = `hue-rotate(${Math.random() * 360}deg)`;
          
          elements.rewardAnimation.appendChild(star);
          
          // Pulsing animation
          const keyframes = [
            { transform: 'scale(0) rotate(0deg)', opacity: 0 },
            { transform: 'scale(1.2) rotate(180deg)', opacity: 1 },
            { transform: 'scale(1) rotate(360deg)', opacity: 0.8 },
            { transform: 'scale(0) rotate(720deg)', opacity: 0 }
          ];
          
          const timing = {
            duration: 1500,
            easing: 'ease-in-out',
            fill: 'forwards'
          };
          
          const animation = star.animate(keyframes, timing);
          
          animation.onfinish = () => {
            if (star.parentNode) {
              star.parentNode.removeChild(star);
            }
          };
        }, i * 150);
      }
    }
    
    // Create floating music notes
    function createMusicNotes() {
      const musicNotes = ['♪', '♫', '♬', '♩', '♭', '♮', '♯'];
      
      for (let i = 0; i < 15; i++) {
        setTimeout(() => {
          const note = document.createElement('div');
          note.style.position = 'absolute';
          note.style.fontSize = (Math.random() * 30 + 20) + 'px';
          note.style.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
          note.style.textShadow = '0 0 10px rgba(255, 255, 255, 0.8)';
          note.style.zIndex = '15';
          note.style.fontWeight = 'bold';
          note.textContent = musicNotes[Math.floor(Math.random() * musicNotes.length)];
          
          // Random position around trophy
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 150 + 50;
          const x = elements.rewardAnimation.clientWidth / 2 + Math.cos(angle) * distance;
          const y = elements.rewardAnimation.clientHeight / 2 + Math.sin(angle) * distance;
          
          note.style.left = x + 'px';
          note.style.top = y + 'px';
          
          elements.rewardAnimation.appendChild(note);
          
          // Floating animation
          const keyframes = [
            { 
              transform: 'translateY(0) rotate(0deg) scale(1)', 
              opacity: 0
            },
            { 
              transform: 'translateY(-20px) rotate(20deg) scale(1.2)', 
              opacity: 1
            },
            { 
              transform: `translateY(-${50 + Math.random() * 50}px) rotate(${Math.random() * 40 - 20}deg) scale(0.8)`, 
              opacity: 0.7
            },
            { 
              transform: `translateY(-${100 + Math.random() * 100}px) rotate(${Math.random() * 60 - 30}deg) scale(0.5)`, 
              opacity: 0
            }
          ];
          
          const timing = {
            duration: 2000 + Math.random() * 2000,
            easing: 'ease-out',
            fill: 'forwards'
          };
          
          const animation = note.animate(keyframes, timing);
          
          animation.onfinish = () => {
            if (note.parentNode) {
              note.parentNode.removeChild(note);
            }
          };
        }, i * 200);
      }
    }

    // Function to toggle highlighting
    function toggleHighlight() {
      gameState.highlightEnabled = !gameState.highlightEnabled;
      elements.toggleHighlightBtn.textContent = gameState.highlightEnabled ? "Hide Hints" : "Show Hints";
      
      // Update the staff display
      drawStaffAndNote();
      
      // Update key highlighting
      updateKeyHighlighting();
    }

    // Function to update key highlighting
    function updateKeyHighlighting() {
      // Clear all highlights
      document.querySelectorAll('.key').forEach(key => {
        key.classList.remove('highlighted');
      });
      
      // If highlighting is enabled and the game is playing, highlight the current note
      if (gameState.highlightEnabled && gameState.isPlaying) {
        const currentNote = getCurrentNote();
        const key = document.querySelector(`.key[data-note="${currentNote}"]`);
        
        if (key) {
          key.classList.add('highlighted');
        }
      }
    }

    // Function to start the game
    function startGame() {
      if (gameState.isPlaying) return;
      
      // Reset the game state
      gameState.currentNoteIndex = 0;
      gameState.score = 0;
      gameState.streak = 0;
      gameState.correctNotes = 0;
      gameState.isPlaying = true;
      
      // Update the score display
      elements.scoreDisplay.textContent = gameState.score;
      
      // Reset star rating
      elements.stars.forEach(star => {
        star.classList.remove('filled');
      });
      
      // Draw the initial note
      drawStaffAndNote();
      
      // Update progress
      updateProgress();
      
      // Update key highlighting
      updateKeyHighlighting();
      
      // Create the first falling note
      createFallingNote();
      
      // Show welcome message
      elements.maestroBubble.textContent = "Let's make some music!";
      elements.maestroBubble.style.opacity = '1';
      
      elements.melodyBubble.textContent = "Follow the highlighted keys!";
      elements.melodyBubble.style.opacity = '1';
      
      // Hide welcome messages after delay
      setTimeout(() => {
        elements.maestroBubble.style.opacity = '0';
        elements.melodyBubble.style.opacity = '0';
      }, 3000);
      
      // Update button text
      elements.startBtn.textContent = 'Pause';
    }

    // Function to pause the game
    function pauseGame() {
      if (!gameState.isPlaying) return;
      
      gameState.isPlaying = false;
      elements.startBtn.textContent = 'Resume';
      
      // Pause all falling notes
      gameState.fallingNotes.forEach(note => {
        note.style.animationPlayState = 'paused';
      });
    }

    // Function to resume the game
    function resumeGame() {
      if (gameState.isPlaying) return;
      
      gameState.isPlaying = true;
      elements.startBtn.textContent = 'Pause';
      
      // Resume all falling notes
      gameState.fallingNotes.forEach(note => {
        note.style.animationPlayState = 'running';
      });
    }

    // Function to reset the game
    function resetGame() {
      // Stop the game
      gameState.isPlaying = false;
      
      // Clear all falling notes
      gameState.fallingNotes.forEach(note => {
        if (note.parentNode) {
          note.parentNode.removeChild(note);
        }
      });
      gameState.fallingNotes = [];
      
      // Clear all timers
      gameState.timers.forEach(timer => {
        clearTimeout(timer);
      });
      gameState.timers = [];
      
      // Reset the game state
      gameState.currentNoteIndex = 0;
      gameState.score = 0;
      gameState.streak = 0;
      gameState.correctNotes = 0;
      
      // Update the score display
      elements.scoreDisplay.textContent = gameState.score;
      
      // Reset star rating
      elements.stars.forEach(star => {
        star.classList.remove('filled');
      });
      
      // Draw the initial note
      drawStaffAndNote();
      
      // Update progress
      updateProgress();
      
      // Clear key highlighting
      document.querySelectorAll('.key').forEach(key => {
        key.classList.remove('highlighted');
        key.classList.remove('active');
        key.classList.remove('correct');
        key.classList.remove('incorrect');
      });
      
      // Update button text
      elements.startBtn.textContent = 'Start';
    }

    // Function to load a song
    function loadSong(songId) {
      // Stop the current song if playing
      if (gameState.isPlaying) {
        pauseGame();
      }
      
      // Reset the game
      resetGame();
      
      // Change the current song
      gameState.currentSong = songId;
      
      // Draw the initial note
      drawStaffAndNote();
      
      // Update progress
      updateProgress();
    }

    // Function to save settings
    function saveSettings() {
      // Update settings
      gameState.settings.noteSpeed = parseFloat(elements.noteSpeedSlider.value);
      gameState.settings.volume = parseFloat(elements.volumeSlider.value);
      gameState.settings.particles = elements.particlesToggle.checked;
      gameState.settings.animations = elements.animationsToggle.checked;
      gameState.settings.difficulty = elements.difficultySelect.value;
      
      // Update CSS variable for falling note speed
      document.documentElement.style.setProperty('--falling-note-speed', gameState.settings.noteSpeed + 's');
      
      // Update audio volume if context exists
      if (masterGainNode) {
        masterGainNode.gain.value = gameState.settings.volume;
      }
      
      // Close settings panel
      elements.settingsPanel.style.display = 'none';
      
      // Play button sound for feedback
      playButtonSound();
    }

    // Event listeners
    function setupEventListeners() {
      // Start/Pause button
      elements.startBtn.addEventListener('click', () => {
        playButtonSound();
        if (gameState.isPlaying) {
          pauseGame();
        } else {
          if (elements.startBtn.textContent === 'Start') {
            startGame();
          } else {
            resumeGame();
          }
        }
      });
      
      // Reset button
      elements.resetBtn.addEventListener('click', () => {
        playButtonSound();
        resetGame();
      });
      
      // Song selection
      elements.songSelect.addEventListener('change', () => {
        playButtonSound();
        loadSong(elements.songSelect.value);
      });
      
      // Toggle highlight button
      elements.toggleHighlightBtn.addEventListener('click', () => {
        playButtonSound();
        toggleHighlight();
      });
      
      // Settings button
      elements.settingsBtn.addEventListener('click', () => {
        playButtonSound();
        
        // Update settings UI to match current settings
        elements.noteSpeedSlider.value = gameState.settings.noteSpeed;
        elements.volumeSlider.value = gameState.settings.volume;
        elements.particlesToggle.checked = gameState.settings.particles;
        elements.animationsToggle.checked = gameState.settings.animations;
        elements.difficultySelect.value = gameState.settings.difficulty;
        
        // Show settings panel
        elements.settingsPanel.style.display = 'block';
      });
      
      // Close settings button
      elements.closeSettingsBtn.addEventListener('click', () => {
        playButtonSound();
        elements.settingsPanel.style.display = 'none';
      });
      
      // Save settings button
      elements.saveSettingsBtn.addEventListener('click', saveSettings);
      
      // Keyboard events
      document.addEventListener('keydown', (event) => {
        // Check if a key is mapped to a note
        const note = keyboardMapping[event.key.toLowerCase()];
        if (note) {
          handleNotePress(note);
        }
      });
      
      document.addEventListener('keyup', (event) => {
        // Check if a key is mapped to a note
        const note = keyboardMapping[event.key.toLowerCase()];
        if (note) {
          handleNoteRelease(note);
        }
      });
      
      // Window resize event
      window.addEventListener('resize', () => {
        drawStaffAndNote();
        
        // Restart the game if it was playing
        if (gameState.isPlaying) {
          pauseGame();
          setTimeout(resumeGame, 100);
        }
      });
    }

    // Initialize the game
    function initGame() {
      // Initialize the piano
      initializePiano();
      
      // Setup event listeners
      setupEventListeners();
      
      // Draw the initial musical staff and note
      drawStaffAndNote();
      
      // Create learning path
      updateLearningPath();
      
      // Welcome message from characters
      setTimeout(() => {
        elements.maestroBubble.textContent = "Welcome to Musical Waterfall!";
        elements.maestroBubble.style.opacity = '1';
        
        setTimeout(() => {
          elements.melodyBubble.textContent = "Press Start to begin playing!";
          elements.melodyBubble.style.opacity = '1';
          
          setTimeout(() => {
            elements.maestroBubble.style.opacity = '0';
            elements.melodyBubble.style.opacity = '0';
          }, 3000);
        }, 1500);
      }, 500);
    }

    // Start the game when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initGame);
  </script>
</body>
</html>
