<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Similar Triangles Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            background-color: #f0f8ff;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #game-canvas {
            display: block;
        }
        #control-panel {
            background-color: #e6f7ff;
            padding: 10px;
            border-top: 3px solid #7ac5ff;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            gap: 10px;
            max-height: 30vh;
            overflow-y: auto;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            margin: 5px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #92c9ff;
        }
        .control-group h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #0066cc;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .slider-container label {
            font-size: 14px;
            margin-right: 10px;
            color: #333;
            width: 120px;
        }
        .slider-container input[type="range"] {
            width: 120px;
        }
        .slider-container .value {
            width: 30px;
            text-align: center;
            margin-left: 5px;
            font-size: 14px;
            color: #0066cc;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 0 #388E3C;
        }
        button:hover {
            background-color: #45a049;
        }
        button:active {
            box-shadow: 0 2px 0 #388E3C;
            transform: translateY(2px);
        }
        #toggle-panel-btn {
            position: absolute;
            right: 10px;
            top: 10px;
            z-index: 100;
            background-color: #ff9800;
            box-shadow: 0 4px 0 #e68a00;
        }
        #reset-btn {
            background-color: #f44336;
            box-shadow: 0 4px 0 #d32f2f;
        }
        #next-question-btn {
            background-color: #2196F3;
            box-shadow: 0 4px 0 #0b7dda;
        }
        .help-btn {
            background-color: #9c27b0;
            box-shadow: 0 4px 0 #7B1FA2;
        }
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        #close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
            color: #777;
        }
        #close-modal:hover {
            color: #333;
        }
        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            border: 2px solid #7ac5ff;
            font-size: 18px;
            color: #0066cc;
        }
        .hidden {
            display: none;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0); }
        }
        @keyframes celebrate {
            0% { background-color: #f0f8ff; }
            25% { background-color: #ffe6e6; }
            50% { background-color: #e6ffe6; }
            75% { background-color: #e6e6ff; }
            100% { background-color: #f0f8ff; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
            <div id="score-display">Score: 0</div>
            <button id="toggle-panel-btn">Settings</button>
        </div>
        <div id="control-panel">
            <div class="control-group">
                <h3>Difficulty</h3>
                <div class="slider-container">
                    <label for="difficulty-slider">Difficulty Level:</label>
                    <input type="range" id="difficulty-slider" min="1" max="5" value="1" step="1">
                    <span class="value" id="difficulty-value">1</span>
                </div>
            </div>
            <div class="control-group">
                <h3>Triangle Settings</h3>
                <div class="slider-container">
                    <label for="triangles-slider">Number of Triangles:</label>
                    <input type="range" id="triangles-slider" min="2" max="6" value="3" step="1">
                    <span class="value" id="triangles-value">3</span>
                </div>
                <div class="slider-container">
                    <label for="size-multiplier-slider">Size Range:</label>
                    <input type="range" id="size-multiplier-slider" min="1" max="5" value="2" step="0.1">
                    <span class="value" id="size-multiplier-value">2</span>
                </div>
            </div>
            <div class="control-group">
                <h3>Visual Settings</h3>
                <div class="slider-container">
                    <label for="animation-speed-slider">Animation Speed:</label>
                    <input type="range" id="animation-speed-slider" min="0.5" max="2" value="1" step="0.1">
                    <span class="value" id="animation-speed-value">1</span>
                </div>
                <div class="slider-container">
                    <label for="show-ratios-slider">Show Ratios:</label>
                    <input type="range" id="show-ratios-slider" min="0" max="1" value="1" step="1">
                    <span class="value" id="show-ratios-value">Yes</span>
                </div>
            </div>
            <div class="control-group">
                <h3>Game Controls</h3>
                <button id="next-question-btn">Next Question</button>
                <button id="reset-btn">Reset Game</button>
                <button id="help-btn" class="help-btn">Help</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <span id="close-modal">&times;</span>
            <div id="modal-text"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Game state
        let gameState = {
            score: 0,
            level: 1,
            triangles: [],
            baseTriangle: null,
            selectedTriangle: null,
            targetTriangle: null,
            correctTriangles: [],
            incorrectGuesses: [],
            animationSpeed: 1,
            showRatios: true,
            numTriangles: 3,
            sizeMultiplierRange: 2,
            difficulty: 1,
            gamePhase: 'question', // question, celebration, explanation
            characters: [],
            particles: [],
            soundsEnabled: true,
            lastUpdateTime: 0,
            deltaTime: 0
        };

        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const controlPanel = document.getElementById('control-panel');
        const togglePanelBtn = document.getElementById('toggle-panel-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const resetBtn = document.getElementById('reset-btn');
        const helpBtn = document.getElementById('help-btn');
        const scoreDisplay = document.getElementById('score-display');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modalText = document.getElementById('modal-text');
        const closeModal = document.getElementById('close-modal');
        const tooltip = document.getElementById('tooltip');
        
        // Sliders
        const difficultySlider = document.getElementById('difficulty-slider');
        const difficultyValue = document.getElementById('difficulty-value');
        const trianglesSlider = document.getElementById('triangles-slider');
        const trianglesValue = document.getElementById('triangles-value');
        const sizeMultiplierSlider = document.getElementById('size-multiplier-slider');
        const sizeMultiplierValue = document.getElementById('size-multiplier-value');
        const animationSpeedSlider = document.getElementById('animation-speed-slider');
        const animationSpeedValue = document.getElementById('animation-speed-value');
        const showRatiosSlider = document.getElementById('show-ratios-slider');
        const showRatiosValue = document.getElementById('show-ratios-value');

        // Audio Context
        let audioContext;
        
        // Character definitions
        const CHARACTER_TYPES = {
            PROFESSOR: {
                name: 'Professor Triangle',
                color: '#4a6fa5',
                size: 60,
                eyeColor: '#ffffff',
                glasses: true,
                messages: [
                    "Similar triangles have the same shape but different sizes!",
                    "When triangles are similar, their angles are equal!",
                    "The ratio of corresponding sides is the same in similar triangles!",
                    "Let's learn about scale factors in similar triangles!",
                    "Can you find the similar triangles? Look at their angles and proportions!"
                ]
            },
            ASSISTANT: {
                name: 'Tiny',
                color: '#66bb6a',
                size: 40,
                eyeColor: '#ffffff',
                glasses: false,
                messages: [
                    "You're doing great! Keep going!",
                    "Remember to check the side ratios!",
                    "Need a hint? Compare the angles!",
                    "You're so smart! Try another one!",
                    "Good job finding similar triangles!"
                ]
            }
        };

        // Initialize the game
        function init() {
            // Set up canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize audio context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Web Audio API not supported');
                gameState.soundsEnabled = false;
            }
            
            // Set up event listeners
            canvas.addEventListener('mousedown', handleCanvasClick);
            canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            togglePanelBtn.addEventListener('click', toggleControlPanel);
            nextQuestionBtn.addEventListener('click', generateNewQuestion);
            resetBtn.addEventListener('click', resetGame);
            helpBtn.addEventListener('click', showHelp);
            closeModal.addEventListener('click', () => {
                modalOverlay.style.display = 'none';
            });
            
            // Slider event listeners
            difficultySlider.addEventListener('input', () => {
                gameState.difficulty = parseInt(difficultySlider.value);
                difficultyValue.textContent = difficultySlider.value;
            });
            
            trianglesSlider.addEventListener('input', () => {
                gameState.numTriangles = parseInt(trianglesSlider.value);
                trianglesValue.textContent = trianglesSlider.value;
            });
            
            sizeMultiplierSlider.addEventListener('input', () => {
                gameState.sizeMultiplierRange = parseFloat(sizeMultiplierSlider.value);
                sizeMultiplierValue.textContent = sizeMultiplierSlider.value;
            });
            
            animationSpeedSlider.addEventListener('input', () => {
                gameState.animationSpeed = parseFloat(animationSpeedSlider.value);
                animationSpeedValue.textContent = animationSpeedSlider.value;
            });
            
            showRatiosSlider.addEventListener('input', () => {
                gameState.showRatios = parseInt(showRatiosSlider.value) === 1;
                showRatiosValue.textContent = gameState.showRatios ? 'Yes' : 'No';
            });
            
            // Create characters
            createCharacters();
            
            // Start the game
            resetGame();
            
            // Start animation loop
            gameState.lastUpdateTime = performance.now();
            requestAnimationFrame(gameLoop);
            
            // Show welcome modal
            showWelcomeMessage();
        }
        
        // Welcome message
        function showWelcomeMessage() {
            modalText.innerHTML = `
                <h2>Welcome to Similar Triangles Adventure!</h2>
                <p>Hi there, young mathematician! I'm Professor Triangle, and I'm going to help you learn about similar triangles!</p>
                <p>Similar triangles have the same <strong>shape</strong> but can be different <strong>sizes</strong>. 
                   That means their angles are the same, and their sides are in proportion.</p>
                <div style="text-align: center; margin: 20px 0;">
                    <svg width="300" height="150" style="display: inline-block;">
                        <polygon points="50,120 100,20 150,120" fill="#a6d8ff" stroke="#0066cc" stroke-width="2"/>
                        <polygon points="180,120 210,60 240,120" fill="#ffcccc" stroke="#cc0000" stroke-width="2"/>
                        <text x="100" y="140" fill="#0066cc" style="font-size: 16px;">Big Triangle</text>
                        <text x="210" y="140" fill="#cc0000" style="font-size: 16px;">Small Triangle</text>
                    </svg>
                </div>
                <p>In this game, your job is to find the triangles that are similar to the target triangle.</p>
                <p><strong>How to play:</strong></p>
                <ul>
                    <li>Look at the purple target triangle</li>
                    <li>Click on the triangles that you think are similar to it</li>
                    <li>Remember: similar triangles have the same angles and proportional sides!</li>
                </ul>
                <p>Ready? Click the close button to start your adventure!</p>
            `;
            modalOverlay.style.display = 'flex';
        }
        
        // Show help modal
        function showHelp() {
            modalText.innerHTML = `
                <h2>How to Play Similar Triangles Adventure</h2>
                <p>In this game, you need to identify triangles that are similar to the target triangle (shown in purple).</p>
                
                <h3>What are Similar Triangles?</h3>
                <p>Two triangles are similar if:</p>
                <ul>
                    <li>Their corresponding angles are equal</li>
                    <li>Their corresponding sides are proportional</li>
                </ul>
                
                <div style="text-align: center; margin: 20px 0;">
                    <svg width="300" height="150" style="display: inline-block;">
                        <polygon points="50,120 100,20 150,120" fill="#a6d8ff" stroke="#0066cc" stroke-width="2"/>
                        <polygon points="180,120 210,60 240,120" fill="#ffcccc" stroke="#cc0000" stroke-width="2"/>
                        <line x1="100" y1="20" x2="210" y2="60" stroke="#333" stroke-width="1" stroke-dasharray="4"/>
                        <line x1="50" y1="120" x2="180" y2="120" stroke="#333" stroke-width="1" stroke-dasharray="4"/>
                        <line x1="150" y1="120" x2="240" y2="120" stroke="#333" stroke-width="1" stroke-dasharray="4"/>
                    </svg>
                </div>
                
                <h3>Example:</h3>
                <p>If Triangle A has sides of length 3, 4, and 5, and Triangle B has sides of length 6, 8, and 10, they are similar because:</p>
                <ul>
                    <li>The ratio of corresponding sides is 1:2 (3:6, 4:8, 5:10)</li>
                    <li>All angles are the same in both triangles</li>
                </ul>
                
                <h3>Game Controls:</h3>
                <ul>
                    <li><strong>Click or tap</strong> on triangles you think are similar to the target</li>
                    <li>Use the <strong>Settings</strong> button to change game options</li>
                    <li>Press <strong>Next Question</strong> to move to a new problem</li>
                </ul>
                
                <h3>Advanced Concepts:</h3>
                <p>As you progress in the game, you'll learn about:</p>
                <ul>
                    <li>Scale factors - how much larger or smaller one triangle is compared to another</li>
                    <li>Corresponding sides and angles</li>
                    <li>Proportional relationships</li>
                    <li>Geometric transformations</li>
                </ul>
                
                <p>Remember, the more you practice, the better you'll get! Good luck!</p>
            `;
            modalOverlay.style.display = 'flex';
        }
        
        // Create game characters
        function createCharacters() {
            // Create professor character
            gameState.characters.push({
                type: CHARACTER_TYPES.PROFESSOR,
                x: canvas.width * 0.85,
                y: canvas.height * 0.2,
                targetX: canvas.width * 0.85,
                targetY: canvas.height * 0.2,
                vx: 0,
                vy: 0,
                message: '',
                messageTimer: 0,
                animationPhase: 0
            });
            
            // Create assistant character
            gameState.characters.push({
                type: CHARACTER_TYPES.ASSISTANT,
                x: canvas.width * 0.15,
                y: canvas.height * 0.8,
                targetX: canvas.width * 0.15,
                targetY: canvas.height * 0.8,
                vx: 0,
                vy: 0,
                message: '',
                messageTimer: 0,
                animationPhase: Math.PI
            });
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Reposition characters if they exist
            if (gameState.characters.length > 0) {
                gameState.characters[0].targetX = canvas.width * 0.85;
                gameState.characters[0].targetY = canvas.height * 0.2;
                gameState.characters[1].targetX = canvas.width * 0.15;
                gameState.characters[1].targetY = canvas.height * 0.8;
            }
        }

        // Toggle control panel
        function toggleControlPanel() {
            controlPanel.classList.toggle('hidden');
            togglePanelBtn.textContent = controlPanel.classList.contains('hidden') ? 'Show Settings' : 'Hide Settings';
        }

        // Reset game
        function resetGame() {
            gameState.score = 0;
            gameState.level = 1;
            updateScoreDisplay();
            generateNewQuestion();
        }

        // Generate new question
        function generateNewQuestion() {
            // Reset game state for new question
            gameState.triangles = [];
            gameState.correctTriangles = [];
            gameState.incorrectGuesses = [];
            gameState.selectedTriangle = null;
            gameState.gamePhase = 'question';
            
            // Generate base triangle (this will be the reference for similarity)
            gameState.baseTriangle = generateRandomTriangle(canvas.width / 2, canvas.height / 2, 80);
            
            // Create target triangle (always similar to the base)
            const scaleFactor = 0.6 + Math.random() * 0.8; // Scale factor between 0.6 and 1.4
            gameState.targetTriangle = scaleTriangle(gameState.baseTriangle, scaleFactor);
            
            // Position the target triangle
            const targetX = canvas.width * 0.5;
            const targetY = canvas.height * 0.25;
            moveTriangle(gameState.targetTriangle, targetX, targetY);
            gameState.targetTriangle.color = '#8e44ad'; // Purple color for target
            gameState.targetTriangle.isTarget = true;
            
            // Generate triangles for the quiz
            const numSimilar = Math.max(1, Math.floor(gameState.numTriangles / 3)); // At least 1 similar triangle
            const numTriangles = gameState.numTriangles;
            
            for (let i = 0; i < numTriangles; i++) {
                let triangle;
                
                // Decide if this triangle should be similar to the base
                const isSimilar = i < numSimilar;
                
                if (isSimilar) {
                    // Create a similar triangle with different scale
                    const newScaleFactor = 0.5 + (gameState.sizeMultiplierRange * Math.random());
                    triangle = scaleTriangle(gameState.baseTriangle, newScaleFactor);
                    gameState.correctTriangles.push(triangle);
                } else {
                    // Create a non-similar triangle
                    triangle = generateRandomTriangle(0, 0, 60 + Math.random() * 40);
                    
                    // As difficulty increases, make non-similar triangles more similar-looking
                    if (gameState.difficulty > 2) {
                        const similarityFactor = 1 - (0.1 * gameState.difficulty);
                        makeTriangleSomewhatSimilar(triangle, gameState.baseTriangle, similarityFactor);
                    }
                }
                
                // Assign random color
                triangle.color = getRandomBrightColor();
                triangle.isSimilar = isSimilar;
                triangle.isSelected = false;
                triangle.scale = 1;
                triangle.targetScale = 1;
                triangle.rotation = Math.random() * Math.PI * 2;
                triangle.targetRotation = triangle.rotation;
                triangle.targetColor = triangle.color;
                
                // Position triangles in a circular pattern
                const angle = (i / numTriangles) * Math.PI * 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.3;
                const x = canvas.width / 2 + radius * Math.cos(angle);
                const y = canvas.height / 2 + radius * Math.sin(angle);
                
                moveTriangle(triangle, x, y);
                gameState.triangles.push(triangle);
            }
            
            // Character messages
            const professor = gameState.characters[0];
            const assistant = gameState.characters[1];
            
            professor.message = professor.type.messages[Math.floor(Math.random() * professor.type.messages.length)];
            professor.messageTimer = 5; // Display for 5 seconds
            
            assistant.message = '';
            assistant.messageTimer = 0;
        }

        // Generate a random triangle
        function generateRandomTriangle(centerX, centerY, avgSize) {
            // Generate random points around the center
            const points = [];
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 + Math.random() * 0.6 - 0.3;
                const distance = avgSize * (0.7 + Math.random() * 0.6);
                points.push({
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance
                });
            }
            
            return {
                points: points,
                color: '#3498db',
                centerX: centerX,
                centerY: centerY
            };
        }

        // Make a triangle somewhat similar to another
        function makeTriangleSomewhatSimilar(triangle, referenceTriangle, similarityFactor) {
            // Clone the reference triangle
            const similarTriangle = scaleTriangle(referenceTriangle, 1 + Math.random() * 0.4);
            
            // Blend between random and similar triangle
            for (let i = 0; i < 3; i++) {
                triangle.points[i].x = triangle.points[i].x * (1 - similarityFactor) + similarTriangle.points[i].x * similarityFactor;
                triangle.points[i].y = triangle.points[i].y * (1 - similarityFactor) + similarTriangle.points[i].y * similarityFactor;
            }
            
            // Recalculate center
            updateTriangleCenter(triangle);
        }

        // Scale a triangle by a factor
        function scaleTriangle(triangle, scaleFactor) {
            const newTriangle = {
                points: [],
                color: triangle.color,
                centerX: triangle.centerX,
                centerY: triangle.centerY
            };
            
            for (let i = 0; i < triangle.points.length; i++) {
                const dx = triangle.points[i].x - triangle.centerX;
                const dy = triangle.points[i].y - triangle.centerY;
                
                newTriangle.points.push({
                    x: triangle.centerX + dx * scaleFactor,
                    y: triangle.centerY + dy * scaleFactor
                });
            }
            
            return newTriangle;
        }

        // Move a triangle to a new center position
        function moveTriangle(triangle, newCenterX, newCenterY) {
            const dx = newCenterX - triangle.centerX;
            const dy = newCenterY - triangle.centerY;
            
            for (let i = 0; i < triangle.points.length; i++) {
                triangle.points[i].x += dx;
                triangle.points[i].y += dy;
            }
            
            triangle.centerX = newCenterX;
            triangle.centerY = newCenterY;
        }

        // Update triangle center based on points
        function updateTriangleCenter(triangle) {
            let sumX = 0;
            let sumY = 0;
            
            for (let i = 0; i < triangle.points.length; i++) {
                sumX += triangle.points[i].x;
                sumY += triangle.points[i].y;
            }
            
            triangle.centerX = sumX / triangle.points.length;
            triangle.centerY = sumY / triangle.points.length;
        }

        // Game loop
        function gameLoop(timestamp) {
            // Calculate delta time
            gameState.deltaTime = (timestamp - gameState.lastUpdateTime) / 1000; // Convert to seconds
            gameState.lastUpdateTime = timestamp;
            
            // Apply animation speed
            const effectiveDelta = gameState.deltaTime * gameState.animationSpeed;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update game elements
            updateTriangles(effectiveDelta);
            updateCharacters(effectiveDelta);
            updateParticles(effectiveDelta);
            
            // Draw game elements
            drawBackground();
            drawTriangles();
            drawCharacters();
            drawParticles();
            
            // Check if all similar triangles have been found
            if (gameState.gamePhase === 'question' && areAllSimilarTrianglesFound()) {
                startCelebration();
            }
            
            // Continue animation loop
            requestAnimationFrame(gameLoop);
        }

        // Update triangles
        function updateTriangles(delta) {
            for (const triangle of gameState.triangles) {
                // Smooth scale animation
                triangle.scale += (triangle.targetScale - triangle.scale) * 5 * delta;
                
                // Smooth rotation animation
                let rotDiff = triangle.targetRotation - triangle.rotation;
                // Normalize to shortest path
                if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                triangle.rotation += rotDiff * 5 * delta;
                
                // Color transitions
                if (triangle.color !== triangle.targetColor) {
                    triangle.color = lerpColor(triangle.color, triangle.targetColor, 5 * delta);
                }
            }
            
            // Update target triangle
            if (gameState.targetTriangle) {
                // Make the target triangle gently float
                const floatY = Math.sin(performance.now() / 1000) * 5;
                moveTriangle(
                    gameState.targetTriangle, 
                    gameState.targetTriangle.centerX,
                    canvas.height * 0.25 + floatY
                );
            }
        }

        // Update characters
        function updateCharacters(delta) {
            for (const character of gameState.characters) {
                // Movement
                const dx = character.targetX - character.x;
                const dy = character.targetY - character.y;
                character.x += dx * 2 * delta;
                character.y += dy * 2 * delta;
                
                // Animation
                character.animationPhase += delta;
                
                // Message timer
                if (character.messageTimer > 0) {
                    character.messageTimer -= delta;
                    if (character.messageTimer <= 0) {
                        character.message = '';
                    }
                }
            }
        }

        // Update particles
        function updateParticles(delta) {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                
                // Update position
                particle.x += particle.vx * delta;
                particle.y += particle.vy * delta;
                
                // Apply gravity
                particle.vy += 100 * delta;
                
                // Update lifetime
                particle.lifetime -= delta;
                
                // Remove if expired
                if (particle.lifetime <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        // Draw background
        function drawBackground() {
            // Clear background
            ctx.fillStyle = '#f0f8ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw celebration background if in celebration mode
            if (gameState.gamePhase === 'celebration') {
                const timePhase = (performance.now() % 2000) / 2000;
                const colors = ['#ffe6e6', '#e6ffe6', '#e6e6ff', '#fffde6'];
                const colorIndex = Math.floor(timePhase * colors.length);
                
                ctx.fillStyle = colors[colorIndex];
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw grid
            ctx.strokeStyle = 'rgba(200, 220, 240, 0.5)';
            ctx.lineWidth = 1;
            
            const gridSize = 40;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Draw triangles
        function drawTriangles() {
            // First draw all non-target, non-selected triangles
            for (const triangle of gameState.triangles) {
                if (!triangle.isSelected) {
                    drawTriangle(triangle);
                }
            }
            
            // Then draw the selected triangle
            if (gameState.selectedTriangle) {
                drawTriangle(gameState.selectedTriangle);
            }
            
            // Finally draw the target triangle
            if (gameState.targetTriangle) {
                drawTriangle(gameState.targetTriangle);
                drawTargetLabel();
            }
        }

        // Draw a single triangle
        function drawTriangle(triangle) {
            ctx.save();
            
            // Apply scale and rotation
            ctx.translate(triangle.centerX, triangle.centerY);
            ctx.rotate(triangle.rotation);
            ctx.scale(triangle.scale, triangle.scale);
            ctx.translate(-triangle.centerX, -triangle.centerY);
            
            // Draw the triangle
            ctx.beginPath();
            ctx.moveTo(triangle.points[0].x, triangle.points[0].y);
            
            for (let i = 1; i < triangle.points.length; i++) {
                ctx.lineTo(triangle.points[i].x, triangle.points[i].y);
            }
            
            ctx.closePath();
            
            // Fill triangle
            ctx.fillStyle = triangle.color;
            ctx.fill();
            
            // Draw border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Highlight if selected
            if (triangle.isSelected) {
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            
            // Special highlight for target
            if (triangle.isTarget) {
                ctx.strokeStyle = '#8e44ad';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            
            // Draw side lengths if enabled
            if (gameState.showRatios) {
                drawSideLengths(triangle);
            }
            
            ctx.restore();
        }

        // Draw side lengths
        function drawSideLengths(triangle) {
            const sides = [];
            
            // Calculate side lengths
            for (let i = 0; i < triangle.points.length; i++) {
                const nextIndex = (i + 1) % triangle.points.length;
                const dx = triangle.points[nextIndex].x - triangle.points[i].x;
                const dy = triangle.points[nextIndex].y - triangle.points[i].y;
                const length = Math.sqrt(dx * dx + dy * dy);
                sides.push({
                    length: length,
                    midX: (triangle.points[i].x + triangle.points[nextIndex].x) / 2,
                    midY: (triangle.points[i].y + triangle.points[nextIndex].y) / 2,
                    angle: Math.atan2(dy, dx)
                });
            }
            
            // Normalize to get simple ratios based on the shortest side
            const minLength = Math.min(...sides.map(side => side.length));
            const ratio = 30 / minLength; // Scale factor to keep lengths readable
            
            // Draw length labels
            ctx.save();
            ctx.font = '12px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i < sides.length; i++) {
                const side = sides[i];
                const normalizedLength = Math.round(side.length * ratio * 10) / 10;
                
                // Calculate offset perpendicular to the side
                const offsetX = Math.sin(side.angle) * 15;
                const offsetY = -Math.cos(side.angle) * 15;
                
                // Draw background for text
                const text = normalizedLength.toString();
                const textWidth = ctx.measureText(text).width + 6;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(
                    side.midX + offsetX - textWidth/2, 
                    side.midY + offsetY - 8, 
                    textWidth, 
                    16
                );
                
                // Draw text
                ctx.fillStyle = '#333';
                ctx.fillText(text, side.midX + offsetX, side.midY + offsetY);
            }
            
            ctx.restore();
        }

        // Draw target label
        function drawTargetLabel() {
            const target = gameState.targetTriangle;
            
            ctx.save();
            ctx.font = '16px Arial';
            ctx.fillStyle = '#8e44ad';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Target Triangle', target.centerX, target.centerY - 50);
            ctx.fillText('(Find similar triangles!)', target.centerX, target.centerY - 30);
            ctx.restore();
        }

        // Draw characters
        function drawCharacters() {
            for (const character of gameState.characters) {
                drawCharacter(character);
            }
        }

        // Draw a single character
        function drawCharacter(character) {
            const { x, y, type, animationPhase, message } = character;
            const bounceOffset = Math.sin(animationPhase * 3) * 5;
            
            ctx.save();
            
            // Character body (triangle)
            ctx.beginPath();
            ctx.moveTo(x, y - type.size/2 + bounceOffset);
            ctx.lineTo(x - type.size/2, y + type.size/2 + bounceOffset);
            ctx.lineTo(x + type.size/2, y + type.size/2 + bounceOffset);
            ctx.closePath();
            
            ctx.fillStyle = type.color;
            ctx.fill();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Eyes
            const eyeSize = type.size / 8;
            const eyeOffsetX = type.size / 6;
            const eyeOffsetY = bounceOffset - type.size / 8;
            
            // Left eye
            ctx.beginPath();
            ctx.arc(x - eyeOffsetX, y + eyeOffsetY, eyeSize, 0, Math.PI * 2);
            ctx.fillStyle = type.eyeColor;
            ctx.fill();
            
            // Right eye
            ctx.beginPath();
            ctx.arc(x + eyeOffsetX, y + eyeOffsetY, eyeSize, 0, Math.PI * 2);
            ctx.fillStyle = type.eyeColor;
            ctx.fill();
            
            // Pupils
            const pupilSize = eyeSize / 2;
            const blinkState = Math.sin(animationPhase * 5) > 0.9 ? 0 : 1;
            
            // Blink animation
            if (blinkState > 0) {
                // Left pupil
                ctx.beginPath();
                ctx.arc(x - eyeOffsetX, y + eyeOffsetY, pupilSize, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
                
                // Right pupil
                ctx.beginPath();
                ctx.arc(x + eyeOffsetX, y + eyeOffsetY, pupilSize, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
            }
            
            // Glasses if applicable
            if (type.glasses) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                
                // Left lens
                ctx.beginPath();
                ctx.arc(x - eyeOffsetX, y + eyeOffsetY, eyeSize * 1.5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Right lens
                ctx.beginPath();
                ctx.arc(x + eyeOffsetX, y + eyeOffsetY, eyeSize * 1.5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Bridge
                ctx.beginPath();
                ctx.moveTo(x - eyeOffsetX + eyeSize * 1.2, y + eyeOffsetY);
                ctx.lineTo(x + eyeOffsetX - eyeSize * 1.2, y + eyeOffsetY);
                ctx.stroke();
            }
            
            // Mouth
            const mouthWidth = type.size / 4;
            const mouthHeight = type.size / 12;
            const smileOffset = Math.sin(animationPhase * 2) * 2;
            
            ctx.beginPath();
            ctx.arc(x, y + type.size/4 + bounceOffset, mouthWidth, 0, Math.PI);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Character name
            ctx.font = '14px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(type.name, x, y - type.size * 0.7 + bounceOffset);
            
            // Speech bubble if has message
            if (message && message.length > 0) {
                drawSpeechBubble(x, y - type.size, message);
            }
            
            ctx.restore();
        }

        // Draw speech bubble
        function drawSpeechBubble(x, y, text) {
            ctx.save();
            
            // Measure text
            ctx.font = '14px Arial';
            const textWidth = ctx.measureText(text).width;
            const padding = 10;
            const bubbleWidth = textWidth + padding * 2;
            const bubbleHeight = 30;
            
            // Draw bubble
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Main bubble body
            ctx.beginPath();
            ctx.roundRect(
                x - bubbleWidth / 2,
                y - bubbleHeight - 20,
                bubbleWidth,
                bubbleHeight,
                10
            );
            ctx.fill();
            ctx.stroke();
            
            // Pointer
            ctx.beginPath();
            ctx.moveTo(x, y - 20);
            ctx.lineTo(x + 10, y - 25);
            ctx.lineTo(x - 10, y - 25);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Text
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x, y - bubbleHeight / 2 - 20);
            
            ctx.restore();
        }

        // Draw particles
        function drawParticles() {
            for (const particle of gameState.particles) {
                ctx.save();
                
                ctx.globalAlpha = particle.lifetime / particle.maxLifetime;
                ctx.fillStyle = particle.color;
                
                if (particle.type === 'star') {
                    drawStar(particle.x, particle.y, particle.size);
                } else if (particle.type === 'confetti') {
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Draw a star shape
        function drawStar(x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const outerAngle = i * Math.PI * 2 / 5 - Math.PI / 2;
                const innerAngle = outerAngle + Math.PI / 5;
                
                if (i === 0) {
                    ctx.moveTo(
                        x + Math.cos(outerAngle) * size,
                        y + Math.sin(outerAngle) * size
                    );
                } else {
                    ctx.lineTo(
                        x + Math.cos(outerAngle) * size,
                        y + Math.sin(outerAngle) * size
                    );
                }
                
                ctx.lineTo(
                    x + Math.cos(innerAngle) * size / 2.5,
                    y + Math.sin(innerAngle) * size / 2.5
                );
            }
            ctx.closePath();
            ctx.fill();
        }

        // Handle canvas click
        function handleCanvasClick(e) {
            if (gameState.gamePhase !== 'question') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if a triangle was clicked
            for (const triangle of gameState.triangles) {
                if (isPointInTriangle(x, y, triangle)) {
                    handleTriangleClick(triangle);
                    break;
                }
            }
        }

        // Handle touch start
        function handleCanvasTouchStart(e) {
            e.preventDefault(); // Prevent default touch actions
            
            if (gameState.gamePhase !== 'question') return;
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // Check if a triangle was touched
            for (const triangle of gameState.triangles) {
                if (isPointInTriangle(x, y, triangle)) {
                    handleTriangleClick(triangle);
                    break;
                }
            }
        }

        // Handle triangle click
        function handleTriangleClick(triangle) {
            // Don't allow selecting the same triangle twice
            if (triangle.isSelected) return;
            
            // Set as selected
            triangle.isSelected = true;
            gameState.selectedTriangle = triangle;
            
            // Visual feedback
            triangle.targetScale = 1.2;
            playSound('click');
            
            // Check if the selected triangle is similar to the target
            if (triangle.isSimilar) {
                // Correct selection
                triangle.targetColor = '#2ecc71'; // Green
                updateScore(10);
                
                // Assistant feedback
                const assistant = gameState.characters[1];
                assistant.message = "Great job! That's correct!";
                assistant.messageTimer = 3;
                
                // Create particles
                createParticlesAt(triangle.centerX, triangle.centerY, 'correct');
                
                // Play sound
                playSound('correct');
            } else {
                // Incorrect selection
                triangle.targetColor = '#e74c3c'; // Red
                
                // Add to incorrect guesses
                gameState.incorrectGuesses.push(triangle);
                
                // Assistant feedback
                const assistant = gameState.characters[1];
                assistant.message = "Hmm, that's not similar. Try again!";
                assistant.messageTimer = 3;
                
                // Play sound
                playSound('wrong');
            }
            
            // After a delay, reset the selected triangle
            setTimeout(() => {
                triangle.targetScale = 1;
                gameState.selectedTriangle = null;
            }, 1000);
        }

        // Check if all similar triangles have been found
        function areAllSimilarTrianglesFound() {
            for (const triangle of gameState.correctTriangles) {
                if (!triangle.isSelected) {
                    return false;
                }
            }
            return true;
        }

        // Start celebration
        function startCelebration() {
            gameState.gamePhase = 'celebration';
            
            // Increase level
            gameState.level++;
            
            // Bonus points
            const incorrectPenalty = gameState.incorrectGuesses.length * 5;
            const bonus = Math.max(0, 20 - incorrectPenalty);
            updateScore(bonus);
            
            // Character celebration
            const professor = gameState.characters[0];
            const assistant = gameState.characters[1];
            
            professor.message = "Excellent job! You found all similar triangles!";
            professor.messageTimer = 5;
            
            assistant.message = `Level ${gameState.level} completed! +${bonus} bonus points!`;
            assistant.messageTimer = 5;
            
            // Create celebration particles
            createParticlesAt(canvas.width / 2, canvas.height / 2, 'celebration');
            
            // Play celebration sound
            playSound('celebration');
            
            // Show explanation modal
            setTimeout(showExplanationModal, 2000);
        }

        // Show explanation modal
        function showExplanationModal() {
            const correctTriangle = gameState.correctTriangles[0];
            const targetTriangle = gameState.targetTriangle;
            
            // Calculate scale factor between target and similar triangle
            const targetSide = getTriangleSide(targetTriangle, 0);
            const correctSide = getTriangleSide(correctTriangle, 0);
            const scaleFactor = (targetSide / correctSide).toFixed(2);
            
            modalText.innerHTML = `
                <h2>Great Job! 🎉</h2>
                <p>You found all the similar triangles! Let's understand why they are similar:</p>
                
                <h3>Why are these triangles similar?</h3>
                <ul>
                    <li>They have the <strong>same angles</strong></li>
                    <li>Their sides are <strong>proportional</strong> to each other</li>
                </ul>
                
                <p>The scale factor between the purple target triangle and the green similar triangle is approximately <strong>${scaleFactor}</strong>.</p>
                
                <p>That means each side of the target triangle is about ${scaleFactor} times the corresponding side of the similar triangle.</p>
                
                <h3>Try to remember:</h3>
                <ol>
                    <li>Similar triangles have the <strong>same shape</strong> but different sizes</li>
                    <li>The <strong>angles</strong> in similar triangles are equal</li>
                    <li>The <strong>ratio</strong> between corresponding sides is the same</li>
                </ol>
                
                <p style="text-align: center;">
                    <button id="continue-btn" style="padding: 10px 20px; font-size: 18px; background-color: #4CAF50;">
                        Continue to Level ${gameState.level}
                    </button>
                </p>
            `;
            
            modalOverlay.style.display = 'flex';
            
            // Add event listener to continue button
            document.getElementById('continue-btn').addEventListener('click', () => {
                modalOverlay.style.display = 'none';
                generateNewQuestion();
            });
        }

        // Get triangle side length
        function getTriangleSide(triangle, sideIndex) {
            const p1 = triangle.points[sideIndex];
            const p2 = triangle.points[(sideIndex + 1) % triangle.points.length];
            
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Update score
        function updateScore(points) {
            gameState.score += points;
            updateScoreDisplay();
        }

        // Update score display
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${gameState.score} | Level: ${gameState.level}`;
        }

        // Create particles at a position
        function createParticlesAt(x, y, type) {
            if (type === 'correct') {
                // Create stars and circles
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 100 + Math.random() * 200;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 200, // Initial upward velocity
                        size: 5 + Math.random() * 10,
                        color: getRandomBrightColor(),
                        type: Math.random() > 0.5 ? 'star' : 'circle',
                        lifetime: 1 + Math.random(),
                        maxLifetime: 1 + Math.random()
                    });
                }
            } else if (type === 'celebration') {
                // Create lots of confetti and stars
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 100 + Math.random() * 300;
                    const startX = canvas.width * (0.3 + Math.random() * 0.4);
                    const startY = canvas.height * 0.3;
                    
                    gameState.particles.push({
                        x: startX,
                        y: startY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 200,
                        size: 5 + Math.random() * 15,
                        color: getRandomBrightColor(),
                        type: Math.random() > 0.6 ? 'star' : 'confetti',
                        lifetime: 2 + Math.random() * 2,
                        maxLifetime: 2 + Math.random() * 2
                    });
                }
            }
        }

        // Play sound
        function playSound(type) {
            if (!gameState.soundsEnabled || !audioContext) return;
            
            // Create oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            if (type === 'click') {
                // Click sound
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            } else if (type === 'correct') {
                // Correct answer sound
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            } else if (type === 'wrong') {
                // Wrong answer sound
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            } else if (type === 'celebration') {
                // Celebration fanfare
                playMultiToneSound([523.25, 659.25, 783.99], 0.3);
            }
        }

        // Play a sequence of tones
        function playMultiToneSound(frequencies, duration) {
            if (!gameState.soundsEnabled || !audioContext) return;
            
            frequencies.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.15);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.15);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + index * 0.15 + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.15 + duration);
                
                oscillator.start(audioContext.currentTime + index * 0.15);
                oscillator.stop(audioContext.currentTime + index * 0.15 + duration);
            });
        }

        // Utility Functions
        
        // Check if a point is inside a triangle
        function isPointInTriangle(x, y, triangle) {
            const p1 = triangle.points[0];
            const p2 = triangle.points[1];
            const p3 = triangle.points[2];
            
            const area = 0.5 * Math.abs(
                (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y))
            );
            
            const area1 = 0.5 * Math.abs((x * (p2.y - p3.y) + p2.x * (p3.y - y) + p3.x * (y - p2.y)));
            const area2 = 0.5 * Math.abs((p1.x * (y - p3.y) + x * (p3.y - p1.y) + p3.x * (p1.y - y)));
            const area3 = 0.5 * Math.abs((p1.x * (p2.y - y) + p2.x * (y - p1.y) + x * (p1.y - p2.y)));
            
            // Account for floating point errors with a small epsilon
            return Math.abs(area - (area1 + area2 + area3)) < 0.1;
        }
        
        // Linear interpolation function for colors
        function lerpColor(color1, color2, t) {
            // Convert hex to RGB
            const rgb1 = hexToRgb(color1);
            const rgb2 = hexToRgb(color2);
            
            // Interpolate each component
            const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);
            const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);
            const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);
            
            // Convert back to hex
            return rgbToHex(r, g, b);
        }
        
        // Convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        // Convert RGB to hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // Get a random bright color
        function getRandomBrightColor() {
            const hue = Math.random() * 360;
            return HSLToHex(hue, 70, 60);
        }
        
        // Convert HSL to hex
        function HSLToHex(h, s, l) {
            s /= 100;
            l /= 100;
            
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            
            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }
            
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            
            return rgbToHex(r, g, b);
        }

        // Polyfill for roundRect if not available
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.arcTo(x + width, y, x + width, y + height, radius);
                this.arcTo(x + width, y + height, x, y + height, radius);
                this.arcTo(x, y + height, x, y, radius);
                this.arcTo(x, y, x + width, y, radius);
                this.closePath();
                return this;
            };
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            // Try to start audio context on first user interaction
            document.addEventListener('click', () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
            
            // Initialize game
            init();
        });
    </script>
</body>
</html>
