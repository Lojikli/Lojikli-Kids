<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melody Hop: Music Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #6e45e2, #88d3ce);
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(180deg, #25074d, #3a1465);
            overflow: hidden;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #6e45e2, #88d3ce);
            z-index: 100;
            transition: opacity 0.5s;
        }

        #settings-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #6e45e2, #88d3ce);
            z-index: 100;
            transition: opacity 0.5s;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            transition: opacity 0.5s;
        }

        #tutorial-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #6e45e2, #88d3ce);
            z-index: 100;
        }

        h1 {
            font-size: 4em;
            margin-bottom: 30px;
            color: #fff;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .subtitle {
            font-size: 1.5em;
            color: #fff;
            margin-bottom: 40px;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 50px;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #FF8E53, #FF6B6B);
        }

        .settings-container {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            width: 80%;
            max-width: 600px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            color: white;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .slider-container {
            display: flex;
            align-items: center;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            margin: 0 10px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #FF6B6B;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .slider-value {
            color: white;
            font-size: 1.2em;
            min-width: 40px;
            text-align: center;
        }

        .character-select {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .character-option {
            width: 80px;
            height: 80px;
            margin: 0 10px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: transform 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .character-option.selected {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .character-option:hover {
            transform: scale(1.05);
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: white;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        #pause-button {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2em;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            z-index: 10;
        }

        #player {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #ffffff;
            z-index: 5;
            transition: transform 0.1s;
        }

        .tile {
            position: absolute;
            width: 120px;
            height: 40px;
            background: linear-gradient(to right, #fd746c, #ff9068);
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform-style: preserve-3d;
            transition: opacity 0.3s;
        }

        .tile.note {
            background: linear-gradient(to right, #6e45e2, #88d3ce);
        }

        .tile.power {
            background: linear-gradient(to right, #8e2de2, #4a00e0);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale3d(1, 1, 1); }
            50% { transform: scale3d(1.05, 1.05, 1.05); }
            100% { transform: scale3d(1, 1, 1); }
        }

        .note-icon {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .effect {
            position: absolute;
            pointer-events: none;
            z-index: 4;
        }

        .star {
            position: absolute;
            pointer-events: none;
            z-index: 4;
        }

        .bubble {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            z-index: 4;
        }

        #tutorial-content {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 20px;
            max-width: 80%;
            text-align: center;
        }

        #tutorial-content h2 {
            margin-bottom: 20px;
            color: #4a00e0;
        }

        #tutorial-content p {
            margin-bottom: 15px;
            font-size: 1.2em;
            line-height: 1.5;
        }

        .controls-illustration {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        .control-key {
            background: #f1f1f1;
            border: 2px solid #ccc;
            border-radius: 5px;
            padding: 10px 15px;
            margin: 0 10px;
            font-weight: bold;
        }

        .progress-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: #FF6B6B;
            width: 0%;
            transition: width 0.3s;
        }

        .streak-display {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.5em;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo-indicator {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        @keyframes fall {
            0% { transform: translateY(-100vh); }
            100% { transform: translateY(100vh); }
        }

        .falling-note {
            position: absolute;
            font-size: 30px;
            color: rgba(255, 255, 255, 0.8);
            animation: fall 3s linear;
            z-index: 3;
            pointer-events: none;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5em;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .character-face {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }

        .character-face .eyes {
            position: absolute;
            top: 30%;
            width: 100%;
            display: flex;
            justify-content: space-evenly;
        }

        .character-face .eye {
            width: 25%;
            height: 25%;
            background: #333;
            border-radius: 50%;
            position: relative;
        }

        .character-face .eye::after {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 40%;
            height: 40%;
            background: white;
            border-radius: 50%;
        }

        .character-face .mouth {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 20%;
            background: #333;
            border-radius: 50px;
        }

        .character-face.happy .mouth {
            border-radius: 50px 50px 0 0;
            transform: translateX(-50%) rotate(180deg);
        }

        .quiz-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            z-index: 200;
            display: none;
        }

        .quiz-title {
            font-size: 2em;
            color: #4a00e0;
            margin-bottom: 20px;
            text-align: center;
        }

        .quiz-question {
            font-size: 1.5em;
            margin-bottom: 30px;
            text-align: center;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }

        .quiz-option {
            background: rgba(110, 69, 226, 0.2);
            border: 2px solid #6e45e2;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quiz-option:hover {
            background: rgba(110, 69, 226, 0.4);
        }

        .quiz-option.selected {
            background: rgba(110, 69, 226, 0.6);
            color: white;
        }

        .quiz-option.correct {
            background: rgba(46, 213, 115, 0.6);
            border-color: #2ed573;
        }

        .quiz-option.incorrect {
            background: rgba(255, 71, 87, 0.6);
            border-color: #ff4757;
        }

        .quiz-button {
            background: linear-gradient(45deg, #6e45e2, #88d3ce);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.5em;
            cursor: pointer;
            display: block;
            margin: 0 auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        .quiz-button:hover {
            transform: scale(1.05);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        .quiz-progress {
            text-align: center;
            margin-top: 20px;
            color: #666;
        }

        .character-bubble {
            position: absolute;
            background: white;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
            max-width: 300px;
            text-align: center;
        }

        .character-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid white;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #6e45e2, #88d3ce);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: white;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Melody Hop...</div>
    </div>

    <div id="game-container">
        <div id="start-screen">
            <h1>Melody Hop</h1>
            <p class="subtitle">Jump to the beat and learn music!</p>
            <button id="start-button" class="button">Play</button>
            <button id="settings-button" class="button">Settings</button>
            <button id="tutorial-button" class="button">How to Play</button>
        </div>

        <div id="settings-screen">
            <h1>Settings</h1>
            <div class="settings-container">
                <div class="setting-group">
                    <label class="setting-label">Music Volume</label>
                    <div class="slider-container">
                        <span class="slider-value" id="music-value">50</span>
                        <input type="range" min="0" max="100" value="50" class="slider" id="music-slider">
                        <span class="slider-value">%</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Sound Effects Volume</label>
                    <div class="slider-container">
                        <span class="slider-value" id="sfx-value">70</span>
                        <input type="range" min="0" max="100" value="70" class="slider" id="sfx-slider">
                        <span class="slider-value">%</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Game Speed</label>
                    <div class="slider-container">
                        <span class="slider-value" id="speed-value">5</span>
                        <input type="range" min="1" max="10" value="5" class="slider" id="speed-slider">
                        <span class="slider-value">/10</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Tile Frequency</label>
                    <div class="slider-container">
                        <span class="slider-value" id="frequency-value">5</span>
                        <input type="range" min="1" max="10" value="5" class="slider" id="frequency-slider">
                        <span class="slider-value">/10</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Choose Your Character</label>
                    <div class="character-select">
                        <div class="character-option selected" data-color="#FF6B6B">
                            <div class="character-face happy" style="background-color: #FF6B6B;">
                                <div class="eyes">
                                    <div class="eye"></div>
                                    <div class="eye"></div>
                                </div>
                                <div class="mouth"></div>
                            </div>
                        </div>
                        <div class="character-option" data-color="#33D9B2">
                            <div class="character-face happy" style="background-color: #33D9B2;">
                                <div class="eyes">
                                    <div class="eye"></div>
                                    <div class="eye"></div>
                                </div>
                                <div class="mouth"></div>
                            </div>
                        </div>
                        <div class="character-option" data-color="#FFDA79">
                            <div class="character-face happy" style="background-color: #FFDA79;">
                                <div class="eyes">
                                    <div class="eye"></div>
                                    <div class="eye"></div>
                                </div>
                                <div class="mouth"></div>
                            </div>
                        </div>
                        <div class="character-option" data-color="#706FD3">
                            <div class="character-face happy" style="background-color: #706FD3;">
                                <div class="eyes">
                                    <div class="eye"></div>
                                    <div class="eye"></div>
                                </div>
                                <div class="mouth"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <button id="settings-back-button" class="button">Back</button>
        </div>

        <div id="tutorial-screen">
            <div id="tutorial-content">
                <h2>How to Play Melody Hop</h2>
                <p>Melody Hop is a music-based jumping game where you hop from tile to tile collecting musical notes!</p>
                
                <p>Use the <strong>left</strong> and <strong>right</strong> arrow keys to move your character:</p>
                <div class="controls-illustration">
                    <div class="control-key">←</div>
                    <div class="control-key">→</div>
                </div>
                
                <p>Jump on tiles to stay in the game and collect musical notes to earn points!</p>
                <p>The more notes you collect in a row, the higher your combo multiplier!</p>
                <p>Watch out for special power-up tiles that give you special abilities!</p>
                <p>Complete music quizzes to earn bonus points and learn about music concepts!</p>
                
                <p>How far can you go? Good luck!</p>
                
                <button id="tutorial-close-button" class="button">Got it!</button>
            </div>
        </div>

        <div id="game-over-screen">
            <h1>Game Over</h1>
            <p class="subtitle">Your Score: <span id="final-score">0</span></p>
            <p class="subtitle">High Score: <span id="high-score">0</span></p>
            <button id="restart-button" class="button">Play Again</button>
            <button id="home-button" class="button">Main Menu</button>
        </div>

        <div id="score-display">Score: 0</div>
        <div class="level-indicator">Level: 1</div>
        <div class="streak-display">Combo: x1</div>
        <div id="combo-indicator">+50!</div>
        <button id="pause-button">⏸️</button>

        <div class="progress-container">
            <div class="progress-bar"></div>
        </div>

        <div id="player">
            <div class="character-face happy">
                <div class="eyes">
                    <div class="eye"></div>
                    <div class="eye"></div>
                </div>
                <div class="mouth"></div>
            </div>
        </div>

        <div id="melody-bubble" class="character-bubble"></div>

        <div class="quiz-container">
            <h2 class="quiz-title">Music Quiz!</h2>
            <div class="quiz-question">What is a quarter note?</div>
            <div class="quiz-options">
                <div class="quiz-option">A note that lasts one beat</div>
                <div class="quiz-option">A note that lasts four beats</div>
                <div class="quiz-option">A note that costs 25 cents</div>
                <div class="quiz-option">A note that is one fourth of a whole note</div>
            </div>
            <button class="quiz-button">Submit Answer</button>
            <div class="quiz-progress">Question 1/5</div>
        </div>
    </div>

    <script>
        // Game constants and variables
        const gameState = {
            isPlaying: false,
            isPaused: false,
            score: 0,
            highScore: 0,
            level: 1,
            speed: 5,
            tileFrequency: 5,
            musicVolume: 0.5,
            sfxVolume: 0.7,
            playerColor: '#FF6B6B',
            playerPosition: {
                x: 0,
                y: 0
            },
            tiles: [],
            lastTileTime: 0,
            currentTile: null,
            fallingSpeed: 2,
            tileGap: 300,
            leftPressed: false,
            rightPressed: false,
            comboStreak: 0,
            comboMultiplier: 1,
            levelProgress: 0,
            nextQuizAt: 1000,
            quizCompleted: false,
            currentQuiz: {
                question: '',
                options: [],
                correctAnswer: '',
                userAnswer: ''
            },
            quizCount: 0,
            quizTotal: 5,
            characterBubbleTimers: [],
            animationFrameId: null,
            gameWidth: window.innerWidth,
            gameHeight: window.innerHeight,
            noteIcons: ['♩', '♪', '♫', '♬', '𝄞'],
            activeEffects: [],
            effectTimers: [],
            introPlayed: false,
            tutorialShown: localStorage.getItem('tutorialShown') === 'true',
            fallingNotes: []
        };

        // Audio context
        let audioContext;
        let backgroundMusic;
        let backgroundMusicSource;
        let backgroundMusicGain;

        // Element references
        const elements = {
            screens: {
                start: document.getElementById('start-screen'),
                settings: document.getElementById('settings-screen'),
                tutorial: document.getElementById('tutorial-screen'),
                gameOver: document.getElementById('game-over-screen'),
                loading: document.getElementById('loading-screen')
            },
            buttons: {
                start: document.getElementById('start-button'),
                settings: document.getElementById('settings-button'),
                tutorial: document.getElementById('tutorial-button'),
                settingsBack: document.getElementById('settings-back-button'),
                tutorialClose: document.getElementById('tutorial-close-button'),
                restart: document.getElementById('restart-button'),
                home: document.getElementById('home-button'),
                pause: document.getElementById('pause-button')
            },
            sliders: {
                music: document.getElementById('music-slider'),
                sfx: document.getElementById('sfx-slider'),
                speed: document.getElementById('speed-slider'),
                frequency: document.getElementById('frequency-slider')
            },
            values: {
                music: document.getElementById('music-value'),
                sfx: document.getElementById('sfx-value'),
                speed: document.getElementById('speed-value'),
                frequency: document.getElementById('frequency-value')
            },
            characterOptions: document.querySelectorAll('.character-option'),
            player: document.getElementById('player'),
            scoreDisplay: document.getElementById('score-display'),
            finalScore: document.getElementById('final-score'),
            highScore: document.getElementById('high-score'),
            gameContainer: document.getElementById('game-container'),
            progressBar: document.querySelector('.progress-bar'),
            levelIndicator: document.querySelector('.level-indicator'),
            streakDisplay: document.querySelector('.streak-display'),
            comboIndicator: document.getElementById('combo-indicator'),
            quizContainer: document.querySelector('.quiz-container'),
            quizQuestion: document.querySelector('.quiz-question'),
            quizOptions: document.querySelector('.quiz-options'),
            quizButton: document.querySelector('.quiz-button'),
            quizProgress: document.querySelector('.quiz-progress'),
            melodyBubble: document.getElementById('melody-bubble')
        };

        // Create sound generation
        function initializeAudio() {
            // Create audio context
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            
            // Create master gain node
            const masterGain = audioContext.createGain();
            masterGain.gain.value = 1;
            masterGain.connect(audioContext.destination);
            
            // Background music gain node
            backgroundMusicGain = audioContext.createGain();
            backgroundMusicGain.gain.value = gameState.musicVolume;
            backgroundMusicGain.connect(masterGain);
            
            // Create and setup background music
            createBackgroundMusic();
        }

        // Create background music
        function createBackgroundMusic() {
            // We'll create procedural background music
            const bpm = 120;
            const beatDuration = 60 / bpm;
            const measures = 8;
            const totalDuration = beatDuration * 4 * measures;
            
            backgroundMusic = audioContext.createBuffer(
                2,
                audioContext.sampleRate * totalDuration,
                audioContext.sampleRate
            );
            
            const leftChannel = backgroundMusic.getChannelData(0);
            const rightChannel = backgroundMusic.getChannelData(1);
            
            // Base chord progression (C, G, Am, F in 4/4 time)
            const chords = [
                [261.63, 329.63, 392.00], // C major
                [392.00, 493.88, 587.33], // G major
                [220.00, 277.18, 329.63], // A minor
                [349.23, 440.00, 523.25]  // F major
            ];
            
            // Melody notes (relative to C major scale)
            const melodyNotes = [
                [5, 0.5], [4, 0.5], [3, 0.5], [4, 0.5], // Measure 1
                [5, 1], [5, 1],                         // Measure 2
                [5, 0.5], [4, 0.5], [3, 0.5], [4, 0.5], // Measure 3
                [3, 1], [2, 1],                         // Measure 4
                [2, 0.5], [3, 0.5], [4, 0.5], [5, 0.5], // Measure 5
                [4, 1], [3, 1],                         // Measure 6
                [2, 0.5], [1, 0.5], [2, 0.5], [3, 0.5], // Measure 7
                [1, 1], [0, 1]                          // Measure 8
            ];
            
            // C major scale frequencies
            const cMajorScale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
            
            // Fill the buffer with simple synthesized music
            let time = 0;
            for (let measure = 0; measure < measures; measure++) {
                // Current chord for this measure
                const chord = chords[measure % chords.length];
                
                // Each measure has 4 beats
                for (let beat = 0; beat < 4; beat++) {
                    // Add chord on beats 0 and 2
                    if (beat === 0 || beat === 2) {
                        addChord(chord, time, beatDuration * 1.9);
                    }
                    
                    time += beatDuration;
                }
            }
            
            // Add melody
            time = 0;
            for (const [noteIndex, duration] of melodyNotes) {
                const frequency = cMajorScale[noteIndex];
                addNote(frequency, time, beatDuration * duration, 0.2);
                time += beatDuration * duration;
            }
            
            // Helper function to add a chord
            function addChord(frequencies, startTime, duration) {
                for (const frequency of frequencies) {
                    addNote(frequency, startTime, duration, 0.1);
                }
            }
            
            // Helper function to add a note
            function addNote(frequency, startTime, duration, volume) {
                // Convert time to sample index
                const startSample = Math.floor(startTime * audioContext.sampleRate);
                const endSample = Math.floor((startTime + duration) * audioContext.sampleRate);
                
                // Attack and release in seconds
                const attack = 0.01;
                const release = 0.05;
                
                const attackSamples = Math.floor(attack * audioContext.sampleRate);
                const releaseSamples = Math.floor(release * audioContext.sampleRate);
                
                for (let i = startSample; i < endSample; i++) {
                    if (i >= backgroundMusic.length) break;
                    
                    // Calculate amplitude envelope
                    let amplitude = volume;
                    
                    // Apply attack
                    if (i - startSample < attackSamples) {
                        amplitude *= (i - startSample) / attackSamples;
                    }
                    
                    // Apply release
                    if (endSample - i < releaseSamples) {
                        amplitude *= (endSample - i) / releaseSamples;
                    }
                    
                    // Generate sine wave
                    const sampleTime = i / audioContext.sampleRate;
                    const sample = Math.sin(2 * Math.PI * frequency * sampleTime) * amplitude;
                    
                    // Add to both channels with slight variation for stereo effect
                    if (i < leftChannel.length) {
                        leftChannel[i] += sample * 0.95;
                        rightChannel[i] += sample * 1.05;
                    }
                }
            }
        }

        // Play background music
        function playBackgroundMusic() {
            if (backgroundMusicSource) {
                backgroundMusicSource.stop();
            }
            
            backgroundMusicSource = audioContext.createBufferSource();
            backgroundMusicSource.buffer = backgroundMusic;
            backgroundMusicSource.loop = true;
            backgroundMusicSource.connect(backgroundMusicGain);
            backgroundMusicSource.start();
        }

        // Stop background music
        function stopBackgroundMusic() {
            if (backgroundMusicSource) {
                backgroundMusicSource.stop();
                backgroundMusicSource = null;
            }
        }

        // Play button sound
        function playButtonSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            }
        }

        // Play jump sound
        function playJumpSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            }
        }

        // Play note collect sound
        function playNoteSound(noteIndex = 0) {
            if (audioContext && gameState.sfxVolume > 0) {
                // Use pentatonic scale
                const pentatonicScale = [523.25, 587.33, 659.25, 783.99, 880.00];
                const frequency = pentatonicScale[noteIndex % pentatonicScale.length];
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.5, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            }
        }

        // Play success sound
        function playSuccessSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                
                notes.forEach((frequency, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.1);
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.1);
                    gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.5, audioContext.currentTime + index * 0.1 + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + index * 0.1 + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start(audioContext.currentTime + index * 0.1);
                    oscillator.stop(audioContext.currentTime + index * 0.1 + 0.3);
                });
            }
        }

        // Play error sound
        function playErrorSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                const frequencies = [349.23, 329.63, 311.13]; // F4, E4, D#4/Eb4
                
                frequencies.forEach((frequency, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.15);
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.15);
                    gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.5, audioContext.currentTime + index * 0.15 + 0.01);
                    gainNode.gain.linearRampToValueAtTime(0.001, audioContext.currentTime + index * 0.15 + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start(audioContext.currentTime + index * 0.15);
                    oscillator.stop(audioContext.currentTime + index * 0.15 + 0.3);
                });
            }
        }

        // Play level up sound
        function playLevelUpSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                // Major scale ascending
                const notes = [
                    { freq: 523.25, time: 0 },    // C5
                    { freq: 587.33, time: 0.1 },  // D5
                    { freq: 659.25, time: 0.2 },  // E5
                    { freq: 698.46, time: 0.3 },  // F5
                    { freq: 783.99, time: 0.4 },  // G5
                    { freq: 880.00, time: 0.5 },  // A5
                    { freq: 987.77, time: 0.6 },  // B5
                    { freq: 1046.50, time: 0.7 }  // C6
                ];
                
                notes.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime + note.time);
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime + note.time);
                    gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.5, audioContext.currentTime + note.time + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + note.time + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + 0.2);
                });
            }
        }

        // Play game over sound
        function playGameOverSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                const frequencies = [523.25, 493.88, 440.00, 392.00, 349.23, 329.63, 293.66, 261.63]; // C5 to C4 descending
                
                frequencies.forEach((frequency, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + index * 0.1);
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.1);
                    gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.5, audioContext.currentTime + index * 0.1 + 0.01);
                    gainNode.gain.linearRampToValueAtTime(0.001, audioContext.currentTime + index * 0.1 + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start(audioContext.currentTime + index * 0.1);
                    oscillator.stop(audioContext.currentTime + index * 0.1 + 0.2);
                });

                // Final chord after the scale
                setTimeout(() => {
                    // Minor chord
                    const chordNotes = [261.63, 311.13, 392.00]; // C4, Eb4, G4
                    
                    chordNotes.forEach(frequency => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.3, audioContext.currentTime + 0.01);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.0);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 1.0);
                    });
                }, 900);
            }
        }

        // Play power-up sound
        function playPowerUpSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.type = 'sine';
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator1.frequency.exponentialRampToValueAtTime(1046.50, audioContext.currentTime + 0.3);
                
                oscillator2.type = 'sine';
                oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator2.frequency.exponentialRampToValueAtTime(1318.51, audioContext.currentTime + 0.4);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.5, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.5);
                
                oscillator2.start(audioContext.currentTime + 0.1);
                oscillator2.stop(audioContext.currentTime + 0.5);
            }
        }

        // Play quiz appear sound
        function playQuizSound() {
            if (audioContext && gameState.sfxVolume > 0) {
                // Chord progression
                const chords = [
                    [523.25, 659.25, 783.99], // C major
                    [587.33, 698.46, 880.00]  // D major
                ];
                
                chords.forEach((chord, chordIndex) => {
                    chord.forEach(frequency => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + chordIndex * 0.3);
                        
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime + chordIndex * 0.3);
                        gainNode.gain.linearRampToValueAtTime(gameState.sfxVolume * 0.3, audioContext.currentTime + chordIndex * 0.3 + 0.01);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + chordIndex * 0.3 + 0.5);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.start(audioContext.currentTime + chordIndex * 0.3);
                        oscillator.stop(audioContext.currentTime + chordIndex * 0.3 + 0.5);
                    });
                });
            }
        }

        // Initialize game
        async function initGame() {
            // Try to load high score from localStorage
            try {
                const savedHighScore = localStorage.getItem('melodyHopHighScore');
                if (savedHighScore) {
                    gameState.highScore = parseInt(savedHighScore);
                    elements.highScore.textContent = gameState.highScore;
                }

                // Load settings from localStorage
                const savedSettings = localStorage.getItem('melodyHopSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    
                    // Update sliders
                    elements.sliders.music.value = settings.musicVolume * 100;
                    elements.sliders.sfx.value = settings.sfxVolume * 100;
                    elements.sliders.speed.value = settings.speed;
                    elements.sliders.frequency.value = settings.tileFrequency;
                    
                    // Update values
                    elements.values.music.textContent = settings.musicVolume * 100;
                    elements.values.sfx.textContent = settings.sfxVolume * 100;
                    elements.values.speed.textContent = settings.speed;
                    elements.values.frequency.textContent = settings.tileFrequency;
                    
                    // Update game state
                    gameState.musicVolume = settings.musicVolume;
                    gameState.sfxVolume = settings.sfxVolume;
                    gameState.speed = settings.speed;
                    gameState.tileFrequency = settings.tileFrequency;
                    gameState.playerColor = settings.playerColor;
                    
                    // Update character selection
                    elements.characterOptions.forEach(option => {
                        if (option.dataset.color === settings.playerColor) {
                            option.classList.add('selected');
                        } else {
                            option.classList.remove('selected');
                        }
                    });
                    
                    // Update player color
                    elements.player.querySelector('.character-face').style.backgroundColor = settings.playerColor;
                }
            } catch (error) {
                console.error('Error loading saved data:', error);
            }
            
            // Set player initial position
            resetPlayerPosition();
            
            // Add event listeners for buttons
            elements.buttons.start.addEventListener('click', startGame);
            elements.buttons.settings.addEventListener('click', showSettings);
            elements.buttons.tutorial.addEventListener('click', showTutorial);
            elements.buttons.settingsBack.addEventListener('click', hideSettings);
            elements.buttons.tutorialClose.addEventListener('click', hideTutorial);
            elements.buttons.restart.addEventListener('click', restartGame);
            elements.buttons.home.addEventListener('click', goToMainMenu);
            elements.buttons.pause.addEventListener('click', togglePause);
            
            // Add event listeners for sliders
            elements.sliders.music.addEventListener('input', updateMusicVolume);
            elements.sliders.sfx.addEventListener('input', updateSfxVolume);
            elements.sliders.speed.addEventListener('input', updateSpeed);
            elements.sliders.frequency.addEventListener('input', updateFrequency);
            
            // Add event listeners for character selection
            elements.characterOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.characterOptions.forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                    gameState.playerColor = option.dataset.color;
                    elements.player.querySelector('.character-face').style.backgroundColor = gameState.playerColor;
                    saveSettings();
                    playButtonSound();
                });
            });
            
            // Add event listeners for keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Add event listeners for quiz
            elements.quizButton.addEventListener('click', checkQuizAnswer);
            elements.quizOptions.addEventListener('click', selectQuizOption);
            
            // Initialize audio
            try {
                await initializeAudio();
                // Hide loading screen
                elements.screens.loading.style.display = 'none';
                
                // Show tutorial for first-time players
                if (!gameState.tutorialShown) {
                    showTutorial();
                    localStorage.setItem('tutorialShown', 'true');
                }
            } catch (error) {
                console.error('Error initializing audio:', error);
                // Still hide loading screen even if audio fails
                elements.screens.loading.style.display = 'none';
            }
            
            // Initial resize handling
            handleResize();
            window.addEventListener('resize', handleResize);
        }

        // Reset player position
        function resetPlayerPosition() {
            gameState.playerPosition.x = gameState.gameWidth / 2;
            gameState.playerPosition.y = gameState.gameHeight * 0.8;
            updatePlayerPosition();
        }

        // Update player position in DOM
        function updatePlayerPosition() {
            elements.player.style.left = `${gameState.playerPosition.x - 30}px`;
            elements.player.style.top = `${gameState.playerPosition.y - 30}px`;
        }

        // Start game
        function startGame() {
            playButtonSound();
            
            // Reset game state
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.score = 0;
            gameState.level = 1;
            gameState.comboStreak = 0;
            gameState.comboMultiplier = 1;
            gameState.levelProgress = 0;
            gameState.nextQuizAt = 1000;
            gameState.quizCompleted = false;
            gameState.quizCount = 0;
            gameState.tiles = [];
            gameState.lastTileTime = 0;
            gameState.currentTile = null;
            
            // Update UI
            elements.scoreDisplay.textContent = `Score: ${gameState.score}`;
            elements.levelIndicator.textContent = `Level: ${gameState.level}`;
            elements.progressBar.style.width = '0%';
            elements.streakDisplay.style.opacity = '0';
            
            // Hide start screen
            elements.screens.start.style.display = 'none';
            
            // Clear any existing tiles
            const existingTiles = elements.gameContainer.querySelectorAll('.tile');
            existingTiles.forEach(tile => tile.remove());
            
            // Reset player position
            resetPlayerPosition();
            
            // Start background music
            if (audioContext) {
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Play background music
                playBackgroundMusic();
            }
            
            // Show tutorial message
            showMelodyMessage("Welcome to Melody Hop! Jump on the tiles and collect musical notes!");
            
            // Start game loop
            gameLoop();
        }

        // Game loop
        function gameLoop() {
            if (!gameState.isPlaying) return;
            if (gameState.isPaused) {
                gameState.animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // Calculate time difference for consistent movement
            const now = Date.now();
            const dt = Math.min((now - (gameState.lastTime || now)) / 1000, 0.1); // Cap at 100ms
            gameState.lastTime = now;
            
            // Move tiles
            moveTiles(dt);
            
            // Create new tiles
            if (now - gameState.lastTileTime > getTileDelay()) {
                createTile();
                gameState.lastTileTime = now;
            }
            
            // Move player
            movePlayer(dt);
            
            // Check collisions
            checkCollisions();
            
            // Check if player has fallen off
            checkGameOver();
            
            // Update level progress
            updateProgress();
            
            // Create falling background notes
            if (Math.random() < 0.02) {
                createFallingNote();
            }
            
            // Move falling notes
            moveFallingNotes(dt);
            
            // Request next frame
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Move tiles
        function moveTiles(dt) {
            for (let i = gameState.tiles.length - 1; i >= 0; i--) {
                const tile = gameState.tiles[i];
                
                // Move tile down
                tile.y += getTileSpeed() * dt;
                
                // Update tile position in DOM
                tile.element.style.transform = `translate3d(${tile.x}px, ${tile.y}px, 0) rotateX(${30 + Math.sin(Date.now() / 1000) * 5}deg)`;
                
                // Remove tiles that go off screen
                if (tile.y > gameState.gameHeight + 100) {
                    tile.element.remove();
                    gameState.tiles.splice(i, 1);
                }
            }
        }

        // Create a new tile
        function createTile() {
            // Calculate a random x position
            const minX = 100;
            const maxX = gameState.gameWidth - 100;
            const x = Math.random() * (maxX - minX) + minX;
            
            // Create tile element
            const tileElement = document.createElement('div');
            tileElement.className = 'tile';
            
            // Determine tile type
            let tileType = 'normal';
            let noteIcon = '';
            
            // 30% chance for note tile after level 1
            if (gameState.level > 1 && Math.random() < 0.3) {
                tileType = 'note';
                tileElement.classList.add('note');
                
                // Add note icon
                const iconElement = document.createElement('div');
                iconElement.className = 'note-icon';
                noteIcon = gameState.noteIcons[Math.floor(Math.random() * gameState.noteIcons.length)];
                iconElement.textContent = noteIcon;
                tileElement.appendChild(iconElement);
            }
            // 5% chance for power tile after level 3
            else if (gameState.level >= 3 && Math.random() < 0.05) {
                tileType = 'power';
                tileElement.classList.add('power');
            }
            
            // Position the tile
            tileElement.style.transform = `translate3d(${x}px, ${-100}px, 0) rotateX(30deg)`;
            
            // Add tile to game container
            elements.gameContainer.appendChild(tileElement);
            
            // Store tile data
            const tile = {
                element: tileElement,
                x: x,
                y: -100,
                width: 120,
                height: 40,
                type: tileType,
                note: noteIcon,
                collected: false
            };
            
            gameState.tiles.push(tile);
        }

        // Create a falling note (background effect)
        function createFallingNote() {
            const note = document.createElement('div');
            note.className = 'falling-note';
            note.textContent = gameState.noteIcons[Math.floor(Math.random() * gameState.noteIcons.length)];
            
            // Position randomly
            const x = Math.random() * gameState.gameWidth;
            note.style.left = `${x}px`;
            
            // Add to game container
            elements.gameContainer.appendChild(note);
            
            // Store in game state
            gameState.fallingNotes.push({
                element: note,
                x: x,
                y: -50
            });
            
            // Remove after animation finishes
            setTimeout(() => {
                if (note.parentNode) {
                    note.remove();
                }
                gameState.fallingNotes = gameState.fallingNotes.filter(n => n.element !== note);
            }, 3000);
        }

        // Move falling notes
        function moveFallingNotes(dt) {
            for (let i = gameState.fallingNotes.length - 1; i >= 0; i--) {
                const note = gameState.fallingNotes[i];
                
                // Move note down
                note.y += getTileSpeed() * 0.3 * dt;
                
                // Add some horizontal movement
                note.x += Math.sin(Date.now() / 1000 + i) * 0.5;
                
                // Update position
                note.element.style.transform = `translate(${note.x}px, ${note.y}px)`;
            }
        }

        // Move player
        function movePlayer(dt) {
            const moveSpeed = 500; // Pixels per second
            
            if (gameState.leftPressed) {
                gameState.playerPosition.x = Math.max(30, gameState.playerPosition.x - moveSpeed * dt);
            }
            
            if (gameState.rightPressed) {
                gameState.playerPosition.x = Math.min(gameState.gameWidth - 30, gameState.playerPosition.x + moveSpeed * dt);
            }
            
            // Gravity if player is not on a tile
            if (!gameState.currentTile) {
                gameState.playerPosition.y += 600 * dt; // Gravity
            }
            
            // Update player position in DOM
            updatePlayerPosition();
        }

        // Check collisions between player and tiles
        function checkCollisions() {
            // Reset current tile
            let wasOnTile = gameState.currentTile !== null;
            gameState.currentTile = null;
            
            for (const tile of gameState.tiles) {
                const playerBottom = gameState.playerPosition.y + 30;
                const tileTop = tile.y;
                const playerX = gameState.playerPosition.x;
                const tileLeft = tile.x - tile.width / 2;
                const tileRight = tile.x + tile.width / 2;
                
                // Check if player is above tile and falling onto it
                if (playerBottom >= tileTop && playerBottom <= tileTop + 20 && 
                    playerX >= tileLeft && playerX <= tileRight && 
                    gameState.playerPosition.y > gameState.playerPosition.previousY) {
                    
                    // Land on tile
                    gameState.playerPosition.y = tileTop - 30;
                    gameState.currentTile = tile;
                    
                    // Play jump sound when landing on a new tile
                    if (!wasOnTile) {
                        playJumpSound();
                        
                        // Visual feedback
                        elements.player.style.transform = 'scale(1.2)';
                        setTimeout(() => {
                            elements.player.style.transform = 'scale(1)';
                        }, 150);
                    }
                    
                    // Process tile effects if not already collected
                    if (!tile.collected) {
                        processTileEffect(tile);
                        tile.collected = true;
                    }
                    
                    break;
                }
            }
            
            // Store previous position for next frame
            gameState.playerPosition.previousY = gameState.playerPosition.y;
        }

        // Process tile effect based on type
        function processTileEffect(tile) {
            // Add points for any tile
            addPoints(10);
            
            // Special effects based on tile type
            if (tile.type === 'note') {
                // Collect note
                playNoteSound(gameState.noteIcons.indexOf(tile.note));
                
                // Add points
                addPoints(50);
                
                // Increase combo
                increaseCombo();
                
                // Visual effect
                createParticleEffect(tile.x, tile.y, 'note');
            } else if (tile.type === 'power') {
                // Power up effect
                playPowerUpSound();
                
                // Add points
                addPoints(100);
                
                // Visual effect
                createParticleEffect(tile.x, tile.y, 'power');
                
                // Random power-up effect
                const powerUpEffects = [
                    slowDownTiles,
                    doublePoints,
                    extraLife
                ];
                
                const randomEffect = powerUpEffects[Math.floor(Math.random() * powerUpEffects.length)];
                randomEffect();
            }
        }

        // Slow down tiles power-up
        function slowDownTiles() {
            showMelodyMessage("Power-up: Slow Motion!");
            
            // Create slow motion effect
            const originalSpeed = gameState.speed;
            gameState.speed = Math.max(1, gameState.speed - 3);
            
            // Return to normal after 5 seconds
            setTimeout(() => {
                gameState.speed = originalSpeed;
            }, 5000);
        }

        // Double points power-up
        function doublePoints() {
            showMelodyMessage("Power-up: Double Score!");
            
            // Create double points effect
            const originalMultiplier = gameState.comboMultiplier;
            gameState.comboMultiplier *= 2;
            
            // Visual indicator
            elements.streakDisplay.textContent = `Combo: x${gameState.comboMultiplier}`;
            elements.streakDisplay.style.opacity = '1';
            
            // Return to normal after 5 seconds
            setTimeout(() => {
                gameState.comboMultiplier = originalMultiplier;
                
                if (gameState.comboStreak > 0) {
                    elements.streakDisplay.textContent = `Combo: x${gameState.comboMultiplier}`;
                } else {
                    elements.streakDisplay.style.opacity = '0';
                }
            }, 5000);
        }

        // Extra life power-up
        function extraLife() {
            showMelodyMessage("Power-up: Safety Net!");
            
            // Create temporary platform at the bottom
            const safetyTile = document.createElement('div');
            safetyTile.className = 'tile power';
            safetyTile.style.width = `${gameState.gameWidth - 200}px`;
            safetyTile.style.transform = `translate3d(${gameState.gameWidth / 2 - (gameState.gameWidth - 200) / 2}px, ${gameState.gameHeight - 100}px, 0) rotateX(30deg)`;
            
            elements.gameContainer.appendChild(safetyTile);
            
            // Remove after 5 seconds
            setTimeout(() => {
                safetyTile.style.opacity = '0';
                setTimeout(() => {
                    if (safetyTile.parentNode) {
                        safetyTile.remove();
                    }
                }, 500);
            }, 5000);
        }

        // Increase combo
        function increaseCombo() {
            gameState.comboStreak++;
            
            // Update combo multiplier
            if (gameState.comboStreak >= 10) {
                gameState.comboMultiplier = 4;
            } else if (gameState.comboStreak >= 5) {
                gameState.comboMultiplier = 2;
            } else if (gameState.comboStreak >= 3) {
                gameState.comboMultiplier = 1.5;
            }
            
            // Update UI
            elements.streakDisplay.textContent = `Combo: x${gameState.comboMultiplier}`;
            elements.streakDisplay.style.opacity = '1';
        }

        // Reset combo
        function resetCombo() {
            gameState.comboStreak = 0;
            gameState.comboMultiplier = 1;
            
            // Update UI
            elements.streakDisplay.style.opacity = '0';
        }

        // Add points to score
        function addPoints(points) {
            // Apply combo multiplier
            const multipliedPoints = Math.floor(points * gameState.comboMultiplier);
            
            // Add to score
            gameState.score += multipliedPoints;
            
            // Update UI
            elements.scoreDisplay.textContent = `Score: ${gameState.score}`;
            
            // Show point indicator for significant points
            if (points >= 50) {
                showPointsIndicator(multipliedPoints);
            }
            
            // Update level progress
            gameState.levelProgress += multipliedPoints;
            
            // Update high score if needed
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                elements.highScore.textContent = gameState.highScore;
                
                // Save high score
                localStorage.setItem('melodyHopHighScore', gameState.highScore.toString());
            }
        }

        // Show points indicator
        function showPointsIndicator(points) {
            elements.comboIndicator.textContent = `+${points}!`;
            elements.comboIndicator.style.opacity = '1';
            
            // Animate
            elements.comboIndicator.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            // Hide after animation
            setTimeout(() => {
                elements.comboIndicator.style.transform = 'translate(-50%, -50%) scale(1)';
                setTimeout(() => {
                    elements.comboIndicator.style.opacity = '0';
                }, 200);
            }, 300);
        }

        // Create particle effect
        function createParticleEffect(x, y, type) {
            const particleCount = type === 'power' ? 30 : 15;
            
            for (let i = 0; i < particleCount; i++) {
                createParticle(x, y, type);
            }
        }

        // Create a single particle
        function createParticle(x, y, type) {
            const particle = document.createElement('div');
            
            if (type === 'note') {
                // Star particle
                particle.className = 'effect star';
                
                // Random size
                const size = Math.random() * 20 + 10;
                
                // Star SVG
                particle.innerHTML = `
                    <svg width="${size}" height="${size}" viewBox="0 0 51 48">
                        <path fill="#FFD700" d="m25,1 6,17h18l-14,11 5,17-15-10-15,10 5-17-14-11h18z"/>
                    </svg>
                `;
            } else {
                // Bubble particle
                particle.className = 'effect bubble';
                
                // Random size
                const size = Math.random() * 30 + 10;
                
                // Random color
                const colors = ['#FF9A00', '#4b0082', '#4CAF50', '#f44336', '#2196F3'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.backgroundColor = color;
            }
            
            // Position at effect origin
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            // Add to game container
            elements.gameContainer.appendChild(particle);
            
            // Animation
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            const dx = Math.cos(angle) * speed;
            const dy = Math.sin(angle) * speed;
            
            let opacity = 1;
            let posX = x;
            let posY = y;
            let scale = 1;
            
            const animation = setInterval(() => {
                opacity -= 0.02;
                posX += dx;
                posY += dy;
                scale -= 0.01;
                
                particle.style.opacity = opacity;
                particle.style.left = `${posX}px`;
                particle.style.top = `${posY}px`;
                particle.style.transform = `scale(${Math.max(0.5, scale)})`;
                
                if (opacity <= 0) {
                    clearInterval(animation);
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }
            }, 20);
            
            // Store animation timer
            gameState.effectTimers.push(animation);
        }

        // Check if game should end
        function checkGameOver() {
            if (gameState.playerPosition.y > gameState.gameHeight + 100) {
                endGame();
            }
        }

        // End the game
        function endGame() {
            // Set game state
            gameState.isPlaying = false;
            
            // Stop game loop
            cancelAnimationFrame(gameState.animationFrameId);
            
            // Stop background music
            stopBackgroundMusic();
            
            // Play game over sound
            playGameOverSound();
            
            // Show game over screen
            elements.finalScore.textContent = gameState.score;
            elements.highScore.textContent = gameState.highScore;
            elements.screens.gameOver.style.display = 'flex';
            
            // Clear all effects and timers
            clearAllEffects();
        }

        // Clear all effects and timers
        function clearAllEffects() {
            // Clear all character bubble timers
            gameState.characterBubbleTimers.forEach(timer => clearTimeout(timer));
            gameState.characterBubbleTimers = [];
            
            // Clear all effect timers
            gameState.effectTimers.forEach(timer => clearInterval(timer));
            gameState.effectTimers = [];
            
            // Remove all effects
            const effects = elements.gameContainer.querySelectorAll('.effect');
            effects.forEach(effect => effect.remove());
            
            // Remove all falling notes
            const fallingNotes = elements.gameContainer.querySelectorAll('.falling-note');
            fallingNotes.forEach(note => note.remove());
            gameState.fallingNotes = [];
            
            // Hide character bubbles
            elements.melodyBubble.style.opacity = '0';
        }

        // Restart the game
        function restartGame() {
            playButtonSound();
            elements.screens.gameOver.style.display = 'none';
            startGame();
        }

        // Go to main menu
        function goToMainMenu() {
            playButtonSound();
            elements.screens.gameOver.style.display = 'none';
            elements.screens.start.style.display = 'flex';
            
            // Clear all existing tiles
            const existingTiles = elements.gameContainer.querySelectorAll('.tile');
            existingTiles.forEach(tile => tile.remove());
        }

        // Show settings
        function showSettings() {
            playButtonSound();
            elements.screens.start.style.display = 'none';
            elements.screens.settings.style.display = 'flex';
        }

        // Hide settings
        function hideSettings() {
            playButtonSound();
            elements.screens.settings.style.display = 'none';
            elements.screens.start.style.display = 'flex';
        }

        // Show tutorial
        function showTutorial() {
            playButtonSound();
            elements.screens.start.style.display = 'none';
            elements.screens.tutorial.style.display = 'flex';
        }

        // Hide tutorial
        function hideTutorial() {
            playButtonSound();
            elements.screens.tutorial.style.display = 'none';
            elements.screens.start.style.display = 'flex';
        }

        // Toggle pause
        function togglePause() {
            if (!gameState.isPlaying) return;
            
            gameState.isPaused = !gameState.isPaused;
            
            if (gameState.isPaused) {
                // Pause
                elements.buttons.pause.textContent = '▶️';
                
                // Show message
                showMelodyMessage("Paused! Click ▶️ to continue");
                
                // Pause background music
                if (backgroundMusicSource) {
                    backgroundMusicSource.playbackRate.value = 0.1;
                }
            } else {
                // Resume
                elements.buttons.pause.textContent = '⏸️';
                
                // Resume background music
                if (backgroundMusicSource) {
                    backgroundMusicSource.playbackRate.value = 1;
                }
            }
        }

        // Update progress
        function updateProgress() {
            // Calculate progress percentage
            const levelThreshold = 2000 * gameState.level;
            const percentage = Math.min(100, (gameState.levelProgress / levelThreshold) * 100);
            
            // Update progress bar
            elements.progressBar.style.width = `${percentage}%`;
            
            // Check for level up
            if (gameState.levelProgress >= levelThreshold) {
                levelUp();
            }
            
            // Check for quiz
            if (!gameState.quizCompleted && gameState.score >= gameState.nextQuizAt) {
                showQuiz();
                gameState.quizCompleted = true;
            }
        }

        // Level up
        function levelUp() {
            // Increase level
            gameState.level++;
            
            // Reset progress
            gameState.levelProgress = 0;
            
            // Update UI
            elements.levelIndicator.textContent = `Level: ${gameState.level}`;
            
            // Play level up sound
            playLevelUpSound();
            
            // Show message
            showMelodyMessage(`Level ${gameState.level}! The tiles are moving faster!`);
            
            // Create celebration effect
            createLevelUpEffect();
        }

        // Create level up effect
        function createLevelUpEffect() {
            // Create particles around the player
            createParticleEffect(gameState.playerPosition.x, gameState.playerPosition.y, 'power');
            
            // Show level text
            const levelText = document.createElement('div');
            levelText.textContent = `LEVEL ${gameState.level}`;
            levelText.style.position = 'absolute';
            levelText.style.left = '50%';
            levelText.style.top = '50%';
            levelText.style.transform = 'translate(-50%, -50%)';
            levelText.style.fontSize = '5em';
            levelText.style.color = 'rgba(255, 255, 255, 0)';
            levelText.style.textShadow = '0 0 20px rgba(255, 255, 255, 0.8)';
            levelText.style.zIndex = '20';
            levelText.style.transition = 'all 0.5s';
            
            elements.gameContainer.appendChild(levelText);
            
            // Animate
            setTimeout(() => {
                levelText.style.color = 'rgba(255, 255, 255, 1)';
                levelText.style.fontSize = '8em';
            }, 100);
            
            setTimeout(() => {
                levelText.style.top = '40%';
                levelText.style.opacity = '0';
            }, 1500);
            
            setTimeout(() => {
                levelText.remove();
            }, 2000);
        }

        // Show quiz
        function showQuiz() {
            // Pause game
            gameState.isPaused = true;
            
            // Play quiz sound
            playQuizSound();
            
            // Generate quiz question
            generateQuizQuestion();
            
            // Show quiz container
            elements.quizContainer.style.display = 'block';
        }

        // Generate quiz question
        function generateQuizQuestion() {
            gameState.quizCount++;
            
            const questions = [
                {
                    question: "What is a quarter note?",
                    options: [
                        "A note that lasts one beat",
                        "A note that lasts four beats",
                        "A note that costs 25 cents",
                        "A note that is one fourth of a whole note"
                    ],
                    correctAnswer: 0
                },
                {
                    question: "Which of these is NOT one of the basic elements of music?",
                    options: [
                        "Rhythm",
                        "Temperature",
                        "Melody",
                        "Harmony"
                    ],
                    correctAnswer: 1
                },
                {
                    question: "What does the musical symbol '𝄞' represent?",
                    options: [
                        "Treble Clef",
                        "Bass Clef",
                        "Rest",
                        "Repeat Sign"
                    ],
                    correctAnswer: 0
                },
                {
                    question: "How many lines are in a standard musical staff?",
                    options: [
                        "4",
                        "5",
                        "6",
                        "7"
                    ],
                    correctAnswer: 1
                },
                {
                    question: "Which of these is NOT a type of musical note?",
                    options: [
                        "Whole note",
                        "Half note",
                        "Double note",
                        "Eighth note"
                    ],
                    correctAnswer: 2
                },
                {
                    question: "What do we call a group of notes played together?",
                    options: [
                        "Melody",
                        "Chord",
                        "Scale",
                        "Beat"
                    ],
                    correctAnswer: 1
                },
                {
                    question: "What is 'tempo' in music?",
                    options: [
                        "The loudness or softness",
                        "The speed of the music",
                        "The main melody",
                        "The mood"
                    ],
                    correctAnswer: 1
                },
                {
                    question: "What do musicians use to keep time?",
                    options: [
                        "Metronome",
                        "Thermometer",
                        "Speedometer",
                        "Clock"
                    ],
                    correctAnswer: 0
                },
                {
                    question: "Which instrument family does the piano belong to?",
                    options: [
                        "String",
                        "Percussion",
                        "Woodwind",
                        "Brass"
                    ],
                    correctAnswer: 1
                },
                {
                    question: "What does 'forte' mean in music?",
                    options: [
                        "Play softly",
                        "Play loudly",
                        "Play quickly",
                        "Play slowly"
                    ],
                    correctAnswer: 1
                }
            ];
            
            // Select a random question
            const randomIndex = Math.floor(Math.random() * questions.length);
            const quizQuestion = questions[randomIndex];
            
            // Update quiz UI
            elements.quizQuestion.textContent = quizQuestion.question;
            elements.quizOptions.innerHTML = "";
            
            // Create option elements
            quizQuestion.options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'quiz-option';
                optionElement.textContent = option;
                optionElement.dataset.index = index;
                elements.quizOptions.appendChild(optionElement);
            });
            
            // Update progress
            elements.quizProgress.textContent = `Question ${gameState.quizCount}/5`;
            
            // Store in game state
            gameState.currentQuiz = {
                question: quizQuestion.question,
                options: quizQuestion.options,
                correctAnswer: quizQuestion.correctAnswer,
                userAnswer: null
            };
        }

        // Select quiz option
        function selectQuizOption(event) {
            if (!event.target.classList.contains('quiz-option')) return;
            
            // Clear previous selection
            const options = elements.quizOptions.querySelectorAll('.quiz-option');
            options.forEach(option => option.classList.remove('selected'));
            
            // Select clicked option
            event.target.classList.add('selected');
            
            // Store user's answer
            gameState.currentQuiz.userAnswer = parseInt(event.target.dataset.index);
        }

        // Check quiz answer
        function checkQuizAnswer() {
            if (gameState.currentQuiz.userAnswer === null) {
                showMelodyMessage("Please select an answer first!");
                return;
            }
            
            // Get selected option
            const selectedOption = elements.quizOptions.querySelector('.selected');
            
            // Check if answer is correct
            if (gameState.currentQuiz.userAnswer === gameState.currentQuiz.correctAnswer) {
                // Correct answer
                playSuccessSound();
                
                // Add points
                addPoints(200);
                
                // Highlight correct answer
                selectedOption.classList.add('correct');
                
                // Show message
                showMelodyMessage("Correct! +200 points!");
            } else {
                // Incorrect answer
                playErrorSound();
                
                // Highlight correct and incorrect answers
                selectedOption.classList.add('incorrect');
                
                const correctOption = elements.quizOptions.querySelector(`[data-index="${gameState.currentQuiz.correctAnswer}"]`);
                if (correctOption) {
                    correctOption.classList.add('correct');
                }
                
                // Show message
                showMelodyMessage("Not quite! The correct answer is highlighted.");
            }
            
            // Proceed to next question or close quiz
            setTimeout(() => {
                if (gameState.quizCount < 5) {
                    generateQuizQuestion();
                } else {
                    // Quiz completed
                    closeQuiz();
                }
            }, 2000);
        }

        // Close quiz
        function closeQuiz() {
            // Hide quiz container
            elements.quizContainer.style.display = 'none';
            
            // Resume game
            gameState.isPaused = false;
            
            // Set next quiz threshold
            gameState.nextQuizAt = gameState.score + 2000;
            gameState.quizCompleted = false;
            
            // Reset quiz count
            gameState.quizCount = 0;
        }

        // Show melody message
        function showMelodyMessage(message) {
            // Clear any existing timers
            gameState.characterBubbleTimers.forEach(timer => clearTimeout(timer));
            
            // Position bubble near player
            const bubbleX = Math.max(150, Math.min(gameState.gameWidth - 150, gameState.playerPosition.x));
            const bubbleY = Math.max(100, gameState.playerPosition.y - 100);
            
            elements.melodyBubble.style.left = `${bubbleX}px`;
            elements.melodyBubble.style.top = `${bubbleY}px`;
            elements.melodyBubble.style.transform = 'translate(-50%, -100%)';
            
            // Set message
            elements.melodyBubble.textContent = message;
            
            // Show bubble
            elements.melodyBubble.style.opacity = '1';
            
            // Auto-hide after delay
            const timer = setTimeout(() => {
                elements.melodyBubble.style.opacity = '0';
            }, 3000);
            
            gameState.characterBubbleTimers.push(timer);
        }

        // Handle keyboard controls
        function handleKeyDown(e) {
            if (e.key === 'ArrowLeft') {
                gameState.leftPressed = true;
            } else if (e.key === 'ArrowRight') {
                gameState.rightPressed = true;
            } else if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        }

        function handleKeyUp(e) {
            if (e.key === 'ArrowLeft') {
                gameState.leftPressed = false;
            } else if (e.key === 'ArrowRight') {
                gameState.rightPressed = false;
            }
        }

        // Update music volume
        function updateMusicVolume() {
            const value = parseInt(elements.sliders.music.value);
            elements.values.music.textContent = value;
            
            gameState.musicVolume = value / 100;
            
            // Update background music volume
            if (backgroundMusicGain) {
                backgroundMusicGain.gain.value = gameState.musicVolume;
            }
            
            saveSettings();
        }

        // Update sound effects volume
        function updateSfxVolume() {
            const value = parseInt(elements.sliders.sfx.value);
            elements.values.sfx.textContent = value;
            
            gameState.sfxVolume = value / 100;
            
            saveSettings();
        }

        // Update game speed
        function updateSpeed() {
            const value = parseInt(elements.sliders.speed.value);
            elements.values.speed.textContent = value;
            
            gameState.speed = value;
            
            saveSettings();
        }

        // Update tile frequency
        function updateFrequency() {
            const value = parseInt(elements.sliders.frequency.value);
            elements.values.frequency.textContent = value;
            
            gameState.tileFrequency = value;
            
            saveSettings();
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                musicVolume: gameState.musicVolume,
                sfxVolume: gameState.sfxVolume,
                speed: gameState.speed,
                tileFrequency: gameState.tileFrequency,
                playerColor: gameState.playerColor
            };
            
            localStorage.setItem('melodyHopSettings', JSON.stringify(settings));
        }

        // Get tile speed
        function getTileSpeed() {
            // Base speed adjusted by game speed setting and level
            return 200 + (gameState.speed * 20) + ((gameState.level - 1) * 15);
        }

        // Get tile delay
        function getTileDelay() {
            // Base delay adjusted by tile frequency setting
            const baseDelay = 2000 - (gameState.tileFrequency * 150);
            
            // Adjust for level (tiles come more frequently in higher levels)
            return Math.max(500, baseDelay - ((gameState.level - 1) * 100));
        }

        // Handle window resize
        function handleResize() {
            gameState.gameWidth = window.innerWidth;
            gameState.gameHeight = window.innerHeight;
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
