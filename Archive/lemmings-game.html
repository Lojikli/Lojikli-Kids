<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lemmings Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            overflow: hidden;
            color: white;
            image-rendering: pixelated;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
        }
        
        canvas {
            display: block;
            border: 2px solid #4a4a4a;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        
        #abilities {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 10;
        }
        
        .ability-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #666;
            border-radius: 5px;
            background-color: #333;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            font-size: 10px;
        }
        
        .ability-btn.selected {
            border-color: #ffcc00;
            background-color: #444;
        }
        
        .ability-btn:hover {
            border-color: #999;
        }
        
        .ability-btn .count {
            font-size: 12px;
            font-weight: bold;
        }
        
        .ability-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        #start-screen, #level-complete, #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
        }
        
        #level-complete, #game-over {
            display: none;
        }
        
        h1 {
            color: #ffcc00;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #ffcc00;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        button:hover {
            background-color: #ffd633;
        }
        
        .level-btn {
            margin: 5px;
            padding: 10px 15px;
            background-color: #444;
            color: white;
        }
        
        .level-btn:hover {
            background-color: #555;
        }
        
        #speed-control {
            position: absolute;
            top: 50px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 11;
        }
        
        .speed-btn {
            padding: 5px;
            background-color: #333;
            border: 1px solid #666;
            color: white;
            cursor: pointer;
        }
        
        .speed-btn.active {
            background-color: #ffcc00;
            color: black;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div>Level: <span id="level-display">1</span></div>
            <div>Lemmings: <span id="lemmings-saved">0</span>/<span id="lemmings-target">0</span>/<span id="lemmings-total">0</span></div>
            <div>Time: <span id="time-display">0:00</span></div>
        </div>
        
        <div id="abilities">
            <div class="ability-btn" data-ability="digger">
                <div class="ability-icon">‚õèÔ∏è</div>
                <div>Digger</div>
                <div class="count" id="digger-count">10</div>
            </div>
            <div class="ability-btn" data-ability="blocker">
                <div class="ability-icon">üõë</div>
                <div>Blocker</div>
                <div class="count" id="blocker-count">5</div>
            </div>
            <div class="ability-btn" data-ability="builder">
                <div class="ability-icon">üß±</div>
                <div>Builder</div>
                <div class="count" id="builder-count">10</div>
            </div>
            <div class="ability-btn" data-ability="basher">
                <div class="ability-icon">üí™</div>
                <div>Basher</div>
                <div class="count" id="basher-count">5</div>
            </div>
            <div class="ability-btn" data-ability="climber">
                <div class="ability-icon">üßó</div>
                <div>Climber</div>
                <div class="count" id="climber-count">5</div>
            </div>
            <div class="ability-btn" data-ability="floater">
                <div class="ability-icon">ü™Ç</div>
                <div>Floater</div>
                <div class="count" id="floater-count">5</div>
            </div>
            <div class="ability-btn" data-ability="bomber">
                <div class="ability-icon">üí£</div>
                <div>Bomber</div>
                <div class="count" id="bomber-count">5</div>
            </div>
        </div>
        
        <div id="speed-control">
            <button class="speed-btn" data-speed="1">1x</button>
            <button class="speed-btn active" data-speed="2">2x</button>
            <button class="speed-btn" data-speed="3">3x</button>
        </div>
        
        <div id="start-screen">
            <h1>LEMMINGS</h1>
            <p>Guide your lemmings to the exit door. Assign them roles to overcome obstacles.</p>
            <p>Save enough lemmings to complete each level!</p>
            <div id="level-select">
                <h2>Select Level</h2>
                <div>
                    <button class="level-btn" data-level="1">Level 1</button>
                    <button class="level-btn" data-level="2">Level 2</button>
                    <button class="level-btn" data-level="3">Level 3</button>
                </div>
            </div>
            <button id="start-button">START GAME</button>
        </div>
        
        <div id="level-complete">
            <h1>LEVEL COMPLETE!</h1>
            <div id="level-stats">
                <p>Lemmings saved: <span id="saved-count">0</span>/<span id="required-count">0</span></p>
                <p>Time: <span id="completion-time">0:00</span></p>
            </div>
            <button id="next-level-button">NEXT LEVEL</button>
        </div>
        
        <div id="game-over">
            <h1>GAME OVER</h1>
            <p id="game-over-message">You didn't save enough lemmings!</p>
            <button id="retry-button">RETRY LEVEL</button>
            <button id="main-menu-button">MAIN MENU</button>
        </div>
    </div>

    <script>
        // Game variables
        let gameState = "start"; // start, playing, levelComplete, gameOver
        let currentLevel = 1;
        let gameSpeed = 2;
        let world;
        let lemmings = [];
        let tiles = [];
        let entrances = [];
        let exits = [];
        let selectedAbility = null;
        let spawnTimer = 0;
        let spawnInterval = 60; // frames between lemming spawns
        let levelTime = 0;
        let levelTimeLimit = 120; // seconds
        let totalLemmings = 20;
        let lemminsSaved = 0;
        let lemmingsRequired = 10;
        let lemmingsSpawned = 0;
        let abilities = {
            digger: 10,
            blocker: 5,
            builder: 10,
            basher: 5,
            climber: 5,
            floater: 5,
            bomber: 5
        };
        
        let originalAbilities = {...abilities};
        
        // Level definitions
        const levels = [
            // Level 1
            {
                tileSize: 20,
                gridWidth: 40,
                gridHeight: 30,
                backgroundColor: [100, 150, 255],
                lemmingsTotal: 20,
                lemmingsRequired: 10,
                timeLimit: 120,
                spawnInterval: 60,
                abilities: {
                    digger: 10,
                    blocker: 5,
                    builder: 10,
                    basher: 5,
                    climber: 5,
                    floater: 5,
                    bomber: 5
                },
                entrances: [
                    { x: 5, y: 5 }
                ],
                exits: [
                    { x: 35, y: 25, width: 3, height: 4 }
                ],
                tiles: [
                    // Ground platforms
                    { x: 0, y: 12, width: 10, height: 18, type: "ground" },
                    { x: 12, y: 15, width: 15, height: 15, type: "ground" },
                    { x: 30, y: 25, width: 10, height: 5, type: "ground" },
                    // Small obstacles
                    { x: 10, y: 11, width: 2, height: 1, type: "ground" },
                ]
            },
            // Level 2
            {
                tileSize: 20,
                gridWidth: 40,
                gridHeight: 30,
                backgroundColor: [80, 130, 200],
                lemmingsTotal: 25,
                lemmingsRequired: 15,
                timeLimit: 180,
                spawnInterval: 45,
                abilities: {
                    digger: 8,
                    blocker: 4,
                    builder: 12,
                    basher: 8,
                    climber: 6,
                    floater: 6,
                    bomber: 5
                },
                entrances: [
                    { x: 2, y: 5 }
                ],
                exits: [
                    { x: 35, y: 5, width: 3, height: 4 }
                ],
                tiles: [
                    // Starting platform
                    { x: 0, y: 10, width: 5, height: 20, type: "ground" },
                    // Middle sections
                    { x: 6, y: 15, width: 12, height: 15, type: "ground" },
                    { x: 20, y: 12, width: 8, height: 18, type: "ground" },
                    // End platform
                    { x: 32, y: 9, width: 8, height: 21, type: "ground" },
                    // Obstacles
                    { x: 6, y: 14, width: 2, height: 1, type: "ground" },
                    { x: 28, y: 11, width: 4, height: 1, type: "ground" },
                ]
            },
            // Level 3
            {
                tileSize: 20,
                gridWidth: 40,
                gridHeight: 30,
                backgroundColor: [60, 100, 180],
                lemmingsTotal: 30,
                lemmingsRequired: 20,
                timeLimit: 240,
                spawnInterval: 40,
                abilities: {
                    digger: 12,
                    blocker: 6,
                    builder: 15,
                    basher: 10,
                    climber: 8,
                    floater: 8,
                    bomber: 8
                },
                entrances: [
                    { x: 20, y: 2 }
                ],
                exits: [
                    { x: 5, y: 25, width: 3, height: 4 }
                ],
                tiles: [
                    // Top platform
                    { x: 15, y: 5, width: 10, height: 2, type: "ground" },
                    // Middle structures
                    { x: 5, y: 10, width: 10, height: 2, type: "ground" },
                    { x: 25, y: 12, width: 10, height: 2, type: "ground" },
                    { x: 10, y: 18, width: 20, height: 2, type: "ground" },
                    // Bottom platform
                    { x: 0, y: 25, width: 15, height: 5, type: "ground" },
                    { x: 25, y: 22, width: 15, height: 8, type: "ground" },
                    // Obstacles
                    { x: 15, y: 17, width: 1, height: 1, type: "ground" },
                    { x: 25, y: 17, width: 1, height: 1, type: "ground" },
                ]
            }
        ];
        
        // P5.js functions
        function setup() {
            const canvas = createCanvas(800, 600);
            canvas.parent('game-container');
            frameRate(60);
            textAlign(CENTER, CENTER);
            
            initEventListeners();
            loadLevel(currentLevel);
        }
        
        function draw() {
            // Create a gradient background
            for (let y = 0; y < height; y += 4) {
                const gradientColor = lerpColor(
                    color(world.backgroundColor[0], world.backgroundColor[1], world.backgroundColor[2]),
                    color(world.backgroundColor[0] * 0.7, world.backgroundColor[1] * 0.7, world.backgroundColor[2] * 0.7),
                    y / height
                );
                stroke(gradientColor);
                line(0, y, width, y);
            }
            
            if (gameState === "playing") {
                updateGame();
                drawWorld();
                drawLemmings();
                drawParticles(); // Draw all particle effects
                updateHUD();
            }
        }
        
        // Game initialization functions
        function initEventListeners() {
            // Ability selection
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const ability = btn.getAttribute('data-ability');
                    if (abilities[ability] > 0) {
                        document.querySelectorAll('.ability-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        selectedAbility = ability;
                    }
                });
            });
            
            // Speed control
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameSpeed = parseInt(btn.getAttribute('data-speed'));
                });
            });
            
            // Level selection
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const level = parseInt(btn.getAttribute('data-level'));
                    currentLevel = level;
                    document.getElementById('level-display').textContent = level;
                });
            });
            
            // Start button
            document.getElementById('start-button').addEventListener('click', () => {
                gameState = "playing";
                document.getElementById('start-screen').style.display = 'none';
                loadLevel(currentLevel);
            });
            
            // Next level button
            document.getElementById('next-level-button').addEventListener('click', () => {
                gameState = "playing";
                document.getElementById('level-complete').style.display = 'none';
                currentLevel++;
                if (currentLevel > levels.length) {
                    currentLevel = 1;
                }
                loadLevel(currentLevel);
            });
            
            // Retry button
            document.getElementById('retry-button').addEventListener('click', () => {
                gameState = "playing";
                document.getElementById('game-over').style.display = 'none';
                loadLevel(currentLevel);
            });
            
            // Main menu button
            document.getElementById('main-menu-button').addEventListener('click', () => {
                gameState = "start";
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
            });
        }
        
        function loadLevel(levelIndex) {
            const levelData = levels[levelIndex - 1];
            
            // Reset game variables
            lemmings = [];
            tiles = [];
            entrances = [];
            exits = [];
            lemmingsSpawned = 0;
            lemminsSaved = 0;
            levelTime = 0;
            spawnTimer = 0;
            
            // Set level parameters
            world = {
                tileSize: levelData.tileSize,
                gridWidth: levelData.gridWidth,
                gridHeight: levelData.gridHeight,
                width: levelData.gridWidth * levelData.tileSize,
                height: levelData.gridHeight * levelData.tileSize,
                backgroundColor: levelData.backgroundColor
            };
            
            totalLemmings = levelData.lemmingsTotal;
            lemmingsRequired = levelData.lemmingsRequired;
            levelTimeLimit = levelData.timeLimit;
            spawnInterval = levelData.spawnInterval;
            
            // Copy abilities
            abilities = {...levelData.abilities};
            originalAbilities = {...abilities};
            
            // Update ability counts in UI
            for (const ability in abilities) {
                document.getElementById(`${ability}-count`).textContent = abilities[ability];
            }
            
            // Create level tiles
            levelData.tiles.forEach(tileData => {
                for (let y = 0; y < tileData.height; y++) {
                    for (let x = 0; x < tileData.width; x++) {
                        tiles.push({
                            x: (tileData.x + x) * world.tileSize,
                            y: (tileData.y + y) * world.tileSize,
                            width: world.tileSize,
                            height: world.tileSize,
                            type: tileData.type
                        });
                    }
                }
            });
            
            // Create entrances and exits
            levelData.entrances.forEach(entranceData => {
                entrances.push({
                    x: entranceData.x * world.tileSize,
                    y: entranceData.y * world.tileSize,
                    width: world.tileSize,
                    height: world.tileSize * 2
                });
            });
            
            levelData.exits.forEach(exitData => {
                exits.push({
                    x: exitData.x * world.tileSize,
                    y: exitData.y * world.tileSize,
                    width: exitData.width * world.tileSize,
                    height: exitData.height * world.tileSize
                });
            });
            
            // Update HUD
            document.getElementById('level-display').textContent = currentLevel;
            document.getElementById('lemmings-total').textContent = totalLemmings;
            document.getElementById('lemmings-target').textContent = lemmingsRequired;
            document.getElementById('lemmings-saved').textContent = lemminsSaved;
            
            // Reset ability selection
            selectedAbility = null;
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
        
        // Game update functions
        function updateGame() {
            // Update level time
            if (frameCount % 60 === 0) {
                levelTime++;
                if (levelTime >= levelTimeLimit) {
                    checkLevelCompletion();
                }
            }
            
            // Spawn new lemmings
            spawnTimer++;
            if (lemmingsSpawned < totalLemmings && spawnTimer >= spawnInterval / gameSpeed) {
                spawnLemming();
                spawnTimer = 0;
            }
            
            // Update lemmings
            for (let i = lemmings.length - 1; i >= 0; i--) {
                for (let j = 0; j < gameSpeed; j++) {
                    updateLemming(lemmings[i]);
                    
                    // Check if lemming reached exit
                    if (lemmings[i].reachedExit) {
                        // Add exit sparkle effect
                        for (let k = 0; k < 10; k++) {
                            sparkleParticles.push({
                                x: lemmings[i].x + lemmings[i].width/2,
                                y: lemmings[i].y + lemmings[i].height/2,
                                vx: random(-1, 1),
                                vy: random(-3, -1),
                                size: random(2, 4),
                                color: color(255, 255, random(100, 255)),
                                life: random(15, 30)
                            });
                        }
                        
                        lemminsSaved++;
                        lemmings.splice(i, 1);
                        break;
                    }
                    
                    // Check if lemming died
                    if (lemmings[i].isDead) {
                        // Add small poof of smoke for death
                        for (let k = 0; k < 8; k++) {
                            smokeParticles.push({
                                x: lemmings[i].x + lemmings[i].width/2,
                                y: lemmings[i].y + lemmings[i].height/2,
                                vx: random(-0.5, 0.5),
                                vy: random(-1, -0.2),
                                size: random(3, 8),
                                color: color(200, 200, 200),
                                life: random(20, 40)
                            });
                        }
                        
                        lemmings.splice(i, 1);
                        break;
                    }
                }
            }
            
            // Update all particle systems
            updateParticles();
            
            // Check for level completion
            if (lemmingsSpawned >= totalLemmings && lemmings.length === 0) {
                checkLevelCompletion();
            }
        }
        
        function spawnLemming() {
            if (entrances.length === 0) return;
            
            const entrance = entrances[0];
            lemmings.push({
                x: entrance.x + entrance.width / 2,
                y: entrance.y + entrance.height,
                width: world.tileSize * 0.7,
                height: world.tileSize * 0.9,
                direction: 1, // 1 = right, -1 = left
                isWalking: true,
                isFalling: true,
                isDigging: false,
                isBlocking: false,
                isBuilding: false,
                isBashing: false,
                isClimbing: false,
                isFloating: false,
                isBombing: false,
                hasClimberAbility: false,
                hasFloaterAbility: false,
                buildCounter: 0,
                buildLimit: 12,
                bombTimer: 0,
                bombLimit: 3 * 60, // 3 seconds in frames
                reachedExit: false,
                isDead: false,
                color: color(random(100, 200), random(100, 200), random(100, 200))
            });
            
            lemmingsSpawned++;
        }
        
        function updateLemming(lemming) {
            // Bomb countdown
            if (lemming.isBombing) {
                lemming.bombTimer++;
                if (lemming.bombTimer >= lemming.bombLimit) {
                    // Create explosion
                    explode(lemming);
                    lemming.isDead = true;
                    return;
                }
            }
            
            // Check if lemming reached the exit
            exits.forEach(exit => {
                if (
                    lemming.x >= exit.x && 
                    lemming.x <= exit.x + exit.width && 
                    lemming.y >= exit.y && 
                    lemming.y <= exit.y + exit.height
                ) {
                    lemming.reachedExit = true;
                }
            });
            
            // Check if lemming fell off the world
            if (lemming.y > world.height) {
                lemming.isDead = true;
                return;
            }
            
            // Handle falling
            lemming.isFalling = true;
            
            // Check collision with tiles below
            tiles.forEach(tile => {
                // If lemming is directly above the tile
                if (
                    lemming.x + lemming.width/2 > tile.x && 
                    lemming.x + lemming.width/2 < tile.x + tile.width && 
                    lemming.y + lemming.height <= tile.y && 
                    lemming.y + lemming.height + 5 >= tile.y
                ) {
                    lemming.isFalling = false;
                    lemming.y = tile.y - lemming.height;
                }
            });
            
            // Handle blocking
            if (lemming.isBlocking) {
                return; // Blockers don't move
            }
            
            // Handle falling
            if (lemming.isFalling) {
                if (lemming.isFloating) {
                    lemming.y += 1; // Float slowly
                } else if (lemming.isClimbing && isNextToWall(lemming)) {
                    // Climb up the wall
                    lemming.y -= 1;
                } else {
                    lemming.y += 4; // Fall normally
                }
                return;
            }
            
            // Handle digging
            if (lemming.isDigging) {
                const tileIndex = getTileIndexBelow(lemming);
                if (tileIndex !== -1) {
                    tiles.splice(tileIndex, 1);
                } else {
                    lemming.isDigging = false;
                }
                return;
            }
            
            // Handle building - Create proper diagonal staircases like the original game
            if (lemming.isBuilding) {
                if (lemming.buildCounter < lemming.buildLimit) {
                    // Add a new stair piece in the building direction
                    const newTile = {
                        x: lemming.x + (lemming.direction * lemming.buildCounter * 3),
                        y: lemming.y + lemming.height - (lemming.buildCounter + 1) * 2,
                        width: world.tileSize * 0.6,
                        height: world.tileSize * 0.2,
                        type: "bridge"
                    };
                    
                    tiles.push(newTile);
                    
                    // Every 3rd brick, make a sound (in the original game)
                    if (lemming.buildCounter % 3 === 0) {
                        // We would play a sound here if we had external files
                    }
                    
                    // Move lemming up and forward to follow the stair pattern
                    lemming.x += lemming.direction * 3;
                    lemming.y -= 2;
                    
                    lemming.buildCounter++;
                } else {
                    lemming.isBuilding = false;
                    lemming.buildCounter = 0;
                }
                return;
            }
            
            // Handle bashing
            if (lemming.isBashing) {
                // Check if there's a wall to bash through
                const wallIndex = getWallInFront(lemming);
                if (wallIndex !== -1) {
                    // Remove the wall tile
                    tiles.splice(wallIndex, 1);
                    // Move forward slowly
                    lemming.x += lemming.direction * 1;
                } else {
                    lemming.isBashing = false;
                }
                return;
            }
            
            // Handle walking
            if (lemming.isWalking) {
                // Move in current direction
                lemming.x += lemming.direction * 2;
                
                // Check for walls
                if (isWallInFront(lemming)) {
                    if (lemming.hasClimberAbility) {
                        lemming.isClimbing = true;
                    } else {
                        lemming.direction *= -1; // Turn around
                    }
                }
                
                // Check for edges
                if (!isTileInFront(lemming)) {
                    lemming.isWalking = false;
                    lemming.isFalling = true;
                }
            }
        }
        
        function explode(lemming) {
            // Create explosion effect
            const explosionRadius = world.tileSize * 2;
            const lemmingCenter = {
                x: lemming.x + lemming.width / 2,
                y: lemming.y + lemming.height / 2
            };
            
            // Create explosion particles
            for (let i = 0; i < 20; i++) {
                const angle = random(0, TWO_PI);
                const distance = random(0, explosionRadius);
                const speed = random(1, 5);
                
                explosionParticles.push({
                    x: lemmingCenter.x,
                    y: lemmingCenter.y,
                    vx: cos(angle) * speed,
                    vy: sin(angle) * speed,
                    radius: random(2, 5),
                    color: color(255, random(100, 255), 0, 255),
                    life: random(20, 40)
                });
            }
            
            // Remove tiles in explosion radius
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                const tileCenter = {
                    x: tile.x + tile.width / 2,
                    y: tile.y + tile.height / 2
                };
                
                const distance = dist(lemmingCenter.x, lemmingCenter.y, tileCenter.x, tileCenter.y);
                
                if (distance < explosionRadius) {
                    // Create debris particles for destroyed tiles
                    for (let j = 0; j < 3; j++) {
                        const debrisAngle = random(0, TWO_PI);
                        debrisParticles.push({
                            x: tileCenter.x,
                            y: tileCenter.y,
                            vx: cos(debrisAngle) * random(1, 3),
                            vy: sin(debrisAngle) * random(1, 3) - 2, // Initial upward velocity
                            size: random(2, 6),
                            color: tile.type === "ground" ? color(100, 70, 40) : color(180, 140, 100),
                            gravity: 0.2,
                            life: random(30, 60)
                        });
                    }
                    
                    tiles.splice(i, 1);
                }
            }
        }
        
        // Particle systems for various effects
        let explosionParticles = [];
        let debrisParticles = [];
        let sparkleParticles = [];
        let smokeParticles = [];
        
        function updateParticles() {
            // Update explosion particles
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                if (particle.life <= 0) {
                    explosionParticles.splice(i, 1);
                }
            }
            
            // Update debris particles
            for (let i = debrisParticles.length - 1; i >= 0; i--) {
                const debris = debrisParticles[i];
                
                debris.x += debris.vx;
                debris.y += debris.vy;
                debris.vy += debris.gravity; // Apply gravity
                debris.life--;
                
                if (debris.life <= 0) {
                    debrisParticles.splice(i, 1);
                }
            }
            
            // Update sparkle particles (for saved lemmings)
            for (let i = sparkleParticles.length - 1; i >= 0; i--) {
                const sparkle = sparkleParticles[i];
                
                sparkle.x += sparkle.vx;
                sparkle.y += sparkle.vy;
                sparkle.life--;
                
                if (sparkle.life <= 0) {
                    sparkleParticles.splice(i, 1);
                }
            }
            
            // Update smoke particles (for dying lemmings)
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const smoke = smokeParticles[i];
                
                smoke.x += smoke.vx;
                smoke.y += smoke.vy;
                smoke.size += 0.1; // Expand smoke
                smoke.life--;
                
                if (smoke.life <= 0) {
                    smokeParticles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            // Draw explosion particles
            noStroke();
            explosionParticles.forEach(particle => {
                const alpha = map(particle.life, 0, 40, 0, 255);
                fill(red(particle.color), green(particle.color), blue(particle.color), alpha);
                ellipse(particle.x, particle.y, particle.radius * 2);
            });
            
            // Draw debris particles
            debrisParticles.forEach(debris => {
                const alpha = map(debris.life, 0, 60, 0, 255);
                fill(red(debris.color), green(debris.color), blue(debris.color), alpha);
                rect(debris.x, debris.y, debris.size, debris.size);
            });
            
            // Draw sparkle particles
            sparkleParticles.forEach(sparkle => {
                const alpha = map(sparkle.life, 0, 30, 0, 255);
                fill(red(sparkle.color), green(sparkle.color), blue(sparkle.color), alpha);
                
                // Star shape for sparkles
                push();
                translate(sparkle.x, sparkle.y);
                rotate(frameCount * 0.05);
                
                beginShape();
                for (let i = 0; i < 5; i++) {
                    const angle = TWO_PI / 5 * i;
                    const x1 = cos(angle) * sparkle.size;
                    const y1 = sin(angle) * sparkle.size;
                    vertex(x1, y1);
                    
                    const angleHalf = TWO_PI / 5 * (i + 0.5);
                    const x2 = cos(angleHalf) * (sparkle.size / 2);
                    const y2 = sin(angleHalf) * (sparkle.size / 2);
                    vertex(x2, y2);
                }
                endShape(CLOSE);
                pop();
            });
            
            // Draw smoke particles
            smokeParticles.forEach(smoke => {
                const alpha = map(smoke.life, 0, 40, 0, 150);
                fill(red(smoke.color), green(smoke.color), blue(smoke.color), alpha);
                ellipse(smoke.x, smoke.y, smoke.size);
            });
        }
        
        // Mouse interaction
        function mousePressed() {
            if (gameState !== "playing" || !selectedAbility) return;
            
            // Find the clicked lemming
            for (let i = 0; i < lemmings.length; i++) {
                const lemming = lemmings[i];
                if (
                    mouseX >= lemming.x && 
                    mouseX <= lemming.x + lemming.width && 
                    mouseY >= lemming.y && 
                    mouseY <= lemming.y + lemming.height
                ) {
                    // Apply selected ability
                    applyAbility(lemming, selectedAbility);
                    break;
                }
            }
        }
        
        function applyAbility(lemming, ability) {
            if (abilities[ability] <= 0) return;
            
            // Prevent applying abilities to blockers (except bomber)
            if (lemming.isBlocking && ability !== "bomber") return;
            
            // Prevent applying abilities to bombers
            if (lemming.isBombing) return;
            
            switch (ability) {
                case "digger":
                    if (!lemming.isFalling && !lemming.isDigging) {
                        lemming.isDigging = true;
                        lemming.isWalking = false;
                        lemming.isBuilding = false;
                        lemming.isBashing = false;
                        lemming.isClimbing = false;
                        abilities.digger--;
                    }
                    break;
                    
                case "blocker":
                    if (!lemming.isFalling && !lemming.isBlocking) {
                        lemming.isBlocking = true;
                        lemming.isWalking = false;
                        lemming.isDigging = false;
                        lemming.isBuilding = false;
                        lemming.isBashing = false;
                        lemming.isClimbing = false;
                        abilities.blocker--;
                    }
                    break;
                    
                case "builder":
                    if (!lemming.isFalling && !lemming.isBuilding) {
                        lemming.isBuilding = true;
                        lemming.isWalking = false;
                        lemming.isDigging = false;
                        lemming.isBashing = false;
                        lemming.isClimbing = false;
                        abilities.builder--;
                    }
                    break;
                    
                case "basher":
                    if (!lemming.isFalling && isWallInFront(lemming)) {
                        lemming.isBashing = true;
                        lemming.isWalking = false;
                        lemming.isDigging = false;
                        lemming.isBuilding = false;
                        lemming.isClimbing = false;
                        abilities.basher--;
                    }
                    break;
                    
                case "climber":
                    if (!lemming.hasClimberAbility) {
                        lemming.hasClimberAbility = true;
                        abilities.climber--;
                    }
                    break;
                    
                case "floater":
                    if (!lemming.hasFloaterAbility) {
                        lemming.hasFloaterAbility = true;
                        lemming.isFloating = lemming.isFalling;
                        abilities.floater--;
                    }
                    break;
                    
                case "bomber":
                    if (!lemming.isBombing) {
                        lemming.isBombing = true;
                        lemming.bombTimer = 0;
                        abilities.bomber--;
                    }
                    break;
            }
            
            // Update ability count in UI
            document.getElementById(`${ability}-count`).textContent = abilities[ability];
        }
        
        // Helper functions
        function isWallInFront(lemming) {
            const checkX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const checkY = lemming.y + lemming.height / 2;
            
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                if (
                    (lemming.direction > 0 && checkX <= tile.x && checkX + 2 >= tile.x) ||
                    (lemming.direction < 0 && checkX >= tile.x + tile.width && checkX - 2 <= tile.x + tile.width)
                ) {
                    if (checkY >= tile.y && checkY <= tile.y + tile.height) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function isNextToWall(lemming) {
            // Check left wall
            const leftX = lemming.x - 2;
            // Check right wall
            const rightX = lemming.x + lemming.width + 2;
            const checkY = lemming.y + lemming.height / 2;
            
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                // Check for left wall
                if (leftX <= tile.x + tile.width && leftX >= tile.x) {
                    if (checkY >= tile.y && checkY <= tile.y + tile.height) {
                        lemming.direction = 1; // Make lemming go right
                        return true;
                    }
                }
                // Check for right wall
                if (rightX >= tile.x && rightX <= tile.x + tile.width) {
                    if (checkY >= tile.y && checkY <= tile.y + tile.height) {
                        lemming.direction = -1; // Make lemming go left
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function getWallInFront(lemming) {
            const checkX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const checkY = lemming.y + lemming.height / 2;
            
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                if (
                    (lemming.direction > 0 && checkX <= tile.x && checkX + 5 >= tile.x) ||
                    (lemming.direction < 0 && checkX >= tile.x + tile.width && checkX - 5 <= tile.x + tile.width)
                ) {
                    if (checkY >= tile.y && checkY <= tile.y + tile.height) {
                        return i;
                    }
                }
            }
            
            return -1;
        }
        
        function isTileInFront(lemming) {
            const checkX = lemming.x + (lemming.direction > 0 ? lemming.width : 0);
            const footY = lemming.y + lemming.height;
            
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                if (
                    checkX >= tile.x && 
                    checkX <= tile.x + tile.width && 
                    footY >= tile.y - 5 && 
                    footY <= tile.y + 5
                ) {
                    return true;
                }
            }
            
            return false;
        }
        
        function getTileIndexBelow(lemming) {
            const centerX = lemming.x + lemming.width / 2;
            const footY = lemming.y + lemming.height;
            
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                if (
                    centerX >= tile.x && 
                    centerX <= tile.x + tile.width && 
                    footY >= tile.y - 2 && 
                    footY <= tile.y + 2
                ) {
                    return i;
                }
            }
            
            return -1;
        }
        
        function checkLevelCompletion() {
            if (lemminsSaved >= lemmingsRequired) {
                // Level completed
                gameState = "levelComplete";
                
                // Update level complete screen
                document.getElementById('saved-count').textContent = lemminsSaved;
                document.getElementById('required-count').textContent = lemmingsRequired;
                document.getElementById('completion-time').textContent = formatTime(levelTime);
                
                document.getElementById('level-complete').style.display = 'flex';
            } else {
                // Game over
                gameState = "gameOver";
                
                // Update game over screen
                document.getElementById('game-over-message').textContent = 
                    `You saved ${lemminsSaved} out of ${totalLemmings} lemmings, but needed ${lemmingsRequired}!`;
                
                document.getElementById('game-over').style.display = 'flex';
            }
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Drawing functions
        function drawWorld() {
            // Draw background details
            // Mountains in the far background
            for (let i = 0; i < 3; i++) {
                fill(70, 90, 120, 100);
                noStroke();
                beginShape();
                vertex(i * 300, 200);
                vertex(i * 300 + 100, 120);
                vertex(i * 300 + 180, 160);
                vertex(i * 300 + 250, 90);
                vertex(i * 300 + 300, 200);
                endShape(CLOSE);
            }
            
            // Draw tiles
            tiles.forEach(tile => {
                if (tile.type === "ground") {
                    // Draw ground with a more polished look
                    fill(100, 70, 40); // Darker brown for base
                    noStroke();
                    rect(tile.x, tile.y, tile.width, tile.height);
                    
                    // Top edge highlight
                    fill(120, 85, 50);
                    rect(tile.x, tile.y, tile.width, 4);
                    
                    // Grid pattern overlay
                    stroke(80, 50, 30, 100);
                    strokeWeight(0.5);
                    
                    // Horizontal grid lines
                    for (let y = tile.y + 5; y < tile.y + tile.height; y += 5) {
                        line(tile.x, y, tile.x + tile.width, y);
                    }
                    
                    // Vertical grid lines
                    for (let x = tile.x + 5; x < tile.x + tile.width; x += 5) {
                        line(x, tile.y, x, tile.y + tile.height);
                    }
                    
                    // Random small details for texture
                    fill(80, 55, 30, 150);
                    noStroke();
                    
                    // Use a predictable "random" pattern based on position
                    for (let i = 0; i < 8; i++) {
                        const xPos = tile.x + ((tile.x * i) % tile.width);
                        const yPos = tile.y + ((tile.y * (i+3)) % tile.height);
                        const size = ((i + 1) % 3) + 2;
                        
                        rect(xPos, yPos, size, size);
                    }
                } else if (tile.type === "bridge") {
                    // Draw bridge pieces more like the original game's stairs
                    fill(180, 140, 100); // Brick color
                    stroke(140, 100, 60);
                    strokeWeight(1);
                    rect(tile.x, tile.y, tile.width, tile.height);
                    
                    // Brick details
                    strokeWeight(0.5);
                    line(tile.x + tile.width/2, tile.y, tile.x + tile.width/2, tile.y + tile.height);
                    line(tile.x, tile.y + tile.height/2, tile.x + tile.width, tile.y + tile.height/2);
                    
                    // Highlight
                    stroke(200, 170, 130, 150);
                    line(tile.x, tile.y, tile.x + tile.width, tile.y);
                }
            });
            
            // Draw entrances - more like the original game
            entrances.forEach(entrance => {
                // Metal frame
                fill(150, 150, 180);
                stroke(100, 100, 130);
                strokeWeight(2);
                rect(entrance.x, entrance.y, entrance.width, entrance.height, 4);
                
                // Hatch door
                fill(80, 80, 100);
                rect(
                    entrance.x + entrance.width * 0.2, 
                    entrance.y + entrance.height * 0.3, 
                    entrance.width * 0.6, 
                    entrance.height * 0.6,
                    4
                );
                
                // Door handle
                fill(200, 200, 220);
                noStroke();
                ellipse(
                    entrance.x + entrance.width * 0.7,
                    entrance.y + entrance.height * 0.6,
                    5, 5
                );
                
                // Rivets on frame
                for (let i = 0; i < 4; i++) {
                    ellipse(
                        entrance.x + entrance.width * 0.15 + (i * entrance.width * 0.23),
                        entrance.y + entrance.height * 0.15,
                        3, 3
                    );
                    ellipse(
                        entrance.x + entrance.width * 0.15 + (i * entrance.width * 0.23),
                        entrance.y + entrance.height * 0.85,
                        3, 3
                    );
                }
            });
            
            // Draw exits - more like the original game
            exits.forEach(exit => {
                // Exit structure
                fill(80, 150, 80);
                stroke(40, 100, 40);
                strokeWeight(2);
                rect(exit.x, exit.y, exit.width, exit.height, 8);
                
                // Doorway
                fill(30, 60, 30);
                strokeWeight(1);
                rect(
                    exit.x + exit.width * 0.2, 
                    exit.y + exit.height * 0.3, 
                    exit.width * 0.6, 
                    exit.height * 0.7,
                    [0, 0, 8, 8]
                );
                
                // EXIT sign
                fill(200, 255, 200);
                stroke(30, 80, 30);
                rect(
                    exit.x + exit.width * 0.2,
                    exit.y + exit.height * 0.1,
                    exit.width * 0.6,
                    exit.height * 0.15,
                    4
                );
                
                fill(30, 80, 30);
                noStroke();
                textSize(min(exit.width * 0.2, 16));
                textAlign(CENTER, CENTER);
                text("EXIT", exit.x + exit.width * 0.5, exit.y + exit.height * 0.17);
                
                // Door highlight/trim
                noFill();
                stroke(120, 220, 120);
                strokeWeight(1);
                rect(
                    exit.x + exit.width * 0.25, 
                    exit.y + exit.height * 0.35, 
                    exit.width * 0.5, 
                    exit.height * 0.6,
                    [0, 0, 6, 6]
                );
                
                // Doorstep
                fill(60, 120, 60);
                noStroke();
                rect(
                    exit.x + exit.width * 0.2,
                    exit.y + exit.height * 0.95,
                    exit.width * 0.6,
                    exit.height * 0.05
                );
            });
        }
        
        function drawLemmings() {
            lemmings.forEach(lemming => {
                push();
                
                // Animation frame based on time for walking animation
                const walkFrame = Math.floor(frameCount / 8) % 2;
                
                // Hair color (blue like original game)
                const hairColor = color(0, 100, 200);
                // Body color (green like original game)
                const bodyColor = color(0, 200, 100);
                
                // First, decide if we're flipped based on direction
                const flip = lemming.direction < 0;
                
                if (flip) {
                    scale(-1, 1);
                    translate(-lemming.x * 2 - lemming.width, 0);
                }
                
                // Draw shadow beneath lemming for depth
                fill(0, 0, 0, 40);
                noStroke();
                ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height + 2, lemming.width * 0.8, 4);
                
                if (lemming.isBlocking) {
                    // Blocker stance (arms out) - more like original game
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    
                    // Body
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.3, lemming.width * 0.7, lemming.height * 0.65, 2);
                    
                    // Arms out to sides
                    line(lemming.x, lemming.y + lemming.height * 0.4, lemming.x + lemming.width, lemming.y + lemming.height * 0.4);
                    
                    // Legs
                    stroke(0);
                    line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.3, lemming.y + lemming.height);
                    line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.7, lemming.y + lemming.height);
                    
                    // "X" mark on chest - classic blocker look
                    stroke(255, 0, 0);
                    strokeWeight(1.5);
                    line(lemming.x + lemming.width * 0.25, lemming.y + lemming.height * 0.4, lemming.x + lemming.width * 0.75, lemming.y + lemming.height * 0.7);
                    line(lemming.x + lemming.width * 0.75, lemming.y + lemming.height * 0.4, lemming.x + lemming.width * 0.25, lemming.y + lemming.height * 0.7);
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    strokeWeight(1);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                } else if (lemming.isDigging) {
                    // Digging animation - more detailed
                    
                    // Body - lower position for digging
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.4, lemming.width * 0.7, lemming.height * 0.5, 2);
                    
                    // Digging arm animation (alternating)
                    if (frameCount % 10 < 5) {
                        line(lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.5, 
                             lemming.x + lemming.width * 0.2, lemming.y + lemming.height * 0.9);
                    } else {
                        line(lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.5, 
                             lemming.x + lemming.width * 0.8, lemming.y + lemming.height * 0.9);
                    }
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    strokeWeight(1);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                    
                    // Shovel
                    stroke(150, 100, 50);
                    strokeWeight(2);
                    if (frameCount % 10 < 5) {
                        line(lemming.x + lemming.width * 0.2, lemming.y + lemming.height * 0.9,
                             lemming.x + lemming.width * 0.1, lemming.y + lemming.height * 1.1);
                    } else {
                        line(lemming.x + lemming.width * 0.8, lemming.y + lemming.height * 0.9,
                             lemming.x + lemming.width * 0.9, lemming.y + lemming.height * 1.1);
                    }
                } else if (lemming.isBuilding) {
                    // Building animation - with brick
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    
                    // Body
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.3, lemming.width * 0.7, lemming.height * 0.65, 2);
                    
                    // Arms with brick
                    if (frameCount % 12 < 6) {
                        // Holding brick up
                        fill(180, 100, 80); // Brick color
                        rect(lemming.x + lemming.width * 0.75, lemming.y + lemming.height * 0.3, 
                             lemming.width * 0.4, lemming.height * 0.15);
                        
                        // Arm
                        stroke(0);
                        line(lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.4,
                             lemming.x + lemming.width * 0.8, lemming.y + lemming.height * 0.35);
                    } else {
                        // Placing brick down
                        fill(180, 100, 80); // Brick color
                        rect(lemming.x + lemming.width * 0.75, lemming.y + lemming.height * 0.6, 
                             lemming.width * 0.4, lemming.height * 0.15);
                        
                        // Arm
                        stroke(0);
                        line(lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.4,
                             lemming.x + lemming.width * 0.8, lemming.y + lemming.height * 0.6);
                    }
                    
                    // Legs
                    stroke(0);
                    line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.3, lemming.y + lemming.height);
                    line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.7, lemming.y + lemming.height);
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    strokeWeight(1);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                } else if (lemming.isBashing) {
                    // Bashing animation - punching through walls
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    
                    // Body - slightly hunched forward
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.3, lemming.width * 0.7, lemming.height * 0.65, 2);
                    
                    // Bashing arm animation
                    if (frameCount % 8 < 4) {
                        // Arm pulled back
                        line(lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.4,
                             lemming.x + lemming.width * 0.2, lemming.y + lemming.height * 0.3);
                    } else {
                        // Arm extended forward
                        strokeWeight(2);
                        line(lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.4,
                             lemming.x + lemming.width * 1.1, lemming.y + lemming.height * 0.3);
                    }
                    
                    // Legs
                    strokeWeight(1);
                    line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.3, lemming.y + lemming.height);
                    line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.7, lemming.y + lemming.height);
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                } else if (lemming.isClimbing) {
                    // Climbing animation
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    
                    // Climbing body - vertical orientation
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.3, lemming.width * 0.7, lemming.height * 0.6, 2);
                    
                    // Climbing arms and legs - alternating pattern
                    if (frameCount % 12 < 6) {
                        // Left arm up, right arm down
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.1, lemming.y + lemming.height * 0.2);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.9, lemming.y + lemming.height * 0.6);
                             
                        // Left leg up, right leg down
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.9, 
                             lemming.x + lemming.width * 0.1, lemming.y + lemming.height * 0.7);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.9, 
                             lemming.x + lemming.width * 0.9, lemming.y + lemming.height * 1.1);
                    } else {
                        // Right arm up, left arm down
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.1, lemming.y + lemming.height * 0.6);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.9, lemming.y + lemming.height * 0.2);
                             
                        // Right leg up, left leg down
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.9, 
                             lemming.x + lemming.width * 0.1, lemming.y + lemming.height * 1.1);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.9, 
                             lemming.x + lemming.width * 0.9, lemming.y + lemming.height * 0.7);
                    }
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                } else if (lemming.isFloating) {
                    // Floating animation with umbrella
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    
                    // Body
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.3, lemming.width * 0.7, lemming.height * 0.65, 2);
                    
                    // Arms up holding umbrella
                    line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.4, 
                         lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.1);
                    line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.4, 
                         lemming.x + lemming.width * 0.5, lemming.y + lemming.height * 0.1);
                    
                    // Legs slightly spread
                    line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.2, lemming.y + lemming.height);
                    line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.95, lemming.x + lemming.width * 0.8, lemming.y + lemming.height);
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                    
                    // Umbrella
                    fill(255, 50, 50, 220); // Red umbrella like original
                    stroke(100);
                    strokeWeight(1);
                    arc(lemming.x + lemming.width/2, lemming.y, lemming.width * 1.8, lemming.width * 1.2, PI, TWO_PI);
                    
                    // Umbrella handle
                    stroke(80);
                    strokeWeight(1.5);
                    line(lemming.x + lemming.width/2, lemming.y, lemming.x + lemming.width/2, lemming.y + lemming.height * 0.1);
                    
                    // Umbrella ribs
                    strokeWeight(0.5);
                    for (let i = 0; i < 4; i++) {
                        const angle = PI + (i * PI/3);
                        line(lemming.x + lemming.width/2, lemming.y,
                             lemming.x + lemming.width/2 + cos(angle) * lemming.width * 0.9,
                             lemming.y + sin(angle) * lemming.width * 0.6);
                    }
                } else {
                    // Walking lemming - more detailed
                    fill(bodyColor);
                    stroke(0);
                    strokeWeight(1);
                    
                    // Body
                    rect(lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.3, lemming.width * 0.7, lemming.height * 0.65, 2);
                    
                    // Walking legs animation
                    if (walkFrame === 0) {
                        // Left leg forward, right leg back
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.95, 
                             lemming.x + lemming.width * 0.5, lemming.y + lemming.height);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.95, 
                             lemming.x + lemming.width * 0.6, lemming.y + lemming.height);
                    } else {
                        // Right leg forward, left leg back
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.95, 
                             lemming.x + lemming.width * 0.4, lemming.y + lemming.height);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.95, 
                             lemming.x + lemming.width * 0.9, lemming.y + lemming.height);
                    }
                    
                    // Arms swinging slightly with walk
                    if (walkFrame === 0) {
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.6);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.85, lemming.y + lemming.height * 0.5);
                    } else {
                        line(lemming.x + lemming.width * 0.3, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.15, lemming.y + lemming.height * 0.5);
                        line(lemming.x + lemming.width * 0.7, lemming.y + lemming.height * 0.4, 
                             lemming.x + lemming.width * 0.85, lemming.y + lemming.height * 0.6);
                    }
                    
                    // Head
                    fill(hairColor);
                    stroke(0);
                    ellipse(lemming.x + lemming.width/2, lemming.y + lemming.height/5, lemming.width * 0.65, lemming.width * 0.65);
                }
                
                // Face - for all lemmings
                if (!lemming.isBombing) {
                    fill(255);
                    noStroke();
                    // Eyes
                    ellipse(lemming.x + lemming.width/2 + lemming.width * 0.15, lemming.y + lemming.height/5, 3, 3);
                    
                    // Nose
                    fill(0);
                    ellipse(lemming.x + lemming.width/2 + lemming.width * 0.25, lemming.y + lemming.height/5 + 2, 2, 2);
                    
                    // Mouth
                    noFill();
                    stroke(0);
                    strokeWeight(0.8);
                    arc(lemming.x + lemming.width/2 + lemming.width * 0.15, lemming.y + lemming.height/5 + 5, 
                        6, 4, 0, PI);
                }
                
                // Draw bombing indicator
                if (lemming.isBombing) {
                    const bombProgress = lemming.bombTimer / lemming.bombLimit;
                    
                    // Countdown animation
                    if (frameCount % 10 < 5) {
                        fill(255, 0, 0, 200);
                        noStroke();
                        ellipse(lemming.x + lemming.width/2, lemming.y - 8, 12, 12);
                        
                        // Countdown numbers
                        fill(255);
                        textSize(8);
                        const countdown = Math.ceil((lemming.bombLimit - lemming.bombTimer) / 60);
                        text(countdown, lemming.x + lemming.width/2, lemming.y - 6);
                    }
                    
                    // Progress bar
                    fill(255, 0, 0);
                    noStroke();
                    rect(
                        lemming.x, 
                        lemming.y - 3, 
                        lemming.width * bombProgress, 
                        2
                    );
                    
                    // Sweat drops
                    if (frameCount % 15 < 8) {
                        fill(100, 200, 255);
                        noStroke();
                        ellipse(lemming.x + lemming.width * 0.8, lemming.y + lemming.height * 0.15, 3, 5);
                    }
                    
                    // Worried face
                    fill(255);
                    noStroke();
                    ellipse(lemming.x + lemming.width/2 + lemming.width * 0.15, lemming.y + lemming.height/5, 3, 3);
                    
                    // Worried mouth
                    stroke(0);
                    noFill();
                    strokeWeight(0.8);
                    arc(lemming.x + lemming.width/2 + lemming.width * 0.15, lemming.y + lemming.height/5 + 7, 
                        6, 4, PI, TWO_PI);
                }
                
                // Draw special ability indicators - small icons
                if (lemming.hasClimberAbility && !lemming.isClimbing) {
                    fill(40, 160, 40);
                    noStroke();
                    // Climber icon
                    rect(lemming.x, lemming.y - 3, 5, 3);
                    stroke(40, 160, 40);
                    strokeWeight(0.8);
                    line(lemming.x + 1, lemming.y - 2, lemming.x + 1, lemming.y - 5);
                    line(lemming.x + 4, lemming.y - 2, lemming.x + 4, lemming.y - 5);
                }
                
                if (lemming.hasFloaterAbility && !lemming.isFloating) {
                    fill(180, 30, 30);
                    noStroke();
                    // Floater icon (umbrella)
                    rect(lemming.x + lemming.width - 5, lemming.y - 3, 5, 3);
                    stroke(180, 30, 30);
                    strokeWeight(0.8);
                    arc(lemming.x + lemming.width - 2.5, lemming.y - 5, 4, 3, PI, TWO_PI);
                    line(lemming.x + lemming.width - 2.5, lemming.y - 5, lemming.x + lemming.width - 2.5, lemming.y - 3);
                }
                
                pop();
            });
        }
        
        function updateHUD() {
            document.getElementById('lemmings-saved').textContent = lemminsSaved;
            document.getElementById('time-display').textContent = formatTime(levelTime);
        }
    </script>
</body>
</html>
